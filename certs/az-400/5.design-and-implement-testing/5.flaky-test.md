# ğŸ¢ **Flaky Tests in CI/CD**

## ğŸ“Œ **1. What is a Flaky Test?**

A **flaky test** is a test that sometimes **passes âœ…** and sometimes **fails âŒ**, **without any change in the code**.

ğŸ‘‰ In other words:

- You run the same test, same code â†’ different outcomes.
- It makes pipelines **unreliable** and developers **lose trust** in tests.

---

<div align="center">
  <img src="image/5.flaky-test/1753646420386.png" alt="Flaky Test" style="border-radius: 10px; border: 2px solid; width: 100%">
</div>

---

## ğŸ“Œ **2. Why Flaky Tests are Dangerous**

- Wastes developer time debugging â€œfakeâ€ failures.
- Slows down CI/CD pipelines (re-runs, retries).
- Reduces confidence â†’ teams may start ignoring test failures (â€œoh, itâ€™s just that flaky test againâ€).
- Hides real bugs behind noise.

---

## ğŸ“Œ **3. Common Causes of Flaky Tests**

| Cause                         | Example                                                    |
| ----------------------------- | ---------------------------------------------------------- |
| **â³ Timing issues**          | UI test clicks before page finished loading                |
| **âš¡ Async race conditions**  | Two threads writing to DB â†’ unpredictable result           |
| **ğŸŒ External dependencies**  | API rate limits, network delay, DB server hiccup           |
| **ğŸ–¥ï¸ Environment dependency** | Test passes locally, fails in pipeline due to config or OS |
| **ğŸ”„ Shared state**           | Tests donâ€™t clean up â†’ leftover data causes random fails   |
| **ğŸ² Random data**            | Test relies on `DateTime.Now` or random IDs                |

---

## ğŸ“Œ **4. Example of a Flaky Test**

### âŒ Wrong

```csharp
[Test]
public void TestLoginButton()
{
    driver.Navigate().GoToUrl("https://myapp/login");
    driver.FindElement(By.Id("loginButton")).Click();
    var msg = driver.FindElement(By.Id("welcome")).Text;
    Assert.AreEqual("Welcome!", msg);
}
```

This might fail if the page hasnâ€™t finished loading yet.

---

### âœ… Fixed with Explicit Wait

```csharp
[Test]
public void TestLoginButton()
{
    driver.Navigate().GoToUrl("https://myapp/login");

    WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10));
    var button = wait.Until(drv => drv.FindElement(By.Id("loginButton")));
    button.Click();

    var msg = wait.Until(drv => drv.FindElement(By.Id("welcome"))).Text;
    Assert.AreEqual("Welcome!", msg);
}
```

---

## ğŸ“Œ **5. How to Handle Flaky Tests in Azure Pipelines**

### ğŸ”¹ Detecting Flaky Tests

- **Test history trend** â†’ If a test fails sometimes but passes on rerun, itâ€™s flaky.
- **Azure DevOps Test Analytics** â†’ highlights unstable tests.

### ğŸ”¹ Mitigating Flaky Tests

1. **Retries** (temporary relief, not a fix)

   ```yaml
   - task: DotNetCoreCLI@2
     inputs:
       command: "test"
       projects: "**/*Tests.csproj"
     retryCountOnTaskFailure: 2
   ```

   â†’ Will re-run test step if it fails.

2. **Isolate & quarantine** flaky tests

   - Move unstable tests into a separate pipeline stage.
   - Donâ€™t block main CI pipeline on them until fixed.

3. **Best practices to reduce flakiness**

   - Avoid hard-coded sleeps (`Thread.Sleep`) â†’ use **waits**.
   - Mock external services (DB, APIs) instead of hitting real ones.
   - Clean test data/state after every run.
   - Use deterministic data instead of random.

---

## ğŸ“Œ **What Azure DevOps Gives You**

<div align="center">
  <img src="image/5.flaky-test/1753646893756.png" alt="Flaky Test" style="border-radius: 10px; border: 2px solid white; width: 80%">
</div>

When you enable **Flaky Test Detection**, Azure DevOps will:

1. **Auto-detect flaky tests**

   - Azure looks at test execution history (pass/fail trend across builds).
   - If the same test is failing sometimes and passing sometimes â†’ itâ€™s marked as **flaky**.

2. **Auto-rerun failed tests**

   - If a test fails, Azure will rerun it in the same pipeline run.
   - If it passes on rerun â†’ Azure **flags it as flaky**, not a hard failure.
   - This prevents your pipeline from failing just because of one unreliable test.

3. **Flaky Test Insights in UI**

   - Youâ€™ll see a **â€œFlakyâ€ tag** next to test names in the Test tab of pipeline results.
   - Reports (Test Analytics) show a **Flaky Test trend chart** â†’ so you can identify which tests are unreliable.

---

### âš™ï¸ **Options**

#### ğŸ”¹ **System detection**

Azure Pipelines does the detection automatically using rerun + history. (Default & easiest)

#### ğŸ”¹ **Custom detection**

You plug in your own detection logic (rarely needed).

---

#### ğŸ”¹ **Flaky tests included in test pass percentage**

- **Checked (default):** flaky tests affect the pipeline status. If reruns fail, the pipeline fails.
- **Unchecked:** flaky tests are excluded from pass rate calculation â†’ pipeline may still pass even with flaky failures.

ğŸ’¡ If youâ€™re early in a project and have many flaky tests â†’ uncheck this so the team isnâ€™t blocked.
But best practice: keep it **checked** to force fixing them.

---

#### ğŸ”¹ **Allow users to manually mark/unmark flaky tests**

Lets developers flag/unflag tests as flaky right in Azure DevOps UI (if detection didnâ€™t catch it).
Useful for faster triage.

---

## ğŸ“Œ **Where You See Flaky Tests**

1. **Pipeline Run â†’ Tests Tab**

   - Youâ€™ll see results grouped as **Passed / Failed / Flaky**.
   - Example:

     - âœ… 100 tests passed
     - âŒ 2 tests failed
     - âš ï¸ 1 flaky test

2. **Analytics â†’ Test Results Trend**

   - Dedicated chart for flaky test trends.
   - Helps you track which test methods are unstable over time.

---

## ğŸ“Œ **Example Flow in Action**

1. You enable **Flaky Test Detection** in Project Settings.
2. Pipeline runs â†’ `OrderTests.CheckoutTest` fails.
3. Azure reruns that test automatically.

   - If it **passes on rerun** â†’ test marked as **Flaky** âš ï¸.
   - If it **fails again** â†’ stays as **Failed** âŒ.

4. In results, you see a **â€œFlakyâ€ badge** and Azure shows historical flaky % for that test.

---

## ğŸ“Œ **6. Best Practices for Stable Tests**

- âœ… Keep **unit tests** pure (no external deps).
- âœ… Use **integration test environments** (dedicated DB, test API).
- âœ… For UI tests â†’ use explicit waits, stable locators.
- âœ… Monitor test history to catch flakiness early.
- âœ… Fix root cause â€” retries should be temporary.
- âœ… **Enable rerun** â†’ prevents false negatives blocking CI.
- âœ… Use Analytics to **prioritize fixing flaky tests** (donâ€™t just ignore them).
- âœ… Keep **â€œincluded in pass %â€** checked to maintain test quality pressure.
- ğŸš« Donâ€™t rely on reruns forever â†’ fix root cause (waits, mocks, cleanup).

---

## ğŸ **TL;DR**

- A **flaky test** = sometimes passes, sometimes fails with no code change.
- Causes: timing issues, async, network, shared state, randomness.
- Impact: slows down pipelines, kills trust in tests.
- Fix: stable waits, mocks, cleanup, deterministic data.
- In Azure DevOps â†’ detect via test history, temporarily quarantine/retry, but always **fix root cause**.
