# âš¡ **Load Testing in Azure DevOps**

## ğŸ“Œ **What is Load Testing?**

ğŸ‘‰ Load Testing checks how your **app behaves under pressure** when **many users** or **many requests** hit it at once.

- **Goal:** Can the app **handle expected traffic** (or more) without crashing?
- **Focus:** Performance (response time), Stability, Scalability.
- **When used:** Before releasing to production OR when scaling infra.

ğŸ’¡ Analogy â†’ Like testing how much weight a bridge ğŸ— can carry before it cracks.

---

<div align="center">
  <img src="image/3.load-test/1753637240322.png" alt="Load Test" style="border-radius: 10px; width: 80%; border: 2px solid white;">
</div>

---

## ğŸ“Œ **Key Concepts**

| Term ğŸ”‘                | Meaning                                                             |
| ---------------------- | ------------------------------------------------------------------- |
| **Load**               | Number of users/requests hitting the system simultaneously          |
| **Throughput (RPS)**   | Requests per second your system can handle                          |
| **Latency/Response**   | Time taken to respond to requests                                   |
| **Error Rate**         | Percentage of failed requests                                       |
| **Scalability**        | How well the system handles increased load (linear or bottlenecked) |
| **Baseline vs Stress** | Normal expected traffic vs extreme beyond limits                    |

---

## ğŸ“Œ **Types of Load Tests**

1. **Load Test** â†’ Normal expected traffic (e.g., 1,000 users)
2. **Stress Test** â†’ Beyond normal (e.g., 10,000 users, see where it breaks)
3. **Spike Test** â†’ Sudden traffic jump (e.g., Black Friday sales)
4. **Soak Test** â†’ Long-duration test (e.g., 500 users for 12 hours, check memory leaks)

---

## ğŸ“Œ **Tools in Azure World**

- ğŸ”¹ **Azure Load Testing Service** (fully managed, integrates with DevOps pipelines)
- ğŸ”¹ **Apache JMeter** (classic, open-source; Azure Load Testing runs JMeter scripts)
- ğŸ”¹ **k6** (modern open-source, CLI-based load testing tool)

ğŸ‘‰ For DevOps pipelines, **Azure Load Testing** is the most seamless.

---

## ğŸ“Œ **How Azure Load Testing Works**

<div align="center">

```mermaid
flowchart TD
    A[Pipeline Trigger] --> B[Load Test Task]
    B --> C[Azure Load Testing Service]
    C --> D[Target App Service / API / Website]
    D --> E[Telemetry â†’ App Insights + Azure Monitor]
    E --> F[Pipeline Quality Gate Results]
```

</div>

**Flow:**

1. Pipeline triggers load test â†’
2. Azure Load Testing spins up engines â†’
3. Engines hammer your API/App â†’
4. Results + telemetry collected â†’
5. Pipeline marks success/failure based on thresholds.

---

## ğŸ“Œ **CI/CD Pipeline Example**

<div align="center">
  <img src="image/3.load-test/1753640749914.png" alt="Load Test" style="border-radius: 10px; width: 80%; border: 2px solid white;">
</div>

---

### ğŸ”¹ Load Test YAML (Azure Pipeline)

```yaml
stages:
  - stage: LoadTest
    jobs:
      - job: RunLoadTest
        pool:
          vmImage: "ubuntu-latest"
        steps:
          - task: AzureLoadTest@1
            inputs:
              azureSubscription: "MyServiceConnection" # ARM service connection (SP)
              resourceGroup: "rg-loadtest"
              loadTestResource: "my-loadtest-service"
              loadTestConfigFile: "loadtest-config.yaml"
```

### ğŸ”¹ loadtest-config.yaml (JMeter-based)

```yaml
version: v0.1
testId: "dotnet-api-loadtest"
displayName: ".NET API Load Test"
testPlan: "tests/my-test.jmx"
engineInstances: 2
failureCriteria:
  - avg(response_time_ms) > 2000
  - percentage(error) > 1
```

ğŸ‘‰ This says:

- Run test with 2 load engines.
- Fail pipeline if **avg response > 2s** OR **error rate > 1%**.

---

## ğŸ“Œ **Where Results Appear**

- **Azure DevOps â†’ Pipeline run** â†’ Quality Gate results
- **Azure Portal â†’ Azure Load Testing resource** â†’ Graphs:

  - Response time distribution
  - Error % over time
  - Requests per second

- **App Insights integration** â†’ Drill down to see bottlenecks (DB slow? CPU spike?).

---

## ğŸ“Œ **Best Practices**

- âœ… Start with **baseline load** (normal usage)
- âœ… Define **SLOs/SLAs** (e.g., p95 < 1s, error < 1%)
- âœ… Use **realistic scenarios** (login, checkout, search)
- âœ… Run in **staging** first, then production shadow mode
- âœ… Automate in pipeline â†’ fail build if thresholds are exceeded
- âœ… Pair with **Application Insights** for root cause (server vs DB vs cache)

---

## ğŸ **TL;DR**

- **Load Testing** = Can your app survive real-world traffic?
- **Azure Load Testing** runs JMeter scripts inside Azure.
- In pipelines: **add a stage** â†’ run load test â†’ set **failure criteria** â†’ block bad builds.
- Use results in **Azure Monitor/App Insights** for bottleneck analysis.
