# 📊 **Code Coverage in Testing**

## 📌 **What is Code Coverage?**

- **Code coverage** measures **how much of your source code is executed by automated tests** (unit, integration, etc.).
- It answers the question:

  > “When I run my tests, which parts of the code are actually tested, and which parts are never touched?”

👉 Example:

```csharp
public int Divide(int a, int b)
{
    if (b == 0)
        throw new DivideByZeroException();

    return a / b;
}
```

- If your tests **only call `Divide(10, 2)`** →  
  ✅ The division line is covered.  
  ❌ The `b == 0` branch is **not covered**.

---

## 🛒 Example: `CheckoutService` in an E-Commerce App

```csharp
public class CheckoutService
{
    public decimal CalculateTotal(decimal cartTotal, string couponCode, bool isPremiumUser)
    {
        decimal discount = 0;

        // Case 1: Premium users always get 10% off
        if (isPremiumUser)
        {
            discount = cartTotal * 0.10m;
        }

        // Case 2: Coupons
        if (!string.IsNullOrEmpty(couponCode))
        {
            if (couponCode == "SAVE20")
                discount = Math.Max(discount, cartTotal * 0.20m);
            else if (couponCode == "FREESHIP" && cartTotal >= 50)
                discount = Math.Max(discount, 5); // fixed 5 discount for shipping
        }

        decimal total = cartTotal - discount;

        // Case 3: Never allow negative totals
        if (total < 0)
            total = 0;

        return total;
    }
}
```

---

### 🧪 Unit Tests (with Coverage Scenarios)

```csharp
[TestClass]
public class CheckoutServiceTests
{
    private CheckoutService service = new CheckoutService();

    [TestMethod]
    public void PremiumUser_Gets10PercentDiscount()
    {
        var result = service.CalculateTotal(100, null, true);
        Assert.AreEqual(90, result); // ✅ covers premium user path
    }

    [TestMethod]
    public void Coupon_Save20_Applies20PercentDiscount()
    {
        var result = service.CalculateTotal(100, "SAVE20", false);
        Assert.AreEqual(80, result); // ✅ covers SAVE20 path
    }

    [TestMethod]
    public void Coupon_FreeShip_AppliesFixedDiscount_WhenEligible()
    {
        var result = service.CalculateTotal(60, "FREESHIP", false);
        Assert.AreEqual(55, result); // ✅ covers FREESHIP path
    }

    [TestMethod]
    public void NegativeTotal_BecomesZero()
    {
        var result = service.CalculateTotal(10, "SAVE20", true);
        Assert.AreEqual(0, result); // ✅ covers negative total safeguard
    }
}
```

---

### 📊 Code Coverage Report

Let’s imagine you only wrote **2 tests**:

- Premium user discount
- Coupon SAVE20

Coverage would look like this:

- **Premium user branch** → ✅ Covered
- **SAVE20 coupon branch** → ✅ Covered
- **FREESHIP coupon branch** → ❌ Not covered
- **Negative total safeguard** → ❌ Not covered

Result:

- **Line coverage**: \~60%
- **Branch coverage**: 50%

---

When you add the other 2 tests (FREESHIP + negative total):

- Now **all branches** are executed.
- Line coverage jumps to **100%**.
- Branch coverage = **100%**.

👉 But remember: even with 100%, bugs can still hide if assertions are wrong (e.g., you test FREESHIP but assert against the wrong value).

---

## 📌 **Why is Code Coverage Important?**

- 🎯 **Ensures tests are meaningful** → you’re not just testing “happy paths.”
- 🐛 **Catches untested code** → which could hide bugs.
- 📈 **Quality metric** → DevOps teams often set a minimum coverage threshold (e.g., 80%).
- 🔎 **Helps identify dead/unreachable code**.

⚠️ **Myth:** 100% coverage ≠ bug-free code.
It only means “every line ran during a test,” not that logic is correct.

---

## 📌 **Types of Code Coverage**

| Type                   | Meaning                                                           |
| ---------------------- | ----------------------------------------------------------------- |
| **Line coverage**      | % of lines executed by tests                                      |
| **Branch coverage**    | % of decision paths tested (e.g., `if/else`)                      |
| **Method coverage**    | % of methods invoked at least once                                |
| **Condition coverage** | Tests if boolean conditions were evaluated to both true and false |

👉 Most tools (like .NET Coverlet, JaCoCo for Java, Istanbul for JS) give **line + branch coverage**.

---

## 📌 **Common Code Coverage Tools**

Here’s a cheat sheet of the most used tools in industry (and likely to come up in interviews/exams):

| Language / Stack  | Common Coverage Tools                         | Notes                                                     |
| ----------------- | --------------------------------------------- | --------------------------------------------------------- |
| **.NET / C#**     | Coverlet, dotCover, Visual Studio built-in    | Coverlet integrates with `dotnet test` + Cobertura output |
| **Java**          | JaCoCo, Cobertura, Clover                     | JaCoCo is standard for Maven/Gradle builds                |
| **JavaScript/TS** | Istanbul (nyc), Jest built-in, Karma coverage | Works with Node, Angular, React                           |
| **Python**        | Coverage.py, pytest-cov                       | Generates XML/HTML for pipelines                          |
| **C / C++**       | gcov, lcov, llvm-cov                          | Integrated with GCC/Clang                                 |
| **Go**            | go test -cover                                | Built into Go toolchain                                   |
| **Ruby**          | SimpleCov                                     | Popular in Rails projects                                 |
| **PHP**           | PHPUnit (with Xdebug or phpdbg)               | Coverage integrated                                       |
| **Swift / iOS**   | Xcode built-in, Slather                       | CocoaPods + Xcode integration                             |
| **Kotlin**        | JaCoCo (same as Java)                         | Works with Gradle/Kotlin DSL                              |

👉 Azure Pipelines doesn’t compute coverage by itself. You use these tools to generate reports (XML/JSON), then feed them into:

```yaml
- task: PublishCodeCoverageResults@2
```

to see it in the DevOps UI.

---

## 📌 **Code Coverage in Azure Pipelines**

Azure DevOps doesn’t compute coverage itself. Instead:

1. Your test runner (e.g., **Coverlet** for .NET, **Istanbul** for Node/Angular) produces a coverage report (XML/JSON).
2. Azure Pipeline’s **PublishCodeCoverageResults\@2** task reads that report and shows it in the pipeline UI.

---

## 📌 **Implementation for a .NET App**

### 🔹 Step 1: Add Coverlet

Coverlet integrates with `dotnet test`.
Install package in your test project:

```bash
dotnet add package coverlet.collector
```

---

### 🔹 Step 2: Run Tests with Coverage

Run locally:

```bash
dotnet test MyApp.Tests.csproj \
  /p:CollectCoverage=true \
  /p:CoverletOutput=./TestResults/coverage.cobertura.xml \
  /p:CoverletOutputFormat=cobertura
```

This generates `coverage.cobertura.xml`.

---

### 🔹 Step 3: Azure Pipeline YAML

```yaml
trigger:
  - main

pool:
  vmImage: "windows-latest"

steps:
  - task: UseDotNet@2
    inputs:
      packageType: sdk
      version: "8.0.x"

  - script: dotnet restore MyApp.sln
    displayName: "Restore"

  - script: dotnet build MyApp.sln --configuration Release --no-restore
    displayName: "Build"

  - script: dotnet test MyApp.Tests/MyApp.Tests.csproj \
      --configuration Release \
      --no-build \
      /p:CollectCoverage=true \
      /p:CoverletOutput=$(Common.TestResultsDirectory)/ \
      /p:CoverletOutputFormat=cobertura \
      --logger "trx;LogFileName=unit.trx"
    displayName: "Run Tests with Coverage"

  - task: PublishTestResults@2
    displayName: "Publish test results"
    condition: always()
    inputs:
      testResultsFiles: "$(Common.TestResultsDirectory)/**/*.trx"
      testRunTitle: "Unit Tests"

  - task: PublishCodeCoverageResults@2
    displayName: "Publish code coverage"
    inputs:
      codeCoverageTool: "Cobertura"
      summaryFileLocation: "$(Common.TestResultsDirectory)/coverage.cobertura.xml"
      reportDirectory: "$(Common.TestResultsDirectory)"
```

---

## 📌 **Where You See Results**

After running pipeline:

- **Tests tab** → pass/fail results.
- **Code Coverage tab** → a report like:

```ini
Overall coverage: 76%
Classes: 80% covered
Methods: 78% covered
Lines: 76% covered
Branches: 65% covered
```

👉 Azure DevOps even lets you **drill into files** to see which lines are covered vs missed.

---

## 📌 **Best Practices**

- 🎯 Aim for **70–80% coverage** — enough to build confidence.
- 🚫 Don’t chase 100% — you’ll waste time testing trivial code.
- ✅ Focus coverage on **critical business logic** (not getters/setters).
- 🔄 Combine coverage with **quality gates** (SonarQube, SonarCloud) to enforce standards.

---

## 🏁 **TL;DR**

- Code coverage = how much of your code is tested.
- Helps ensure tests actually execute important code.
- Implement with tools like **Coverlet (for .NET)**, **Istanbul (JS)**, **JaCoCo (Java)**.
- Azure DevOps shows coverage when you **publish results** with `PublishCodeCoverageResults@2`.
