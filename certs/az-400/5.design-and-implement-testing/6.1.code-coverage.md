# 📊 **Code Coverage in Testing**

## 📌 **1. What is Code Coverage?**

- **Code coverage** measures **how much of your source code is executed by automated tests** (unit, integration, etc.).
- It answers the question:

  > “When I run my tests, which parts of the code are actually tested, and which parts are never touched?”

👉 Example:

```csharp
public int Divide(int a, int b)
{
    if (b == 0)
        throw new DivideByZeroException();

    return a / b;
}
```

- If your tests **only call `Divide(10, 2)`** →  
  ✅ The division line is covered.  
  ❌ The `b == 0` branch is **not covered**.

---

## 📌 **2. Why is Code Coverage Important?**

- 🎯 **Ensures tests are meaningful** → you’re not just testing “happy paths.”
- 🐛 **Catches untested code** → which could hide bugs.
- 📈 **Quality metric** → DevOps teams often set a minimum coverage threshold (e.g., 80%).
- 🔎 **Helps identify dead/unreachable code**.

⚠️ **Myth:** 100% coverage ≠ bug-free code.
It only means “every line ran during a test,” not that logic is correct.

---

## 📌 **3. Types of Code Coverage**

| Type                   | Meaning                                                           |
| ---------------------- | ----------------------------------------------------------------- |
| **Line coverage**      | % of lines executed by tests                                      |
| **Branch coverage**    | % of decision paths tested (e.g., `if/else`)                      |
| **Method coverage**    | % of methods invoked at least once                                |
| **Condition coverage** | Tests if boolean conditions were evaluated to both true and false |

👉 Most tools (like .NET Coverlet, JaCoCo for Java, Istanbul for JS) give **line + branch coverage**.

---

## 📌 **4. Code Coverage in Azure Pipelines**

Azure DevOps doesn’t compute coverage itself. Instead:

1. Your test runner (e.g., **Coverlet** for .NET, **Istanbul** for Node/Angular) produces a coverage report (XML/JSON).
2. Azure Pipeline’s **PublishCodeCoverageResults\@2** task reads that report and shows it in the pipeline UI.

---

## 📌 **5. Implementation for a .NET App**

### 🔹 Step 1: Add Coverlet

Coverlet integrates with `dotnet test`.
Install package in your test project:

```bash
dotnet add package coverlet.collector
```

---

### 🔹 Step 2: Run Tests with Coverage

Run locally:

```bash
dotnet test MyApp.Tests.csproj \
  /p:CollectCoverage=true \
  /p:CoverletOutput=./TestResults/coverage.cobertura.xml \
  /p:CoverletOutputFormat=cobertura
```

This generates `coverage.cobertura.xml`.

---

### 🔹 Step 3: Azure Pipeline YAML

```yaml
trigger:
  - main

pool:
  vmImage: "windows-latest"

steps:
  - task: UseDotNet@2
    inputs:
      packageType: sdk
      version: "8.0.x"

  - script: dotnet restore MyApp.sln
    displayName: "Restore"

  - script: dotnet build MyApp.sln --configuration Release --no-restore
    displayName: "Build"

  - script: dotnet test MyApp.Tests/MyApp.Tests.csproj \
      --configuration Release \
      --no-build \
      /p:CollectCoverage=true \
      /p:CoverletOutput=$(Common.TestResultsDirectory)/ \
      /p:CoverletOutputFormat=cobertura \
      --logger "trx;LogFileName=unit.trx"
    displayName: "Run Tests with Coverage"

  - task: PublishTestResults@2
    displayName: "Publish test results"
    condition: always()
    inputs:
      testResultsFiles: "$(Common.TestResultsDirectory)/**/*.trx"
      testRunTitle: "Unit Tests"

  - task: PublishCodeCoverageResults@2
    displayName: "Publish code coverage"
    inputs:
      codeCoverageTool: "Cobertura"
      summaryFileLocation: "$(Common.TestResultsDirectory)/coverage.cobertura.xml"
      reportDirectory: "$(Common.TestResultsDirectory)"
```

---

## 📌 **6. Where You See Results**

After running pipeline:

- **Tests tab** → pass/fail results.
- **Code Coverage tab** → a report like:

```ini
Overall coverage: 76%
Classes: 80% covered
Methods: 78% covered
Lines: 76% covered
Branches: 65% covered
```

👉 Azure DevOps even lets you **drill into files** to see which lines are covered vs missed.

---

## 📌 **7. Best Practices**

- 🎯 Aim for **70–80% coverage** — enough to build confidence.
- 🚫 Don’t chase 100% — you’ll waste time testing trivial code.
- ✅ Focus coverage on **critical business logic** (not getters/setters).
- 🔄 Combine coverage with **quality gates** (SonarQube, SonarCloud) to enforce standards.

---

## 🏁 **TL;DR**

- Code coverage = how much of your code is tested.
- Helps ensure tests actually execute important code.
- Implement with tools like **Coverlet (for .NET)**, **Istanbul (JS)**, **JaCoCo (Java)**.
- Azure DevOps shows coverage when you **publish results** with `PublishCodeCoverageResults@2`.
