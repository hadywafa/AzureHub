# ğŸŒ± **Git Internals**

## ğŸ“Œ **1. What is Git Really?**

- Git is a **distributed version control system (DVCS)**.
- Itâ€™s not just a code hosting tool â†’ itâ€™s a **content-addressable filesystem with a fancy CLI**.
- Under the hood:

  - Every commit, tree, and blob is just a **file object identified by a SHA-1/SHA-256 hash**.
  - Git is like a **key-value database** where:

    - Key = hash (commit ID)
    - Value = object (file, directory tree, or commit metadata).

ğŸ’¡ Think of Git as **a mini database optimized for code history**.

---

## ğŸ“Œ **2. Core Building Blocks**

### ğŸ”¹ **Objects (inside `.git/objects`)**

There are 4 fundamental Git object types:

1. **Blob** â†’ file contents (just raw bytes of a file).
2. **Tree** â†’ directory structure (list of file names + blobs/trees).
3. **Commit** â†’ snapshot of a tree + metadata (author, timestamp, parent commit hash).
4. **Tag** â†’ pointer to a commit with a human-friendly label.

---

### ğŸ”¹ **References (inside `.git/refs`)**

- Refs are **pointers** to commits (e.g., `refs/heads/main`).
- `HEAD` is a special ref that tells Git â€œwhere you are right now.â€

---

### ğŸ”¹ **Index (Staging Area)**

- A binary file (`.git/index`) that stores a snapshot of whatâ€™s staged for commit.
- Think of it as the â€œshopping cartâ€ before checkout.

---

### ğŸ”¹ **Packfiles**

- To save space, Git compresses objects into `.pack` files.
- Helps when repos get huge (millions of objects).

---

## ğŸ“Œ **3. How Git Records History**

Git doesnâ€™t store **diffs** (like SVN or Perforce). Instead:

- Every commit = a **snapshot of the whole project tree**.
- But thanks to object deduplication, unchanged files donâ€™t get copied â†’ Git just reuses the same blob hash.

ğŸ’¡ This makes Git **fast to branch and merge**, because commits are just pointers to snapshots.

---

## ğŸ“Œ **4. Example: Creating a Commit Internally**

Letâ€™s say you add a file `hello.txt` with `"Hello World"`:

1. `git add hello.txt`

   - Git creates a **blob object** for file contents.
   - Updates `.git/index` to stage that blob.

2. `git commit -m "Add hello.txt"`

   - Git creates a **tree object** that lists `hello.txt â†’ blob_hash`.
   - Creates a **commit object** that points to that tree (and previous commit if any).
   - Stores commit in `.git/objects/<hash>`.
   - Updates `refs/heads/main` to point to the new commit.

---

## ğŸ“Œ **5. Branching & Merging Internals**

- **Branch = just a ref (pointer) to a commit.**
- Creating a branch is literally writing a new text file under `.git/refs/heads/feature-x` with a commit hash.
- **Merging** means Git finds the **lowest common ancestor commit** and applies a **three-way merge**.
- **Rebasing** is replaying commits one by one onto another branch by creating new commit objects.

---

## ğŸ“Œ **6. Distributed Nature**

Every developerâ€™s `.git` folder is a **full copy of the database** (all commits, all branches).

- `git push` â†’ moves refs & objects to remote.
- `git fetch/pull` â†’ retrieves refs & objects from remote.
- Remote repos (like GitHub/Azure Repos) are just **bare repos** (no working directory, only `.git` data).

---

## ğŸ“Œ **7. Investigating Internals**

Try these commands in any repo:

```bash
# Show commit object contents
git cat-file -p <commit_hash>

# Show tree contents
git ls-tree <commit_hash>

# Show low-level history graph
git log --graph --oneline --decorate
```

---

## ğŸ“Œ **8. Diagram â€“ Git Objects**

```mermaid
graph TD
  blob1[Blob: hello.txt] --> tree1[Tree: root dir]
  tree1 --> commit1["Commit A: "Initial commit""]
  commit1 --> commit2["Commit B: "Add feature""]
  commit2 --> commit3["Commit C: "Fix bug""]

  branch1[main ref] --> commit3
  HEAD --> branch1
```

---

## ğŸ“Œ **9. Why Engineers Love Git**

- âš¡ **Fast** â†’ local history = no server trips.
- ğŸ”€ **Branching/merging is cheap** â†’ just pointer manipulation.
- ğŸ›¡ï¸ **Integrity** â†’ every object is hashed, so corruption is detected.
- ğŸŒ **Distributed** â†’ no single point of failure.
- ğŸ“š **History is immutable** â†’ you can add commits, but existing commits never change (unless you rewrite history).

---

## ğŸ”¬ **Inside Git: Commit Lifecycle Walkthrough**

### ğŸ“Œ **1. Init a Repo**

```bash
mkdir git-internals-demo
cd git-internals-demo
git init
```

ğŸ‘‰ Creates `.git/` folder â€” Gitâ€™s **database + config**.

```bash
ls .git
# HEAD  config  description  hooks/  info/  objects/  refs/
```

---

### ğŸ“Œ **2. Add a File**

```bash
echo "Hello World" > hello.txt
git add hello.txt
```

What happened internally?

- Git created a **blob object** for `hello.txt` contents.
- Blob = compressed file contents + header.
- Stored in `.git/objects/<2-char-prefix>/<rest-of-hash>`.

Check it:

```bash
git hash-object hello.txt
# e.g. aef3b2c8d7...
```

```bash
ls .git/objects/aef3b2
# contains file named "c8d7..."
```

ğŸ‘‰ Thatâ€™s the **blob**.

---

### ğŸ“Œ **3. Make the Commit**

```bash
git commit -m "Initial commit"
```

Now Git creates:

1. **Tree object** â†’ describes directory layout (file name â†’ blob hash).
2. **Commit object** â†’ points to the tree + metadata (author, date, message).
3. Updates `refs/heads/main` to point to this commit.

Inspect commit:

```bash
git log --oneline
# a1b2c3d Initial commit
```

Inspect commit object:

```bash
git cat-file -p a1b2c3d
```

Output looks like:

```ini
tree 4e935df2...
author Alice <alice@example.com>  1724948160 +0200
committer Alice <alice@example.com>  1724948160 +0200

Initial commit
```

ğŸ‘‰ Commit points to a **tree**.

---

### ğŸ“Œ **4. Inspect Tree**

```bash
git cat-file -p 4e935df2...
```

Example output:

```ini
100644 blob aef3b2c8d7...    hello.txt
```

ğŸ‘‰ This tree maps:

- `hello.txt` â†’ blob (`Hello World`).

---

### ğŸ“Œ **5. Verify Blob**

```bash
git cat-file -p aef3b2c8d7...
```

Output:

```ini
Hello World
```

ğŸ‘‰ Thatâ€™s your file content.

---

### ğŸ“Œ **6. Branch and HEAD**

- `refs/heads/main` â†’ contains commit hash.
- `HEAD` â†’ points to current branch.

```bash
cat .git/refs/heads/main
# a1b2c3d...
```

```bash
cat .git/HEAD
# ref: refs/heads/main
```

So:

```ini
HEAD â†’ refs/heads/main â†’ commit â†’ tree â†’ blob
```

---

### ğŸ“Œ **7. Diagram of What We Just Did**

```mermaid
graph TD
  blob1["Blob: hello.txt "Hello World""] --> tree1[Tree: root dir]
  tree1 --> commit1["Commit: "Initial commit""]
  commit1 --> ref1[refs/heads/main]
  HEAD --> ref1
```

---

### ğŸ“Œ **8. Key Takeaways**

- **Blob** = file contents.
- **Tree** = directory structure.
- **Commit** = snapshot + metadata + parent pointer(s).
- **Refs** = named pointers (branches, tags).
- **HEAD** = where you are.

---

## ğŸ **TL;DR**

- Git = a **content-addressable database** with blobs (files), trees (dirs), commits (snapshots), and refs (pointers).
- A commit = snapshot + pointer to parent commits.
- Branch = pointer to a commit.
- Merge = three-way reconciliation of snapshots.
- Every `.git` is a full repo copy.
- Thatâ€™s why Git is **fast, reliable, and distributed**.
