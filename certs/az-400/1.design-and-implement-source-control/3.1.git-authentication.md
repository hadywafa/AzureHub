# ğŸ” **Git Authentication**

## ğŸ“Œ **Git is Just Transport + Identity**

- Git itself doesnâ€™t â€œauthenticate.â€
- When you `git push` or `git pull`, Git relies on the **transport protocol** (HTTPS, SSH, or local file system).
- Authentication depends on the transport.

ğŸ‘‰ So: **Git Auth = Transport Auth.**

---

### âœğŸ» Example GitHub repo

```bash
https://github.com/myorg/myrepo.git
```

- This URL just says:

  - **Protocol** â†’ HTTPS
  - **Host** â†’ github.com
  - **Path** â†’ myorg/myrepo.git

ğŸ‘‰ It doesnâ€™t say _how_ you authenticate.

---

## ğŸ“Œ **The Main Authentication Methods**

### ğŸ”¹ 1.1 **HTTPS + Username/Password (deprecated ğŸš«)**

- Old way: you typed your GitHub/GitLab/Azure DevOps username + password.
- Disabled everywhere because of **security risks** (no MFA, easy leaks).

**Example (no longer works):**

```bash
git clone https://github.com/org/repo.git
# Username: alice
# Password: <account password>
```

ğŸ‘‰ Today replaced with **Tokens** or **OAuth**.

---

### ğŸ”¹ 1.2 **HTTPS + Personal Access Tokens (PATs)**

- A **token string** replaces your password.
- You generate it in GitHub/GitLab/Azure DevOps settings.
- Scoped: only access repos, or also issues, workflows, etc.
- Stored in keychain (via GCM) or typed manually.

**Example:**

```bash
git clone https://github.com/org/repo.git
# Username: alice
# Password: ghp_xxxxxxxx (PAT token)
```

ğŸ‘‰ Still very common in **CI/CD pipelines** and for **service accounts**.

---

### ğŸ”¹ 1.3 **HTTPS + OAuth (Device Flow or Browser Login)**

- Modern & secure â†’ integrates with SSO/MFA.
- You login via browser/device code.
- Token is issued â†’ cached in OS keychain.
- GCM automates this flow.

**Example (GitHub with GCM):**

```bash
git clone https://github.com/org/repo.git
# Opens browser â†’ login with GitHub account â†’ MFA â†’ token stored
```

ğŸ‘‰ Best for **human developers**.

---

### ğŸ”¹ 2. **SSH Keys ğŸ”‘**

- Public/private keypair stored locally (`~/.ssh/id_rsa`).
- Public key uploaded to GitHub/GitLab/Azure DevOps.
- No password each time; authentication handled by cryptography.

**Example:**

```bash
ssh-keygen -t ed25519 -C "alice@example.com"
# upload ~/.ssh/id_ed25519.pub to GitHub
git clone git@github.com:org/repo.git
```

ğŸ‘‰ Very common in **CI/CD runners** and **advanced users**.

---

### ğŸ”¹ 3. **Kerberos / NTLM / LDAP (Enterprise On-Prem Git)**

- Used in **corporate Git servers** (e.g., Bitbucket Server, GitLab EE with LDAP).
- Auth integrated with enterprise directory.
- Rare in public GitHub/Azure/GitLab Cloud.

---

## ğŸ’¡ **Credential Helpers (Manager, Cache, Store)**

Git lets you **store/retrieve credentials** via helpers:

- `cache` â†’ memory only (for a few minutes).
- `store` â†’ plaintext on disk (âŒ insecure).
- `manager` (GCM) â†’ secure in OS keychain.

**Example:**

```bash
git config --global credential.helper manager
# next time you login â†’ stored securely in Windows Credential Manager/macOS Keychain
```

---

## ğŸ“Œ **Real-Life Provider Examples**

### ğŸ™ GitHub

- HTTPS: OAuth (preferred), PATs (fallback).
- SSH: supported.

### ğŸ¦Š GitLab

- HTTPS: PATs or OAuth (depends on org).
- SSH: supported.

### ğŸŸ¦ Azure DevOps

- HTTPS: Entra ID OAuth (preferred), PATs (fallback).
- SSH: supported but less common.

---

## ğŸ’³ **Authentication Challenge**

When you run:

```bash
git clone https://github.com/myorg/myrepo.git
```

1. Git contacts `https://github.com`.
2. Server replies:

   - "Who are you? Send credentials (401 Unauthorized)."

3. Git asks your **credential helper** (like GCM) or the user for credentials.
4. Depending on config, you provide:

   - ğŸ›‘ **(Old) Password** â†’ rejected now
   - ğŸ”‘ **PAT** â†’ accepted as password
   - ğŸŒ **OAuth Device Flow (GCM)** â†’ redirect to login, fetch token
   - ğŸ”’ **Stored token in Keychain** â†’ silently sent

---

## ğŸ“Œ **How They Differ Internally**

| Method                  | What Git Sends in HTTPS request                                                                |
| ----------------------- | ---------------------------------------------------------------------------------------------- |
| **Old Password**        | `Authorization: Basic <base64(user:password)>`                                                 |
| **PAT**                 | `Authorization: Basic <base64(user:PAT)>` (user can be anything, often `username` or `oauth2`) |
| **OAuth / Device Flow** | `Authorization: Bearer <OAuth token>` (retrieved by GCM after login)                           |
| **GCM cached token**    | Same as above, but pulled from secure keychain silently                                        |

So the **repo URL stays the same** â†’ but the **HTTP Authorization header changes**.

---

## ğŸ“Œ **Example with GitHub**

ğŸ”¹ Using a PAT:

```bash
git clone https://github.com/myorg/myrepo.git
# Username: alice
# Password: ghp_xxxxxxxx   <-- this is the PAT
```

Internally Git sends:

```ini
Authorization: Basic YWxpY2U6Z2hwX3h4eHh4eHh4
```

ğŸ”¹ Using OAuth (via GCM):

```bash
git clone https://github.com/myorg/myrepo.git
# Browser opens â†’ login with MFA
```

Internally Git sends:

```ini
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6...
```

---

## ğŸ“Œ **Why Same URL is Fine**

- The **server (GitHub/GitLab/Azure DevOps)** decides what kind of credential it will accept.
- Your **credential helper (GCM, SSH agent, PAT prompt)** decides what to provide.
- As long as the credential is valid â†’ access is granted.

ğŸ‘‰ Thatâ€™s why **URL doesnâ€™t change for HTTPS**, only **auth header changes**.

---

## ğŸ“Œ **SSH is Different**

For SSH, the URL changes because the **protocol** changes:

```bash
git@github.com:myorg/myrepo.git
```

This tells Git to use SSH, not HTTPS.
Auth here = **public/private keypair**, not tokens.

---

## ğŸ“Œ **CI/CD Authentication**

In pipelines (no humans):

- **PATs** â†’ easiest (store as secret in GitHub Actions/Azure DevOps).
- **Service Principals** â†’ in Azure DevOps when accessing Azure.
- **Deploy keys (SSH)** â†’ repo-scoped, safe for bots.

Example (Azure DevOps pipeline pulling repo via PAT):

```yaml
variables:
  GIT_TOKEN: $(System.AccessToken)

steps:
  - script: |
      git clone https://$(GIT_TOKEN)@dev.azure.com/org/project/_git/repo
```

---

## ğŸ“Œ **Diagram of Auth Options**

```mermaid
flowchart TD
    A[Developer/CI] -->|HTTPS Password| X[Deprecated âŒ]
    A -->|HTTPS PAT| B[Token-based Auth]
    A -->|HTTPS OAuth| C[SSO + MFA]
    A -->|SSH Key| D[Cryptographic Auth]
    A -->|Kerberos/LDAP| E[Enterprise On-Prem]
```

---

## ğŸ“Œ **Best Practices**

- âœ… Use **OAuth device flow** (with GCM) for humans â†’ seamless + MFA.
- âœ… Use **PATs or SSH keys** for CI/CD pipelines â†’ stable and scriptable.
- âœ… Store secrets in **secure vaults** (Azure Key Vault, GitHub Secrets).
- âŒ Never use passwords or plaintext `credential.store`.
- **HTTPS + PAT** â†’ easiest, most common for humans.
- **SSH** â†’ great for developers, no password prompts.
- **OAuth (via GCM)** â†’ best for enterprises with SSO + MFA.
- **Deploy Keys/Machine Users** â†’ best for automation.
- `.gitconfig` decides _which helper_ stores/fetches credentials (store, manager, cache).

---

## ğŸ **TL;DR**

- Git itself doesnâ€™t do auth â†’ it delegates to transport (HTTPS, SSH, etc.).
- Modern auth = **Tokens (PATs)**, **OAuth (device flow)**, or **SSH keys**.
- Humans â†’ OAuth/GCM (best UX).
- Machines â†’ PATs or SSH keys.
- Old password auth is dead.
