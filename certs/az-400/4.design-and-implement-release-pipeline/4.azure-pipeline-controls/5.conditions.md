# ğŸ›ï¸ Azure Pipeline Conditions

Conditions allow you to **control when** a **step**, **job**, or **stage** should run. These can be based on:

- Pipeline result (succeeded, failed, canceled)
- Variable values
- Custom expressions
- Dependencies (e.g., only if another job succeeded)

---

## ğŸ§  SYNTAX OVERVIEW

```yaml
condition: <expression>
```

Expression must evaluate to `true` for the step/job/stage to run.

Built-in functions:

- `succeeded()`
- `failed()`
- `succeededOrFailed()`
- `canceled()`
- `always()`
- `eq()`, `ne()`, `contains()`
- `and()`, `or()`, `not()`

---

## ğŸ§ª Sample Usage

### âœ… 1. Run only if a job succeeded

```yaml
jobs:
  - job: Build
    steps:
      - script: echo "Building..."

  - job: Deploy
    dependsOn: Build
    condition: succeeded() # âœ… Run only if 'Build' succeeded
    steps:
      - script: echo "Deploying..."
```

---

### âŒ 2. Run only if a job failed

```yaml
- job: NotifyFailure
  dependsOn: Build
  condition: failed() # âŒ Run only if Build failed
  steps:
    - script: echo "Build failed! Notifying..."
```

---

### ğŸ“‘ 3. Run even if a previous dependency fails, unless the run is canceled.

This condition ensures the task runs unless the pipeline is canceled â€” perfect for publishing results even when tests fail, which is critical for debugging and visibility in CI/CD flows

```yaml
- task: PublishTestResults@2
  displayName: "Publish Test Results"
  condition: succeededOrFailed()
  inputs:
    testResultsFiles: "**/test-results.xml"
    failTaskOnFailedTests: true
    publishRunAttachments: true
    testRunTitle: "Automated Tests"
```

---

### ğŸ” 4. Always run (e.g., cleanup)

```yaml
- job: Cleanup
  condition: always() # ğŸ” Run even if previous jobs failed/canceled
  steps:
    - script: echo "Cleaning up temp files"
```

---

### âš™ï¸ 5. Use custom variable comparison

```yaml
variables:
  deployEnv: prod

- job: Deploy
  condition: eq(variables['deployEnv'], 'prod')  # âœ… Only if deployEnv is 'prod'
  steps:
    - script: echo "Deploying to Production"
```

---

### ğŸš« 6. Skip based on branch

```yaml
- job: SkipOnMain
  condition: ne(variables['Build.SourceBranch'], 'refs/heads/main')
  steps:
    - script: echo "Running on non-main branch"
```

âœ… `ne()` = not equal  
ğŸ“ Use `Build.SourceBranch` for full branch path

---

### ğŸ§ª 7. Run based on outcome of multiple jobs

```yaml
- job: JobA
  steps:
    - script: echo "Job A"

- job: JobB
  steps:
    - script: echo "Job B"

- job: Deploy
  dependsOn: [JobA, JobB]
  condition: and(succeeded('JobA'), succeeded('JobB')) # âœ… Both must succeed
  steps:
    - script: echo "Deploying after both jobs"
```

---

### âš–ï¸ 8. Combine AND/OR/NOT logic

```yaml
- job: Conditional
  condition: or(
    and(succeeded(), eq(variables['isPR'], 'true')),
    eq(variables['Build.SourceBranch'], 'refs/heads/dev')
  )
  steps:
    - script: echo "Complex condition matched"
```

---

### ğŸ›‘ 9. Stop deployment if user disabled it via variable

```yaml
variables:
  deployToProd: false

- job: Deploy
  condition: eq(variables['deployToProd'], 'true')
  steps:
    - script: echo "Deploying to Production"
```

---

### ğŸ¤– 10. Check output variable from another job

Job A sets an output:

```yaml
- job: A
  steps:
    - script: echo "##vso[task.setvariable variable=didTestsPass;isOutput=true]true"
```

Job B depends on that value:

```yaml
- job: B
  dependsOn: A
  condition: eq(dependencies.A.outputs['A.didTestsPass'], 'true')
  steps:
    - script: echo "Tests passed, continuing..."
```

---

### ğŸ§¹ 11. Always run step inside a succeeded job

```yaml
- job: Test
  steps:
    - script: echo "Run tests"

    - script: echo "Collecting logs..."
      condition: always() # ğŸ” Even if tests fail
```

---

## âœğŸ» Real Example

### ğŸ§  What Are We Building?

We're creating a pipeline that follows this flow:

### ğŸ› ï¸ Build â†’ ğŸ§ª Test â†’ ğŸš€ Deploy

But there's a twist:

> â— **Deployment should only run if the branch is `main`**  
> âŒ If you're working on `dev`, `feature/*`, or any other branch â†’ **skip deployment**

---

### ğŸ¤– How Branch Condition Works

Azure DevOps exposes the **current branch** through a variable called:

```yaml
Build.SourceBranch
```

This variable holds values like:

- `refs/heads/main` â†’ main branch
- `refs/heads/dev` â†’ dev branch
- `refs/heads/feature/login` â†’ feature branch

We compare this against a fixed value (`refs/heads/main`) to check:

```yaml
condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')
```

This means:  
âœ… Run this job if the branch is **exactly** `main`  
âŒ Otherwise, skip it (job will show as â€œSkippedâ€)

---

### ğŸ§  Summary Logic Flow

```text
IF any branch is pushed:
    â†’ Build runs
    â†’ Test runs (after build)

    â†’ Deploy runs ONLY IF:
        - Current branch == 'refs/heads/main'
        - Build & Test succeeded
```

---

```yaml
trigger:
  - "*"

pool:
  vmImage: "ubuntu-latest"

variables:
  buildConfiguration: "Release"
  environmentName: "production"
  deployBranch: "refs/heads/main" # ğŸ‘ˆ Full ref path

jobs:
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - job: Build
    displayName: "ğŸ—ï¸ Build Job"
    steps:
      - task: UseDotNet@2
        displayName: "Install .NET SDK"
        inputs:
          packageType: "sdk"
          version: "6.0.x"

      - script: |
          dotnet restore
          dotnet build --configuration $(buildConfiguration)
        displayName: "Restore & Build"

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - job: Test
    displayName: "ğŸ§ª Test Job"
    dependsOn: Build
    steps:
      - script: |
          dotnet test --configuration $(buildConfiguration) --no-build --logger trx
        displayName: "Run Unit Tests"

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - job: Deploy
    displayName: "ğŸš€ Deploy Job (Only on main)"
    dependsOn: Test
    condition: eq(variables['Build.SourceBranch'], variables['deployBranch']) # ğŸ”’ Condition to allow only main branch
    steps:
      - task: AzureCLI@2
        displayName: "Deploy to Azure Web App"
        inputs:
          azureSubscription: "MyAzureServiceConnection"
          scriptType: bash
          scriptLocation: inlineScript
          inlineScript: |
            echo "Deploying app to $(environmentName) environment"
            # Fake example of zip deployment
            az webapp deployment source config-zip \
              --name my-dotnet-app \
              --resource-group my-resource-group \
              --src $(Pipeline.Workspace)/myapp.zip
```

---

## ğŸ“Š Summary Table

| Function         | Purpose                             |
| ---------------- | ----------------------------------- |
| `succeeded()`    | Only if previous task/job succeeded |
| `failed()`       | Only if failed                      |
| `canceled()`     | Only if canceled                    |
| `always()`       | Run no matter what                  |
| `eq(a, b)`       | Equal comparison                    |
| `ne(a, b)`       | Not equal                           |
| `contains(a, b)` | Substring/array contains element    |
| `and()` / `or()` | Combine multiple conditions         |
