# 🚦 **Azure DevOps Gates**

## 🌐 **What are Gates?**

- **Gates** = automated checks that run **before or after deployment** in a release pipeline.
- They decide whether the pipeline can **continue** or must **wait/stop**.
- Think of them as **traffic lights** 🚦 in your release process:

  - 🟢 Green → deployment moves forward.
  - 🔴 Red → deployment is blocked until conditions are fixed.
  - 🟡 Yellow → waiting for the check to finish.

---

## ⁉️ **Why use Gates?**

- To **reduce risk** before pushing to production.
- To make sure **systems** (not just humans) confirm it’s safe.
- To enforce **business rules** automatically.

---

## 🌨️ **Examples of Gates**

Azure DevOps provides built-in gate types:

1. **Invoke REST API** → Call an external system.
   Example: Ask a Change Management system (like ServiceNow) if the release is approved.

2. **Query Azure Monitor alerts** → Block deployment if active alerts exist.
   Example: Stop rollout if CPU usage is too high.

3. **Query Azure Monitor logs** → Run KQL queries against Log Analytics.
   Example: Stop deployment if recent error logs exceed a threshold.

4. **Query work items (Azure Boards)** → Check for open bugs/tasks.
   Example: Prevent release if high-severity bugs are still unresolved.

5. **Business hours** → Restrict deployments to certain times.
   Example: Only allow deployment Mon–Fri, 9 AM–6 PM.

---

## ⚙️ **How Gates Work**

- Gates don’t just run once. They **re-evaluate periodically** until:

  - ✅ All checks pass, OR
  - ⏳ Timeout is reached (then release fails).

Example:

- You configure a gate with “Check every 5 minutes for up to 1 hour.”
- If conditions turn green anytime in that window → pipeline continues.
- If not → pipeline fails.

---

## 📍 **Where can Gates be used?**

- **Pre-deployment** (before deployment starts).
- **Post-deployment** (after deployment finishes).

👉 Usually, pre-deployment gates protect **prod/staging** environments.

---

## 🎭 **Gates vs Approvals**

- **👩‍💻 Approvals** = human clicks “OK.”
- **🤖 Gates** = system automatically checks.

👉 Best practice: use **both together**. Example:

- Gate = “No Sev-1 incidents in ServiceNow.”
- Approval = “Release Manager gives final signoff.”

---

## 🤔 **Where Gates Live**

- Gates are **not defined in YAML** (like pipeline tasks).
- They live inside **Environments** or **Classic Release stages** under **“Approvals and checks.”**
- This means you attach them to a stage or environment, not inside your task list.

---

## 🪜 **Steps to Add a Gate (UI)**

Here’s how you do it in Azure DevOps:

1. Go to **Pipelines → Environments**.
   (or open a **Classic Release pipeline stage** → select Pre/Post-deployment conditions).

2. Select the **environment** (e.g., `staging` or `prod`) where you want the gate.

3. Click **Approvals and checks → +Add check**.

4. From the list, choose a **Gate type** (examples: REST API, Azure Monitor alerts, Work item query, Business hours).

5. Configure the details:

   - **Invoke REST API** → enter endpoint URL, method (GET/POST), authentication, success criteria (like response contains `"approved": true`).
   - **Azure Monitor Alerts** → select subscription, resource group, alert rules.
   - **Work Item Query** → pick a saved query in Azure Boards (like “No active Sev-1 bugs”).
   - **Business Hours** → choose allowed deployment time windows.

6. Save. ✅

Now your stage will **pause** until the gate condition is met.

---

## ⚙️ **Gate Settings**

Each gate has extra settings to control how it behaves:

- **Sampling interval** (how often to check, e.g., every 5 min).
- **Timeout** (how long to keep waiting, e.g., 1 hour).
- **Success criteria** (e.g., no active alerts, REST API returns OK).

👉 If the timeout expires without success → the deployment **fails**.

---

## ✍🏻 Example — Query Azure Monitor Alerts

Say you want to **block production deployment** if there are active alerts.

- Add **Query Azure Monitor Alerts** gate.
- Configure:

  - Subscription: `my-subscription`
  - Resource group: `prod-rg`
  - Alerts: `High CPU`, `App Crash Rate`
  - Sampling interval: 5 minutes
  - Timeout: 1 hour

👉 Result: Pipeline will **wait up to 1 hour**, re-checking every 5 minutes. If alerts clear → deploy continues. If not → release fails.

---

## ✍🏻 Example — REST API Gate

Say you use ServiceNow for Change Management. You want to **block deployment until the change request is approved**.

- Add **Invoke REST API** gate.
- Configure:

  - URL: `https://servicenow/api/changeRequests/12345`
  - Method: GET
  - Auth: Service connection
  - Success criteria: `"status": "approved"`

👉 Result: Deployment won’t continue until ServiceNow returns an “approved” status.

---

## ✅ **Using Gates with Approvals**

Best practice:

- **Pre-deployment gates**: ensure external systems are green (alerts, bugs, API approvals).
- **Pre-deployment approvals**: human release manager clicks OK after gates pass.
- **Post-deployment gates**: run smoke tests, monitoring checks.
- **Post-deployment approvals**: ops team confirms production looks good.

---

## 🏁 **Summary**

- Gates = **automated checks** before/after deployment.
- Configured in **Environments → Approvals and checks** (not YAML).
- Types include REST API, Monitor Alerts, Logs, Work Item Queries, Business Hours.
- You can set **intervals, timeouts, success conditions**.
- They keep the pipeline safe by waiting until external systems say **all clear**.
- [Docs](https://learn.microsoft.com/en-us/azure/devops/pipelines/release/approvals/gates?view=azure-devops)
