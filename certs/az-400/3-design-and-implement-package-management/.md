# 🚀 **Azure Pipelines Cache**

> There is a two practical ways to speed up **.NET** and **Node.js** builds:
>
> 1. **DIY “pure script” cache** using Pipeline Artifacts
> 2. **First-class** caching with **`Cache@2`**

I’ll keep it exam-smart, production-ready, and sprinkle in visuals + full YAML you can paste and run.

---

## 🧠 **What “Pipeline Cache” Actually Does**

- **Goal:** Reuse heavyweight, deterministic assets across runs (e.g., NuGet, npm, yarn, pip caches) to avoid re-downloading packages.
- **Scope:** Caches are **per-project + per-branch** by default (and per runner OS).
- **Granularity:** You control what’s cached (folders/files) and **when to invalidate** using **keys**.
- **Two solid approaches:**

  - **DIY Pure Script**: Manually **pack** → **publish** → **download** → **restore** with Pipeline Artifacts. Works everywhere, no special task required.
  - **`Cache@2`**: Native caching task — simpler, faster, supports **restore-keys** (fallbacks), and smartly skips uploads if cache unchanged.

---

## 🧩 **Cache Keys 101 (why your cache sometimes “misses”)**

- **Primary key**: A string you design, e.g. `nuget-$(Agent.OS)-$(Build.SourcesDirectory)/packages.lock.json hash`
- **Restore keys (prefixes)**: Fallbacks when the exact key wasn’t found (e.g., allow minor changes).
- **Invalidate smartly**: Hash your lock files (`packages.lock.json`, `package-lock.json`, `yarn.lock`, `pnpm-lock.yaml`, `global.json`, `Directory.Packages.props`) so caches bust only when dependencies truly change.

---

## 🛡️ **Safety & Gotchas**

- **Never cache secrets** (tokens, service principals).
- **OS-specific paths**: cache keys should include OS.
- **Clean builds**: `npm ci` + lockfile hashing gives deterministic restores.
- **NuGet central package mgmt**: include `Directory.Packages.props` hash.
- **Self-hosted agents**: they already persist some directories; still use cache keys to remain deterministic across branches.

---

## 🆚 DIY vs `Cache@2`

| Feature           | DIY (Artifacts)                           | `Cache@2`                             |
| ----------------- | ----------------------------------------- | ------------------------------------- |
| Simplicity        | Medium                                    | **Easy**                              |
| Restore Fallbacks | Manual                                    | **Built-in** (`restoreKeys`)          |
| Storage           | Pipeline Artifacts                        | Dedicated cache store                 |
| Change Detection  | Manual (always republish unless you diff) | **Smart** (skips upload if unchanged) |
| Portability       | Works anywhere                            | Azure Pipelines only                  |

---

## 🔭 **Flow Overview (Mermaid)**

### `Cache@2` flow

```mermaid
flowchart LR
A[Start Job] --> B["Cache@2 restore"]
B -->|Hit| C[Use cached dir]
B -->|Miss| D[Run package restore]
D --> E["Cache@2 save"]
E --> F[Build/Test]
C --> F
```

### DIY “Pure Script” flow (Artifacts)

```mermaid
flowchart LR
A[Start Job] --> B[Try DownloadPipelineArtifact]
B -->|Found| C[Extract cache.tar]
B -->|Not Found| D[Skip extract]
C --> E[Restore uses local cache]
D --> E
E --> F[Build/Test]
F --> G[tar cache dir]
G --> H[PublishPipelineArtifact]
```

---

## 🧪 LAB A — .NET with **`Cache@2`** (NuGet)

### 🎯 What we’ll cache

- **NuGet packages folder**: `~/.nuget/packages` (Linux/macOS) or `%UserProfile%\.nuget\packages` (Windows)

### ✅ YAML (drop-in)

```yaml
trigger:
  - main

pool:
  vmImage: "ubuntu-latest"

variables:
  NUGET_PACKAGES: "$(Pipeline.Workspace)/.nuget/packages" # keep cache inside workspace for clarity

steps:
  - checkout: self

  # Use .NET SDK
  - task: UseDotNet@2
    inputs:
      packageType: "sdk"
      version: "8.0.x"

  # Compute a robust key: OS + hash of NuGet lock + global.json + Directory.Packages.props if present
  - bash: |
      echo "##vso[task.setvariable variable=NUGET_KEY]nuget-$(Agent.OS)-$(Build.SourceVersion)-$(Build.SourcesDirectory)"
    displayName: "Prep: seed key base"

  - task: Cache@2
    displayName: "Cache NuGet packages"
    inputs:
      key: |
        nuget | "$(Agent.OS)" | **/packages.lock.json | **/global.json | **/Directory.Packages.props
      restoreKeys: |
        nuget | "$(Agent.OS)"
      path: $(NUGET_PACKAGES)

  # Ensure NuGet uses the cached folder
  - script: |
      dotnet restore --packages $(NUGET_PACKAGES)
    displayName: "dotnet restore (uses cached packages)"

  - script: |
      dotnet build --configuration Release
      dotnet test --configuration Release --no-build
    displayName: "Build & Test"
```

### 📝 Notes

- `key` lines accept **multiple segments**; `**/packages.lock.json` means the key changes if lockfile changes.
- `restoreKeys` allows an OS-level fallback cache when lockfiles change slightly.
- On Windows hosted agent, use `$(UserProfile)\.nuget\packages` if you prefer the default location; the workspace approach keeps things explicit.

---

## 🧪 LAB B — Node.js with **`Cache@2`** (npm)

### 🎯 What we’ll cache

- **npm cache folder** (not `node_modules/`). This keeps installs fast and clean with `npm ci`.

### ✅ YAML (drop-in)

```yaml
trigger:
  - main

pool:
  vmImage: "ubuntu-latest"

variables:
  NPM_CACHE_DIR: "$(Pipeline.Workspace)/.npm"

steps:
  - checkout: self

  - task: NodeTool@0
    inputs:
      versionSpec: "20.x"
    displayName: "Use Node.js 20"

  - task: Cache@2
    displayName: "Cache npm"
    inputs:
      key: |
        npm | "$(Agent.OS)" | **/package-lock.json
      restoreKeys: |
        npm | "$(Agent.OS)"
      path: $(NPM_CACHE_DIR)

  - script: |
      npm config set cache $(NPM_CACHE_DIR) --global
      npm ci
    displayName: "Install deps (npm ci, uses cache)"

  - script: |
      npm test --if-present
      npm run build --if-present
    displayName: "Test & Build"
```

### 📝 Notes

- Use `npm ci` + `package-lock.json` for deterministic installs.
- If you use **yarn** or **pnpm**, cache their directories and hash `yarn.lock` or `pnpm-lock.yaml`.

---

## 🧪 LAB C — .NET “Pure Script” DIY Cache with **Pipeline Artifacts**

> No `Cache@2`. We’ll roll our own:
>
> - Try to **download** a previous cache artifact
> - Extract it into the NuGet packages folder
> - After restore/build, **re-pack** and **publish** back

### ✅ YAML

```yaml
trigger:
  - main

pool:
  vmImage: "ubuntu-latest"

variables:
  CACHE_NAME: "nuget-cache"
  CACHE_DIR: "$(Pipeline.Workspace)/.nuget/packages"
  CACHE_TAR: "$(Pipeline.Workspace)/nuget-cache.tar"
  # Hash key from lock/props/global.json for invalidation
  KEY_FILE: "$(Build.SourcesDirectory)/.cachekey.txt"

steps:
  - checkout: self

  - bash: |
      set -e
      # Build a key from files that affect NuGet deps
      find "$(Build.SourcesDirectory)" -type f \( -name "packages.lock.json" -o -name "Directory.Packages.props" -o -name "global.json" \) -print0 \
        | sort -z | xargs -0 sha256sum | sha256sum | cut -d' ' -f1 > $(KEY_FILE)
      echo "Key: $(cat $(KEY_FILE))"
    displayName: "Compute cache key"

  - task: DownloadPipelineArtifact@2
    displayName: "Attempt download cache artifact"
    inputs:
      artifact: $(CACHE_NAME)-$(Agent.OS)-$(Build.SourceBranchName)
      path: $(Pipeline.Workspace)
    continueOnError: true

  - bash: |
      set -e
      mkdir -p "$(CACHE_DIR)"
      if [ -f "$(CACHE_TAR)" ]; then
        echo "Extracting cache tar..."
        tar -xf "$(CACHE_TAR)" -C "$(CACHE_DIR)" || true
      else
        echo "No prior cache tar found."
      fi
    displayName: "Extract cache (if exists)"

  - task: UseDotNet@2
    inputs:
      packageType: "sdk"
      version: "8.0.x"

  - script: |
      dotnet restore --packages $(CACHE_DIR)
    displayName: "dotnet restore (uses restored cache)"

  - script: |
      dotnet build --configuration Release
      dotnet test --configuration Release --no-build
    displayName: "Build & Test"

  - bash: |
      set -e
      echo "Packing cache..."
      rm -f "$(CACHE_TAR)"
      tar -cf "$(CACHE_TAR)" -C "$(CACHE_DIR)" .
    displayName: "Pack cache"

  - task: PublishPipelineArtifact@1
    displayName: "Publish cache artifact"
    inputs:
      targetPath: $(CACHE_TAR)
      artifactName: $(CACHE_NAME)-$(Agent.OS)-$(Build.SourceBranchName)
      publishLocation: "pipeline"
```

### 📝 Notes

- Artifact name is branch-scoped to avoid cross-branch pollution.
- The **key** is for **deciding when to blow away prior artifact**. In this simple version we always repack; you can compare the **new key** to a saved key in the artifact to skip republishing.

---

## 🧪 LAB D — Node.js “Pure Script” DIY Cache with **Pipeline Artifacts**

### 🎯 What we cache

- npm cache dir as a tar via artifacts; restore before `npm ci`.

### ✅ YAML

```yaml
trigger:
  - main

pool:
  vmImage: "ubuntu-latest"

variables:
  CACHE_NAME: "npm-cache"
  NPM_CACHE_DIR: "$(Pipeline.Workspace)/.npm"
  CACHE_TAR: "$(Pipeline.Workspace)/npm-cache.tar"
  KEY_FILE: "$(Build.SourcesDirectory)/.cachekey.txt"

steps:
  - checkout: self

  - task: NodeTool@0
    inputs:
      versionSpec: "20.x"
    displayName: "Use Node.js 20"

  - bash: |
      set -e
      # Hash lockfiles to decide cache validity
      find "$(Build.SourcesDirectory)" -type f \( -name "package-lock.json" -o -name "yarn.lock" -o -name "pnpm-lock.yaml" \) -print0 \
        | sort -z | xargs -0 sha256sum | sha256sum | cut -d' ' -f1 > $(KEY_FILE)
      echo "Key: $(cat $(KEY_FILE))"
    displayName: "Compute cache key"

  - task: DownloadPipelineArtifact@2
    displayName: "Attempt download cache artifact"
    inputs:
      artifact: $(CACHE_NAME)-$(Agent.OS)-$(Build.SourceBranchName)
      path: $(Pipeline.Workspace)
    continueOnError: true

  - bash: |
      set -e
      mkdir -p "$(NPM_CACHE_DIR)"
      if [ -f "$(CACHE_TAR)" ]; then
        echo "Extracting cache tar..."
        tar -xf "$(CACHE_TAR)" -C "$(NPM_CACHE_DIR)" || true
      else
        echo "No prior cache tar found."
      fi
      npm config set cache $(NPM_CACHE_DIR) --global
    displayName: "Prepare npm cache dir"

  - script: |
      npm ci
    displayName: "Install deps"

  - script: |
      npm test --if-present
      npm run build --if-present
    displayName: "Test & Build"

  - bash: |
      set -e
      echo "Packing cache..."
      rm -f "$(CACHE_TAR)"
      tar -cf "$(CACHE_TAR)" -C "$(NPM_CACHE_DIR)" .
    displayName: "Pack cache"

  - task: PublishPipelineArtifact@1
    displayName: "Publish cache artifact"
    inputs:
      targetPath: $(CACHE_TAR)
      artifactName: $(CACHE_NAME)-$(Agent.OS)-$(Build.SourceBranchName)
      publishLocation: "pipeline"
```

---

## 🧪 **Quick Validation Checklist**

- First run: expect **cache miss** → full restore → cache saved.
- Subsequent runs (no lockfile changes): **cache hit** → `restore` steps run fast.
- Change a dependency (lockfile changes): see **cache miss** (as designed).
- Cross-branch: keys/artifact names include branch → **no contamination**.
- OS change (ubuntu ↔ windows): isolated due to OS segment in key.

---

## 💡 **Pro Tips & Patterns**

- **Speed vs Flexibility**: Prefer **`Cache@2`** for standard dep caches; use **DIY** when you need _special_ directories or custom logic.
- **Large Monorepos**: Use **multiple caches** (frontend npm, backend NuGet) with **separate keys** to avoid busting everything when only one side changes.
- **Self-hosted agents**: Still use caching — you’ll benefit across branches/PRs and keep installs predictable.
- **Restore Keys**: Add coarse fallbacks, e.g. `npm | "$(Agent.OS)"` to reuse cache even if lockfile slightly diverges (good for big repos with many apps).
- **Dotnet NuGet locals**: If needed, `dotnet nuget locals all --list` to confirm directories you’re caching.

---

## 🏁 **What to use when?**

- **If you want the simplest, reliable speed-up** → **`Cache@2`** labs (A & B).
- **If you need fully custom control** or want a universal trick that works like “just scripts” → **DIY** labs (C & D).
