# 🔹 What is Azure Pipeline Cache?

- **Cache** = a folder saved from a previous run so you don’t re-download packages every time.
- Example: NuGet packages for .NET, or `npm` packages for Node.js.
- Saves **time** and **bandwidth**.

Two main ways:

1. **Simple Script Way (using Artifacts)** – You upload a `.zip`/`.tar` file with dependencies and download it in the next run.
2. **Cache\@2 Task (recommended)** – Azure gives you a special `Cache@2` step that does it automatically.

---

## 🧪 Example 1: .NET App with `Cache@2`

👉 Cache the NuGet folder.

```yaml
pool:
  vmImage: "ubuntu-latest"

steps:
  - checkout: self

  - task: UseDotNet@2
    inputs:
      packageType: "sdk"
      version: "8.0.x"

  - task: Cache@2
    inputs:
      key: 'nuget | "$(Agent.OS)" | **/packages.lock.json'
      restoreKeys: 'nuget | "$(Agent.OS)"'
      path: ~/.nuget/packages

  - script: dotnet restore
    displayName: Restore Packages

  - script: dotnet build --configuration Release
```

✅ On first run → downloads everything → saves cache.
✅ Next run → restores fast from cache.

---

## 🧪 Example 2: Node.js App with `Cache@2`

👉 Cache the npm folder.

```yaml
pool:
  vmImage: "ubuntu-latest"

steps:
  - checkout: self

  - task: NodeTool@0
    inputs:
      versionSpec: "20.x"

  - task: Cache@2
    inputs:
      key: 'npm | "$(Agent.OS)" | **/package-lock.json'
      restoreKeys: 'npm | "$(Agent.OS)"'
      path: $(Pipeline.Workspace)/.npm

  - script: |
      npm config set cache $(Pipeline.Workspace)/.npm --global
      npm ci
    displayName: Install Packages
```

---

## 🧪 Example 3: .NET App “Script Way” (Artifacts)

👉 Save and restore manually.

```yaml
pool:
  vmImage: "ubuntu-latest"

variables:
  CACHE_DIR: ~/.nuget/packages
  CACHE_TAR: $(Pipeline.Workspace)/nuget.tar

steps:
  - checkout: self

  # Try to download old cache
  - task: DownloadPipelineArtifact@2
    inputs:
      artifact: nuget-cache
      path: $(Pipeline.Workspace)
    continueOnError: true

  # Extract if exists
  - script: |
      if [ -f "$(CACHE_TAR)" ]; then
        tar -xf $(CACHE_TAR) -C $(CACHE_DIR)
      fi

  - script: dotnet restore

  # After build, save new cache
  - script: |
      tar -cf $(CACHE_TAR) -C $(CACHE_DIR) .
  - task: PublishPipelineArtifact@1
    inputs:
      targetPath: $(CACHE_TAR)
      artifactName: nuget-cache
```

---

## 🧪 Example 4: Node.js App “Script Way” (Artifacts)

```yaml
pool:
  vmImage: "ubuntu-latest"

variables:
  CACHE_DIR: $(Pipeline.Workspace)/.npm
  CACHE_TAR: $(Pipeline.Workspace)/npm.tar

steps:
  - checkout: self

  - task: DownloadPipelineArtifact@2
    inputs:
      artifact: npm-cache
      path: $(Pipeline.Workspace)
    continueOnError: true

  - script: |
      mkdir -p $(CACHE_DIR)
      if [ -f "$(CACHE_TAR)" ]; then
        tar -xf $(CACHE_TAR) -C $(CACHE_DIR)
      fi
      npm config set cache $(CACHE_DIR) --global
      npm ci

  - script: |
      tar -cf $(CACHE_TAR) -C $(CACHE_DIR) .
  - task: PublishPipelineArtifact@1
    inputs:
      targetPath: $(CACHE_TAR)
      artifactName: npm-cache
```

---

## 🏁 Summary (Keep it Simple)

- **Best choice** → Use **Cache\@2** (shorter, smarter, automatic).
- **Manual (Artifacts)** → Only if you want full control.

> 👉 For **.NET** → cache `~/.nuget/packages`  
> 👉 For **Node.js** → cache npm folder (`$(Pipeline.Workspace)/.npm`)
