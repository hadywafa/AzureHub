# ğŸ”¹ What is Azure Pipeline Cache?

- **Cache** = a folder saved from a previous run so you donâ€™t re-download packages every time.
- Example: NuGet packages for .NET, or `npm` packages for Node.js.
- Saves **time** and **bandwidth**.

Two main ways:

1. **Simple Script Way (using Artifacts)** â€“ You upload a `.zip`/`.tar` file with dependencies and download it in the next run.
2. **Cache\@2 Task (recommended)** â€“ Azure gives you a special `Cache@2` step that does it automatically.

---

## ğŸ§ª Example 1: .NET App with `Cache@2`

ğŸ‘‰ Cache the NuGet folder.

```yaml
pool:
  vmImage: "ubuntu-latest"

steps:
  - checkout: self

  - task: UseDotNet@2
    inputs:
      packageType: "sdk"
      version: "8.0.x"

  - task: Cache@2
    inputs:
      key: 'nuget | "$(Agent.OS)" | **/packages.lock.json'
      restoreKeys: 'nuget | "$(Agent.OS)"'
      path: ~/.nuget/packages

  - script: dotnet restore
    displayName: Restore Packages

  - script: dotnet build --configuration Release
```

âœ… On first run â†’ downloads everything â†’ saves cache.
âœ… Next run â†’ restores fast from cache.

---

## ğŸ§ª Example 2: Node.js App with `Cache@2`

ğŸ‘‰ Cache the npm folder.

```yaml
pool:
  vmImage: "ubuntu-latest"

steps:
  - checkout: self

  - task: NodeTool@0
    inputs:
      versionSpec: "20.x"

  - task: Cache@2
    inputs:
      key: 'npm | "$(Agent.OS)" | **/package-lock.json'
      restoreKeys: 'npm | "$(Agent.OS)"'
      path: $(Pipeline.Workspace)/.npm

  - script: |
      npm config set cache $(Pipeline.Workspace)/.npm --global
      npm ci
    displayName: Install Packages
```

---

## ğŸ§ª Example 3: .NET App â€œScript Wayâ€ (Artifacts)

ğŸ‘‰ Save and restore manually.

```yaml
pool:
  vmImage: "ubuntu-latest"

variables:
  CACHE_DIR: ~/.nuget/packages
  CACHE_TAR: $(Pipeline.Workspace)/nuget.tar

steps:
  - checkout: self

  # Try to download old cache
  - task: DownloadPipelineArtifact@2
    inputs:
      artifact: nuget-cache
      path: $(Pipeline.Workspace)
    continueOnError: true

  # Extract if exists
  - script: |
      if [ -f "$(CACHE_TAR)" ]; then
        tar -xf $(CACHE_TAR) -C $(CACHE_DIR)
      fi

  - script: dotnet restore

  # After build, save new cache
  - script: |
      tar -cf $(CACHE_TAR) -C $(CACHE_DIR) .
  - task: PublishPipelineArtifact@1
    inputs:
      targetPath: $(CACHE_TAR)
      artifactName: nuget-cache
```

---

## ğŸ§ª Example 4: Node.js App â€œScript Wayâ€ (Artifacts)

```yaml
pool:
  vmImage: "ubuntu-latest"

variables:
  CACHE_DIR: $(Pipeline.Workspace)/.npm
  CACHE_TAR: $(Pipeline.Workspace)/npm.tar

steps:
  - checkout: self

  - task: DownloadPipelineArtifact@2
    inputs:
      artifact: npm-cache
      path: $(Pipeline.Workspace)
    continueOnError: true

  - script: |
      mkdir -p $(CACHE_DIR)
      if [ -f "$(CACHE_TAR)" ]; then
        tar -xf $(CACHE_TAR) -C $(CACHE_DIR)
      fi
      npm config set cache $(CACHE_DIR) --global
      npm ci

  - script: |
      tar -cf $(CACHE_TAR) -C $(CACHE_DIR) .
  - task: PublishPipelineArtifact@1
    inputs:
      targetPath: $(CACHE_TAR)
      artifactName: npm-cache
```

---

## ğŸ Summary (Keep it Simple)

- **Best choice** â†’ Use **Cache\@2** (shorter, smarter, automatic).
- **Manual (Artifacts)** â†’ Only if you want full control.

> ğŸ‘‰ For **.NET** â†’ cache `~/.nuget/packages`  
> ğŸ‘‰ For **Node.js** â†’ cache npm folder (`$(Pipeline.Workspace)/.npm`)
