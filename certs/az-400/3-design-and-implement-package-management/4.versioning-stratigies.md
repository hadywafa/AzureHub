# üöÄ Azure Pipelines Cache ‚Äî what, why, how

**What it is:** a way to **reuse previously downloaded/generated files** (dependencies, tool caches, build intermediates) between runs so you **skip repeated work**. The cache is **restored early** in the job and **saved automatically** in a ‚ÄúPost-job: Cache‚Äù step at the end (on success). Caches are **immutable** once created (new key ‚Üí new cache).

**When to use cache vs artifacts:**

- **Pipeline Artifacts** ‚Üí move build outputs between **jobs/stages/pipelines** (things other jobs depend on).
- **Cache** ‚Üí **speed up** a job by reusing files from **previous runs** (if missing, job still runs). Don‚Äôt swap them.

**Not supported:** Classic **release** pipelines. Works in YAML/Classic builds.

**Key concepts (Cache\@2):**

- `path`: folder you cache (no wildcards).
- `key`: unique identifier (segments separated by `|`). Segments can be **strings**, **file paths**, or **file patterns** (lockfiles are hashed).
- `restoreKeys`: fallback prefixes for partial hits.
- `cacheHitVar`: set to `true` / `inexact` / `false` so you can **skip work**.
- **Scope & isolation:** caches are scoped by **project + pipeline + branch**. PRs can **read** target branch caches but **can‚Äôt write** to them.

**Self-hosted agents:** need tar/7-zip available in `PATH` (hosted images already have what you need).

**NuGet-specific guidance:** lock deps (`packages.lock.json`), set `NUGET_PACKAGES` to a stable folder (e.g., `$(Pipeline.Workspace)/.nuget/packages`), and let the cache key include your lockfile(s).

---

## üß™ Labs ‚Äî .NET (NuGet)

We‚Äôll do both methods.

### A. ‚ÄúPure script / pipeline artifacts‚Äù (DIY cache)

**Idea:** You create your own cache using **Publish/Download Pipeline Artifact** keyed by a hash of `packages.lock.json`. This isn‚Äôt as elegant as `Cache@2`, but it teaches control.

> **Prep:** enable lock file once in your `.csproj`:

```xml
<PropertyGroup>
  <RestorePackagesWithLockFile>true</RestorePackagesWithLockFile>
</PropertyGroup>
```

(or `dotnet restore --use-lock-file` once, then commit `packages.lock.json`).

**YAML (Windows example):**

```yaml
trigger: [main]
pool: { vmImage: "windows-latest" }

variables:
  NUGET_PACKAGES: $(Pipeline.Workspace)/.nuget/packages

steps:
  # Compute a deterministic key from all lock files
  - powershell: |
      $files = Get-ChildItem -Recurse -Filter packages.lock.json | Sort-Object FullName
      if (-not $files) { throw "No packages.lock.json found." }
      $hashes = $files | % { (Get-FileHash $_.FullName -Algorithm SHA256).Hash }
      $super = [string]::Join("", $hashes)
      $key   = "$env:BUILD_SOURCEBRANCHNAME-$($env:Agent_OS)-$($super.Substring(0,16))"
      Write-Host "##vso[task.setvariable variable=CACHE_KEY;isOutput=true]$key"
    name: kv
    displayName: Compute cache key

  # Try to download a matching artifact named "nuget-cache-<key>"
  - task: DownloadPipelineArtifact@2
    displayName: Restore DIY cache (artifact)
    inputs:
      artifact: nuget-cache-$(kv.CACHE_KEY)
      path: $(NUGET_PACKAGES)
    continueOnError: true

  # If folder is empty, do a restore to fill it
  - powershell: |
      if (-not (Test-Path "$(NUGET_PACKAGES)")) { New-Item -ItemType Directory -Path "$(NUGET_PACKAGES)" | Out-Null }
      $empty = -not (Get-ChildItem "$(NUGET_PACKAGES)" -Recurse -ErrorAction SilentlyContinue)
      if ($empty) {
        dotnet restore --packages "$(NUGET_PACKAGES)"
      } else {
        Write-Host "DIY cache present. Skipping restore."
      }

  # Your build/tests here...
  - script: dotnet build -c Release --no-restore
    displayName: Build

  # Save/update cache artifact for next runs
  - task: PublishPipelineArtifact@1
    condition: succeeded() # avoid saving on failed runs
    inputs:
      targetPath: $(NUGET_PACKAGES)
      artifact: nuget-cache-$(kv.CACHE_KEY)
      publishLocation: pipeline
```

Docs: Pipeline Artifacts tasks.

**Pros:** portable, transparent. **Cons:** bigger uploads, no partial hits, you manage keying.

---

### B. Official `Cache@2` (recommended)

**YAML (cross-platform):**

```yaml
trigger: [main]
pool: { vmImage: "ubuntu-latest" }

variables:
  NUGET_PACKAGES: $(Pipeline.Workspace)/.nuget/packages

steps:
  - task: Cache@2
    displayName: Cache NuGet packages
    inputs:
      key: 'nuget | "$(Agent.OS)" | **/packages.lock.json,!**/bin/**,!**/obj/**'
      restoreKeys: |
        nuget | "$(Agent.OS)"
        nuget
      path: "$(NUGET_PACKAGES)"
      cacheHitVar: "NUGET_CACHE_HIT"

  # Skip restore if we got an exact cache hit (optional; see note below)
  - task: NuGetCommand@2
    displayName: dotnet/nuget restore (on miss)
    condition: ne(variables.NUGET_CACHE_HIT, 'true')
    inputs:
      command: "restore"
      restoreSolution: "**/*.sln"
```

Notes & caveats:

- If you see **‚Äúproject.assets.json not found‚Äù**, **don‚Äôt** conditionally skip restore‚ÄîNuGet will use the local cache and still be fast.
- `Cache@2` adds a **post-job save** step automatically; caches are **immutable**.
- Scopes & PR behavior are as documented.

---

## üß™ Labs ‚Äî Node.js (npm)

### A. ‚ÄúPure script / pipeline artifacts‚Äù (DIY)

**Strategy:** cache **npm cache** (tarballs) and/or **node_modules** with a key based on `package-lock.json`. Caching **npm‚Äôs cache dir** is generally more stable than caching `node_modules` (size/cross-platform issues). (Community notes show trade-offs: sometimes node_modules caching isn‚Äôt faster.)

**YAML (npm cache):**

```yaml
trigger: [main]
pool: { vmImage: "ubuntu-latest" }

variables:
  NPM_CACHE_DIR: $(Pipeline.Workspace)/.npm

steps:
  - bash: |
      set -e
      KEY="$(echo $(Agent.OS)-$(sha256sum package-lock.json | cut -c1-16))"
      echo "##vso[task.setvariable variable=CACHE_KEY;isOutput=true]$KEY"
    name: kv
    displayName: Compute cache key

  - task: DownloadPipelineArtifact@2
    displayName: Restore DIY npm cache
    inputs:
      artifact: npm-cache-$(kv.CACHE_KEY)
      path: $(NPM_CACHE_DIR)
    continueOnError: true

  - bash: |
      mkdir -p "$(NPM_CACHE_DIR)"
      npm ci --cache "$(NPM_CACHE_DIR)"
    displayName: npm ci

  - task: PublishPipelineArtifact@1
    condition: succeeded()
    inputs:
      targetPath: $(NPM_CACHE_DIR)
      artifact: npm-cache-$(kv.CACHE_KEY)
      publishLocation: pipeline
```

**If you choose to cache `node_modules`:**

- Replace path with `$(Build.SourcesDirectory)/node_modules` in both download & publish steps.
- Be aware of size and OS differences (Windows vs Linux). Some teams find it **slower** than just caching npm‚Äôs cache.

---

### B. Official `Cache@2` (recommended)

Two common patterns:

#### 1. Cache **npm cache** (preferred)

```yaml
variables:
  NPM_CACHE_DIR: $(Pipeline.Workspace)/.npm

steps:
  - task: Cache@2
    inputs:
      key: 'npm | "$(Agent.OS)" | package-lock.json'
      restoreKeys: |
        npm | "$(Agent.OS)"
        npm
      path: $(NPM_CACHE_DIR)
      cacheHitVar: NPM_CACHE_HIT

  - script: npm ci --cache $(NPM_CACHE_DIR)
    displayName: npm ci
```

(General npm example is linked from the caching doc.)

#### 2. Cache **node_modules** (works, but bigger)

```yaml
steps:
  - task: Cache@2
    inputs:
      key: 'node_modules | "$(Agent.OS)" | package-lock.json'
      restoreKeys: |
        node_modules | "$(Agent.OS)"
        node_modules
      path: $(Build.SourcesDirectory)/node_modules
      cacheHitVar: NODEMODS_HIT

  - script: npm ci
    displayName: npm ci (will populate node_modules)
```

---

## üß† Tuning tips & gotchas

- **Choose the right path**: Use a **stable location** (e.g., `$(Pipeline.Workspace)/.nuget/packages`, `$(Pipeline.Workspace)/.npm`). Avoid temp folders that get wiped. (NuGet example uses this pattern.)
- **Lockfiles = great keys**: `packages.lock.json`, `package-lock.json`, `yarn.lock`, etc. They produce deterministic cache keys.
- **Restore keys**: allow partial matches after minor lockfile changes (handy for large caches).
- **Don‚Äôt over-cache**: Cache only if **restore/save < reinstall time**, else you‚Äôll slow the pipeline.
- **PR behavior**: PRs can **read** target branch caches but **can‚Äôt write**; pushes to feature branches write to their own scope.
- **Ubuntu 24.04 note** (NuGet restore): on newer images, prefer **`NuGetAuthenticate` + `dotnet restore`** over `NuGetCommand@2`.

---

## üìö Reference

- **Pipeline caching (how it works, scope, keys, restoreKeys, cacheHitVar):** Microsoft Learn.
- **Cache\@2 task reference:** syntax & inputs.
- **NuGet caching article (lockfile, NuGet packages path, sample YAML):** Microsoft Learn.
- **Pipeline artifacts (DIY cache building blocks):** Microsoft Learn.
- **Community notes on node_modules caching trade-offs:** Stack Overflow / blogs.

---

Want me to package **two starter repos** for you now?

- ["Pipeline caching - Azure Pipelines | Microsoft Learn"](https://learn.microsoft.com/en-us/azure/devops/pipelines/release/caching?view=azure-devops)
- ["Cache NuGet packages - Azure Pipelines | Microsoft Learn"](https://learn.microsoft.com/en-us/azure/devops/pipelines/artifacts/caching-nuget?view=azure-devops)
- ["PublishPipelineArtifact@1 - Publish Pipeline Artifacts v1 task"](https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/publish-pipeline-artifact-v1?view=azure-pipelines&utm_source=chatgpt.com)
- ["Caching node_modules in Azure Pipelines takes longer ..."](https://stackoverflow.com/questions/65958925/caching-node-modules-in-azure-pipelines-takes-longer-than-installing-them?utm_source=chatgpt.com)
- ["Speed up Azure DevOps pipelines with node_modules caching"](https://packetlost.com/blog/2021/01/31/speed-up-azure-devops-pipelines-with-node_modules-caching/?utm_source=chatgpt.com)
- ["Cache@2 - Cache v2 task | Microsoft Learn"](https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/cache-v2?view=azure-pipelines)
- **`.NET`** sample with both DIY + `Cache@2` variants (and `packages.lock.json` enabled).
- **`Node.js`** sample with both DIY + `Cache@2` variants (caching **npm cache** and an alternative for **node_modules**).
