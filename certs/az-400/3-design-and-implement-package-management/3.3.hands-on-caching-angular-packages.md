# 🚀 **Angular 17 – Pipeline Caching (Hands-On)**

## 🧭 **What you’ll build**

- Put the **package manager cache** (npm or pnpm) **inside** `$(Pipeline.Workspace)` so `Cache@2` can manage it.
- Cache **Angular CLI build cache** (`.angular/cache`) for faster rebuilds across runs.
- Use smart **cache keys** (OS + lockfile + optional branch).
- (Optional) Private registry (Azure Artifacts npm feed) auth with **NpmAuthenticate\@0**.

---

## 🧰 **Prereqs**

- Node 18+ (Angular 17 supports Node 18/20).
- Azure DevOps org/project + repo with your Angular app.
- Lockfile present (`package-lock.json` for npm, or `pnpm-lock.yaml` for pnpm).

---

## 🗂️ **Repo skeleton (example)**

```ini
/ClientApp
  package.json
  package-lock.json            # or pnpm-lock.yaml
  angular.json
  src/...
```

> If your Angular app is in a different folder, just tweak `workingDirectory:` paths below.

---

## ✅ **Option A – npm (most common)**

### 📄 Minimal single-job YAML (copy-paste)

```yaml
trigger:
  - main

pool:
  vmImage: "ubuntu-latest" # windows-latest also fine

variables:
  APP_DIR: "ClientApp" # path to your Angular app

steps:
  # 1) Node runtime
  - task: NodeTool@0
    inputs:
      versionSpec: "18.x" # or 20.x if your project uses it

  # 2) Put npm's cache inside the pipeline workspace (portable & cachable)
  - script: npm config set cache $(Pipeline.Workspace)/.npm --global
    displayName: Set npm cache path

  # 3) Restore npm cache (speeds up npm ci)
  - task: Cache@2
    displayName: ♻️ Cache npm store
    inputs:
      key: 'npm | "$(Agent.OS)" | $(APP_DIR)/package-lock.json'
      restoreKeys: |
        npm | "$(Agent.OS)"
      path: "$(Pipeline.Workspace)/.npm"

    # NOTE: we do NOT skip `npm ci` on hit, because this caches the *download store*, not node_modules
  # 4) Install dependencies (fast when cache hits)
  - script: npm ci --prefer-offline
    workingDirectory: "$(Build.SourcesDirectory)/$(APP_DIR)"
    displayName: npm ci

  # 5) Cache Angular CLI build cache (.angular/cache) for incremental builds
  - task: Cache@2
    displayName: ♻️ Cache Angular build cache
    inputs:
      key: 'angular-cache | "$(Agent.OS)" | "$(Build.SourceBranch)"'
      restoreKeys: |
        angular-cache | "$(Agent.OS)"
      path: "$(Build.SourcesDirectory)/$(APP_DIR)/.angular/cache"

  # 6) Build
  - script: npm run build
    workingDirectory: "$(Build.SourcesDirectory)/$(APP_DIR)"
    displayName: ng build
```

#### 🔎 Why this works

- **npm cache**: We cache the _download store_ so `npm ci` can fetch packages from cache quickly. We still run `npm ci` to **materialize `node_modules/`**, which is not cached (cross-OS/toolchain issues).
- **Angular cache**: The Angular CLI stores expensive build outputs in `.angular/cache`. Caching it across runs significantly speeds up repeated builds.

---

### 🔐 Private npm registry (Azure Artifacts) — optional

If your `package.json` pulls from an Azure Artifacts npm feed, authenticate before `npm ci`:

```yaml
- task: NpmAuthenticate@0
  inputs:
    workingFile: "$(Build.SourcesDirectory)/.npmrc" # or generate to project path
  displayName: Auth to Azure Artifacts npm
```

> You can also commit a **scoped** `.npmrc` with the registry URL, and let `NpmAuthenticate@0` inject a temp auth token.

---

## ⚡ **Option B – pnpm (faster for big trees)**

pnpm separates a **global content-addressable store** from `node_modules`. We cache the **store** and then do an **offline install** → very fast.

```yaml
trigger:
  - main

pool:
  vmImage: "ubuntu-latest"

variables:
  APP_DIR: "ClientApp"

steps:
  - task: NodeTool@0
    inputs:
      versionSpec: "18.x"

  - script: npm i -g pnpm@9
    displayName: Install pnpm

  # Put pnpm store inside workspace so Cache@2 can manage it
  - script: |
      echo "##vso[task.setvariable variable=PNPM_STORE_PATH]$(Pipeline.Workspace)/.pnpm-store"
      echo PNPM_STORE_PATH=$(PNPM_STORE_PATH)
    displayName: Set PNPM_STORE_PATH

  - task: Cache@2
    displayName: ♻️ Cache pnpm store
    inputs:
      key: 'pnpm | "$(Agent.OS)" | $(APP_DIR)/pnpm-lock.yaml'
      restoreKeys: |
        pnpm | "$(Agent.OS)"
      path: "$(PNPM_STORE_PATH)"

  # Prefetch to the store (no node_modules yet)
  - script: pnpm fetch
    workingDirectory: "$(Build.SourcesDirectory)/$(APP_DIR)"
    displayName: pnpm fetch

  # Offline install from the warmed store → very fast
  - script: pnpm install --offline
    workingDirectory: "$(Build.SourcesDirectory)/$(APP_DIR)"
    displayName: pnpm install (offline)

  # Cache Angular CLI build cache too
  - task: Cache@2
    displayName: ♻️ Cache Angular build cache
    inputs:
      key: 'angular-cache | "$(Agent.OS)" | "$(Build.SourceBranch)"'
      restoreKeys: |
        angular-cache | "$(Agent.OS)"
      path: "$(Build.SourcesDirectory)/$(APP_DIR)/.angular/cache"

  - script: pnpm run build
    workingDirectory: "$(Build.SourcesDirectory)/$(APP_DIR)"
    displayName: ng build (pnpm)
```

---

## 🧱 **Multi-stage (CI + artifact) with caching**

```yaml
trigger:
  - main

stages:
  - stage: Build
    displayName: Build & Cache
    jobs:
      - job: Angular
        pool:
          vmImage: "ubuntu-latest"
        variables:
          APP_DIR: "ClientApp"
        steps:
          - task: NodeTool@0
            inputs:
              versionSpec: "18.x"

          - script: npm config set cache $(Pipeline.Workspace)/.npm --global
            displayName: Set npm cache path

          - task: Cache@2
            displayName: ♻️ Cache npm store
            inputs:
              key: 'npm | "$(Agent.OS)" | $(APP_DIR)/package-lock.json'
              restoreKeys: |
                npm | "$(Agent.OS)"
              path: "$(Pipeline.Workspace)/.npm"

          - task: Cache@2
            displayName: ♻️ Cache Angular build cache
            inputs:
              key: 'angular-cache | "$(Agent.OS)" | "$(Build.SourceBranch)"'
              restoreKeys: |
                angular-cache | "$(Agent.OS)"
              path: "$(Build.SourcesDirectory)/$(APP_DIR)/.angular/cache"

          - script: npm ci --prefer-offline
            workingDirectory: "$(Build.SourcesDirectory)/$(APP_DIR)"
            displayName: npm ci

          - script: npm run build
            workingDirectory: "$(Build.SourcesDirectory)/$(APP_DIR)"
            displayName: ng build

          # Package dist as artifact (not a cache)
          - task: PublishPipelineArtifact@1
            inputs:
              targetPath: "$(Build.SourcesDirectory)/$(APP_DIR)/dist"
              artifact: "ng-dist"
              publishLocation: "pipeline"
```

> **Artifacts ≠ Cache**: we still publish the build output (`dist/`) so release stages can consume it. Cache is only for speed on future runs.

---

## 🧠 **Key design choices**

- **Separate caches** for **package manager** (npm/pnpm) and **Angular build cache**.
- **Keys** include `$(Agent.OS)` + **lockfile**; Angular cache also includes **branch** to avoid cross-branch contamination.
- We **do not** cache `node_modules/`. It’s environment-specific and brittle across OS/tooling.

---

## 🧪 **How to verify cache behavior**

- On first run:

  - npm/pnpm cache step → `Cache not found for key ...` then **saves** at job end.
  - Angular cache step → likely miss, then save.

- On second run:

  - “**Cache restored**” for npm/pnpm and Angular cache.
  - `npm ci` (or `pnpm install --offline`) is **much faster**.

Optionally print sizes:

```yaml
- script: |
    du -sh $(Pipeline.Workspace)/.npm || echo win
    du -sh $(Build.SourcesDirectory)/$(APP_DIR)/.angular/cache || echo win
  displayName: Inspect cache folders
```

---

## 🧨 **Common pitfalls & fixes**

- **“I want to skip `npm ci` on hit”** → Don’t. You cached the _store_, not `node_modules`. Still run `npm ci`, but it’ll be fast (use `--prefer-offline`).
- **Cache never hits** → Ensure the **lockfile path in the key matches** your app location; key must stay identical across runs/branches (unless you intentionally scope by branch).
- **Using Nx** → Also cache `.nx/cache` similarly:

  ```yaml
  - task: Cache@2
    inputs:
      key: 'nx-cache | "$(Agent.OS)" | "$(Build.SourceBranch)"'
      restoreKeys: |
        nx-cache | "$(Agent.OS)"
      path: "$(Build.SourcesDirectory)/$(APP_DIR)/.nx/cache"
  ```

- **Private registries** → Use `NpmAuthenticate@0` before install.
- **Windows agents** → Same YAML works; don’t hardcode paths—use variables.

---

## ✅ **TL;DR**

- **npm**: cache `$(Pipeline.Workspace)/.npm`, run `npm ci --prefer-offline`.
- **pnpm**: cache `$(Pipeline.Workspace)/.pnpm-store`, run `pnpm fetch` + `pnpm install --offline`.
- **Angular**: cache `.angular/cache` (and `.nx/cache` if Nx).
- Keys: include **OS + lockfile**; for Angular cache include **branch**.
- Publish **`dist/` as artifact** for downstream stages—cache is only for speed.
