# 🚀 **ASP.NET Core – Pipeline Caching (Hands-On)**

## 🧭 **What you’ll build**

- Move NuGet’s global cache **into the pipeline workspace**
- Use **`Cache@2`** with smart keys (OS + lockfiles)
- Optionally **skip `dotnet restore`** when the cache already primed the folder
- Verify cache **miss → save → hit** across runs

---

## 🧰 **Prereqs**

- .NET 8 SDK locally (for generating lock files)
- Azure DevOps org/project + a repo with your ASP.NET Core solution
- Pipeline runs on **Microsoft-hosted** or **self-hosted** agents (works for both)

---

## 🗂️ **Repo skeleton (example)**

```ini
/src
  /WebApp
    WebApp.csproj
  /Services
    Services.csproj
Directory.Build.props  (optional)
global.json            (optional pin for SDK)
```

> If you don’t have **NuGet lock files** yet, create them (recommended for reliable keys):

```bash
dotnet restore --use-lock-file
# or: dotnet restore /p:RestorePackagesWithLockFile=true
```

This generates **`packages.lock.json`** next to each project.

---

## 🧪 **Minimal single-job YAML (copy-paste)**

```yaml
trigger:
  - main

pool:
  vmImage: "ubuntu-latest" # windows-latest also fine

variables:
  BuildConfiguration: "Release"

steps:
  # 1) Use .NET SDK
  - task: UseDotNet@2
    inputs:
      packageType: "sdk"
      version: "8.x"

  # 2) Relocate NuGet global cache INTO the workspace (portable & cachable)
  - script: echo "##vso[task.setvariable variable=NUGET_PACKAGES]$(Pipeline.Workspace)/.nuget/packages"
    displayName: Set NUGET_PACKAGES inside workspace

  # 3) Restore cache at job start (and define a var to know if it hit)
  - task: Cache@2
    displayName: ♻️ Cache NuGet packages
    inputs:
      # Key drives correctness: OS + all lock files (+ global.json if you pin SDK)
      key: 'nuget | "$(Agent.OS)" | **/packages.lock.json,global.json'
      restoreKeys: |
        nuget | "$(Agent.OS)"
      path: "$(NUGET_PACKAGES)"
    cacheHitVar: "CACHE_RESTORED"

  # 4) Only run dotnet restore if cache missed (optional but neat)
  - script: dotnet restore
    displayName: dotnet restore (only if cache miss)
    condition: ne(variables.CACHE_RESTORED, 'true')

  # 5) Build (no-restore)
  - script: dotnet build --configuration $(BuildConfiguration) --no-restore
    displayName: dotnet build

  # 6) Publish (example output)
  - script: dotnet publish src/WebApp/WebApp.csproj -c $(BuildConfiguration) -o $(Build.BinariesDirectory)/publish --no-build
    displayName: dotnet publish
```

### 🔎 What this does

- **First run** → likely **MISS** → `dotnet restore` populates `$(Pipeline.Workspace)/.nuget/packages` → `Cache@2` **saves** it after the job.
- **Next run** → **HIT** → cache downloads into that path → we **skip** `dotnet restore` (because it’s already warm) → build is faster.

---

## 🧱 **Multi-stage YAML (CI + artifact) with cache**

```yaml
trigger:
  - main

stages:
  - stage: Build
    displayName: Build & Cache
    jobs:
      - job: BuildJob
        pool:
          vmImage: "ubuntu-latest"
        variables:
          BuildConfiguration: "Release"
        steps:
          - task: UseDotNet@2
            inputs:
              packageType: "sdk"
              version: "8.x"

          - script: echo "##vso[task.setvariable variable=NUGET_PACKAGES]$(Pipeline.Workspace)/.nuget/packages"
            displayName: Set NUGET_PACKAGES

          - task: Cache@2
            displayName: ♻️ Cache NuGet packages
            inputs:
              key: 'nuget | "$(Agent.OS)" | **/packages.lock.json,global.json'
              restoreKeys: |
                nuget | "$(Agent.OS)"
              path: "$(NUGET_PACKAGES)"
            cacheHitVar: "CACHE_RESTORED"

          - script: dotnet restore
            displayName: dotnet restore (only if cache miss)
            condition: ne(variables.CACHE_RESTORED, 'true')

          - script: dotnet build -c $(BuildConfiguration) --no-restore
            displayName: dotnet build

          - script: dotnet test -c $(BuildConfiguration) --no-build
            displayName: dotnet test

          - script: dotnet publish src/WebApp/WebApp.csproj -c $(BuildConfiguration) -o $(Build.ArtifactStagingDirectory)/publish --no-build
            displayName: dotnet publish

          - task: PublishPipelineArtifact@1
            inputs:
              targetPath: "$(Build.ArtifactStagingDirectory)/publish"
              artifact: "webapp"
              publishLocation: "pipeline"
```

> **Artifacts ≠ Cache**: we still publish the compiled outputs for later stages; cache is only for speeding up restores next time.

---

## 🧠 **Key design choices (why this works well)**

- **`$(Pipeline.Workspace)/.nuget/packages`** – isolates your NuGet cache per run/pipeline and makes it portable across agents/OS.
- **Key uses `$(Agent.OS)` + lockfiles** – guarantees invalidation when dependencies or OS change.
- **`cacheHitVar`** – lets you conditionally skip `dotnet restore` for even faster builds (especially heavy dependency trees).

---

## 🧪 **Verify cache behavior (what to look for)**

- On the first run, the **Cache\@2** step logs:
  `Cache not found for key: nuget | 'Linux' | ...` → then at end: `Saving cache...`
- On subsequent runs:
  `Cache restored.` and your `dotnet restore` step is **skipped** (condition true) or finishes almost instantly.

You can also verify with:

```yaml
- script: |
    echo "CACHE_RESTORED=$(CACHE_RESTORED)"
    du -sh $(Pipeline.Workspace)/.nuget/packages || dir "$(Pipeline.Workspace)/.nuget/packages"
  displayName: Inspect cache folder
```

---

## 🧩 **Alternative ways to set the packages path (pick 1)**

1. **Logging command** (used above; cross-shell, simple)
2. CLI flag per command:

   ```yaml
   - script: dotnet restore --packages "$(Pipeline.Workspace)/.nuget/packages"
   - script: dotnet build --packages "$(Pipeline.Workspace)/.nuget/packages" --no-restore
   ```

3. **NuGet.config** (repo-scoped):

   ```xml
   <configuration>
     <config>
       <add key="globalPackagesFolder" value="$(Pipeline.Workspace)/.nuget/packages" />
     </config>
   </configuration>
   ```

---

## 🧨 **Heavy packages? Extra speed boosts**

- **Enable lock files** (you did) → deterministic restores + stable cache keys.
- **Self-hosted agents**: also enable **Agent Pool Maintenance** to prune stale workspaces/caches.
- **Matrix builds** (Linux/Windows): include `$(Agent.OS)` in the key (we already do); caches will be per-OS.
- **Container jobs**: same YAML works. Inside the container, the workspace is under `/__w`, but variables keep it portable.
- **Private feeds** (Azure Artifacts) during restore: add **`NuGetAuthenticate@1`** _before_ restore; caching still works the same.

```yaml
- task: NuGetAuthenticate@1
  displayName: Auth to Azure Artifacts (if you use private feeds)
```

---

## 🛠️ **Troubleshooting**

- **No lock files?** Create them with `dotnet restore --use-lock-file`.
- **Cache never hits?** Confirm the key string matches across runs (same branch/OS/lockfiles).
- **Huge uploads?** Don’t cache `obj/bin`; only the **global packages** folder.
- **Mixed OS runners?** Keys already partition by `$(Agent.OS)`.
- **Cache hit but restore still long?** You might be running `dotnet restore` without the conditional; add the **`cacheHitVar`** condition.

---

## 🧪 **Quick A/B timing experiment (optional)**

1. Run pipeline **without** cache steps → note durations of `restore` + `build`.
2. Add the caching YAML above → run twice.

   - Run #1 (miss) is baseline.
   - Run #2 (hit) should show **big** improvement (especially with heavy packages).

---

## ✅ **TL;DR**

- Move NuGet cache to `$(Pipeline.Workspace)/.nuget/packages`.
- Use `Cache@2` with key: `nuget | "$(Agent.OS)" | **/packages.lock.json,global.json`.
- Add `cacheHitVar` and **skip** `dotnet restore` on hits.
- Works great on hosted agents; cache lives in Azure DevOps, not on the VM.
