# Pipeline **Artifacts** ğŸ†š Pipeline **Caching**

## ğŸ“¦ 1. Pipeline **Artifacts**

Think of **artifacts** like ğŸ“¤ _deliverables you publish and hand over to the next stage_.

### ğŸ”¹ What they are

- Files/folders you **explicitly publish** in a pipeline using `PublishPipelineArtifact` or `PublishBuildArtifacts`.
- They are stored on the **Azure DevOps server**, not on the agent.
- You can **download them later** in another job, stage, or even another pipeline (if retained).

### ğŸ”¹ Purpose

- Share build outputs (zips, binaries, docker manifests, test logs) across **jobs, stages, or pipelines**.
- Long-term handover â€” artifacts survive even after the job/agent is gone.

### ğŸ”¹ Example

```yaml
# Stage 1: Build
- task: PublishPipelineArtifact@1
  inputs:
    targetPath: "$(Build.BinariesDirectory)"
    artifact: "drop"

# Stage 2: Release
- task: DownloadPipelineArtifact@2
  inputs:
    artifact: "drop"
    path: "$(Pipeline.Workspace)/drop"
```

Here, the **build outputs** are shipped out of the agentâ€™s temp folder, stored in Azure DevOps, and then **downloaded later** (even on a totally different agent machine).

ğŸ‘‰ Analogy: **Artifacts = Shipping a package ğŸ“¦ to a warehouse, so others can pick it up later.**

---

## âš¡ 2. Pipeline **Caching**

Now, caching is about **speeding things up in future runs** âš¡.

### ğŸ”¹ What it is

- Cache is stored in Azure DevOps service, but **indexed by a â€œcache keyâ€** (like a hash of `package-lock.json`).
- Commonly used for dependencies that are expensive to restore each run (npm, NuGet, pip, Gradle, Maven).
- Cache lives **outside artifacts** and can expire/evict.

### ğŸ”¹ Purpose

- Speed up pipelines by reusing downloaded/restored dependencies instead of pulling them every time.
- Works across **pipeline runs**, not just jobs in the same run.

### ğŸ”¹ Example

```yaml
- task: Cache@2
  inputs:
    key: 'npm | "$(Agent.OS)" | package-lock.json'
    path: "$(Pipeline.Workspace)/.npm"
    restoreKeys: |
      npm | "$(Agent.OS)"
- script: npm install
```

Here:

- On first run â†’ cache miss â†’ downloads packages â†’ saves to cache.
- On next run â†’ cache hit â†’ instantly restores from cache.

ğŸ‘‰ Analogy: **Cache = Keeping your favorite snacks ğŸª in a drawer for quick reuse, instead of going to the store every time.**

---

## âš–ï¸ **Key Differences**

| Feature              | **Artifacts**                                    | **Cache**                                                                   |
| -------------------- | ------------------------------------------------ | --------------------------------------------------------------------------- |
| **Purpose**          | Share outputs between jobs/stages/pipelines      | Speed up jobs by reusing dependencies                                       |
| **Lifetime**         | Kept until retention policy expires (days/weeks) | Evicted automatically when unused/expired                                   |
| **Granularity**      | Explicit publish/download                        | Key-based auto-restore                                                      |
| **Scope**            | Current pipeline or other pipelines              | Future runs of the same pipeline (can also be multi-pipeline with same key) |
| **Best For**         | Binaries, installers, test results               | npm, pip, NuGet packages, Gradle caches                                     |
| **Storage Location** | Azure DevOps Artifacts store                     | Azure DevOps Cache service                                                  |
| **Flow**             | â€œBuild â†’ Publish â†’ Release â†’ Downloadâ€           | â€œJob Run 1 saves â†’ Job Run 2 restoresâ€                                      |

---

## ğŸš¦**When to Use What**

âœ… **Use Artifacts when**:

- You want to hand off build outputs (DLLs, JARs, executables) to another stage or deployment.
- You want the files to be downloadable by other pipelines or team members later.
- You need traceability (what was built and deployed).

âœ… **Use Cache when**:

- You want to **accelerate** installs/restores of dependencies between runs.
- You donâ€™t care about the files themselves, only that they save time.
- Example: `npm install`, `pip install`, `dotnet restore`.

---

## ğŸ§  **Mental Model**

- **Artifacts** â†’ "Hereâ€™s the product we made today. Store it in the warehouse so QA/Release can use it." ğŸ­ğŸ“¦
- **Cache** â†’ "Letâ€™s keep the toolbox in the garage, so we donâ€™t waste time buying new tools every time." ğŸ”§

---

ğŸ‘‰ Pro Tip: Sometimes you use **both** in the same pipeline.
Example:

- Cache your `npm` folder to speed up `npm install`.
- Then build â†’ produce app bundle â†’ publish it as an **artifact** for deployment.
