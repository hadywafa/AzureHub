# üöÄ `Cache@2` ‚Äî What it is

**One task that does two things**:

1. **Restore step (start of job):** tries to **download** a previously saved cache for the given **key** (or **restore keys** fallbacks).
2. **Save step (end of job):** if the cache wasn‚Äôt found **or** the cached content changed, it **uploads** the folder at **`path`** under the **primary key**.

> You add **one** `Cache@2` step. It attempts restore **before** your install command and attempts save **after** your job finishes. No second task needed.

---

## üß† How it works internally (mental model)

<div align="center">

```mermaid
---
config:
  layout: elk
  elk:
    mergeEdges: false
    nodePlacementStrategy: LINEAR_SEGMENTS
---
flowchart TB
  A[Start Job] --> B["Cache@2: compute key"]
  B --> C{Exact match?}
  C -- Yes --> D[Download cache ‚Üí extract to path]
  C -- No --> E{Any restoreKeys prefix match?}
  E -- Yes --> F["Download best prefix match ‚Üí extract to path"]
  E -- No --> G["No cache (miss)"]
  D --> H["Run your install/build steps"]
  F --> H
  G --> H
  H --> I["Post-job: compare current path with what was restored"]
  I -->|Changed or Miss| J["Upload + Save under primary key"]
  I -->|Same| K[Skip upload]
  J --> L[End]
  K --> L[End]
```

</div>

---

- **Key resolution**: `Cache@2` resolves your `key` string. If it contains file globs (e.g., `**/package-lock.json`), it creates a **content hash** based on those files.
- **Restore order**:

  1. **Exact key** (best)
  2. **First matching restore key prefix** (fallback)

- **Save**: Happens **once per job** (post-job). If there was no restore hit or the folder changed, it uploads.

---

## üß© The important inputs (every one, in plain English)

| Input         | What it means                                                                                                            | Why it matters                                                                                                               |                                                                 |
| ------------- | ------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------- |
| `key`         | **Primary cache key.** Can be a simple string or a multi-part key separated by \`                                        | `. If you include file globs (e.g.,`\*\*/packages.lock.json\`), the **content hash** of those files becomes part of the key. | This is how you **invalidate** caches when dependencies change. |
| `restoreKeys` | **Fallback prefixes** (one per line). The task will look for the ‚Äúclosest‚Äù prefix match if the exact `key` is not found. | Lets you reuse a slightly older cache when the lockfile changed a bit (good for speed).                                      |                                                                 |
| `path`        | Folder(s) to cache (you can list multiple paths on separate lines).                                                      | This is **what** actually gets restored and saved.                                                                           |                                                                 |
| `cacheHitVar` | Name of a pipeline **variable** to set to `true`/`false` indicating whether the cache restored successfully.             | Use it to **skip** expensive steps when you have a hit.                                                                      |                                                                 |

> Other common step fields still apply (e.g., `displayName`, `condition`), but the four inputs above are the core of `Cache@2`.

---

## üß™ Use it with **.NET (NuGet)**

### ‚úÖ What to cache

- The **NuGet global packages** folder.

  - Linux/macOS hosted agents: `~/.nuget/packages`
  - Windows hosted agents: `$(UserProfile)\.nuget\packages`
  - To keep OS-neutral and explicit, many teams use a path **inside** `$(Pipeline.Workspace)` and point `dotnet restore` there.

### ‚úÖ Minimal & safe YAML (works on Ubuntu hosted agents)

```yaml
pool:
  vmImage: "ubuntu-latest"

steps:
  - checkout: self

  - task: UseDotNet@2
    inputs:
      packageType: "sdk"
      version: "8.0.x"

  - task: Cache@2
    displayName: "Cache NuGet"
    inputs:
      key: "nuget | $(Agent.OS) | **/packages.lock.json | **/Directory.Packages.props | **/global.json"
      restoreKeys: |
        nuget | $(Agent.OS)
      path: ~/.nuget/packages
      cacheHitVar: NUGET_CACHE_HIT

  - script: dotnet restore
    displayName: "dotnet restore"

  - script: |
      dotnet build --configuration Release
      dotnet test --configuration Release --no-build
    displayName: "Build & Test"
```

### Why this works well

- **Key includes** lockfiles (`packages.lock.json`) and optional central package files (`Directory.Packages.props`), plus `global.json`.
- If lockfiles change ‚Üí **new cache** (as intended).
- If only OS differs ‚Üí separate caches per OS via `$(Agent.OS)`.

### Optional: keep NuGet in workspace

```yaml
variables:
  NUGET_PACKAGES: "$(Pipeline.Workspace)/.nuget/packages"
# In Cache@2:
# path: $(NUGET_PACKAGES)

# In restore:
# dotnet restore --packages $(NUGET_PACKAGES)
```

This keeps your cache folder inside the pipeline workspace (clearer and OS-agnostic).

---

## üß™ Use it with **npm (Angular)**

### ‚úÖ What to cache

- The **npm cache folder**, not `node_modules/`.
- Keep installs deterministic with `npm ci`.

### ‚úÖ Minimal & safe YAML (Angular / npm)

```yaml
pool:
  vmImage: "ubuntu-latest"

variables:
  NPM_CACHE_DIR: "$(Pipeline.Workspace)/.npm"

steps:
  - checkout: self

  - task: NodeTool@0
    inputs:
      versionSpec: "20.x"

  - task: Cache@2
    displayName: "Cache npm"
    inputs:
      key: "npm | $(Agent.OS) | **/package-lock.json"
      restoreKeys: |
        npm | $(Agent.OS)
      path: $(NPM_CACHE_DIR)
      cacheHitVar: NPM_CACHE_HIT

  - script: |
      npm config set cache $(NPM_CACHE_DIR) --global
      npm ci
    displayName: "Install (npm ci)"

  - script: |
      npm run build --if-present
      npm test --if-present
    displayName: "Build & Test"
```

### Why this works well

- **Key includes** `package-lock.json` ‚Üí new cache when dependencies change.
- `npm ci` ensures a clean, reproducible install using the cache.

---

## üß™ Advanced patterns you‚Äôll actually use

### 1) **Monorepo / multiple apps ‚Üí multiple caches**

Give each cache its own key & path so front-end changes don‚Äôt bust back-end‚Äôs cache.

```yaml
# Frontend (npm)
- task: Cache@2
  inputs:
    key: "npm-frontend | $(Agent.OS) | frontend/**/package-lock.json"
    restoreKeys: "npm-frontend | $(Agent.OS)"
    path: $(Pipeline.Workspace)/.npm-frontend

# Backend (.NET)
- task: Cache@2
  inputs:
    key: "nuget-backend | $(Agent.OS) | backend/**/packages.lock.json"
    restoreKeys: "nuget-backend | $(Agent.OS)"
    path: $(Pipeline.Workspace)/.nuget-backend
```

### 2) **Using `cacheHitVar` to skip work**

```yaml
- task: Cache@2
  inputs:
    key: "npm | $(Agent.OS) | **/package-lock.json"
    restoreKeys: "npm | $(Agent.OS)"
    path: $(Pipeline.Workspace)/.npm
    cacheHitVar: NPM_CACHE_HIT

- script: npm ci
  condition: ne(variables.NPM_CACHE_HIT, 'true') # run only if we didn't hit cache
  displayName: "npm ci (only on miss)"
```

> Most teams still run `npm ci` even on a hit (it‚Äôs already fast). But you **can** skip it if you design for it.

### 3) **OS & toolchain isolation**

Always add `$(Agent.OS)` to keys. Consider also pinning **Node/SDK version** in the key if you vary those:

```yaml
key: "npm | $(Agent.OS) | node-20 | **/package-lock.json"
```

### 4) **Multiple paths**

You can cache more than one folder by putting each on its **own line** under `path`:

```yaml
inputs:
  path: |
    $(Pipeline.Workspace)/.npm
    $(Pipeline.Workspace)/.someOtherCache
```

---

## üõ†Ô∏è Troubleshooting & Gotchas

- **‚ÄúCache didn‚Äôt save‚Äù**: The upload happens **post-job**. If the job never reaches post-job (e.g., canceled before finishing), no save.
- **Overlapping caches**: Don‚Äôt point multiple `Cache@2` steps at the **same** folder in the same job. Keep paths distinct.
- **Key too broad**: If you never include lockfiles in the key, your cache may get stale and cause weird dependency states. Always hash lockfiles.
- **Branch behavior**: Caches are generally **per project** and **scoped** by your keys. If you want branch scoping, include `$(Build.SourceBranchName)` in your key.
- **Hosted vs self-hosted**: Self-hosted agents may already have some persistence on disk, but `Cache@2` still gives reliable, cross-branch reuse.

---

## ‚úÖ Quick reference (cheat sheet)

- **Primary inputs**: `key`, `restoreKeys`, `path`, `cacheHitVar`
- **Key design rule**: include `$(Agent.OS)` + your **lockfile(s)** (NuGet: `packages.lock.json`, optional `Directory.Packages.props`, `global.json`; npm: `package-lock.json`)
- **Best practice**: cache **package caches**, not `node_modules/`
- **Save is automatic** at end of job; no extra step needed
