# üß™ Project: ‚ÄúShopMini‚Äù ‚Äî Web API + Redis Caching

## üéØ **What you‚Äôll build**

- ASP.NET Core **Web API** with endpoints for **Products**
- **Cache-Aside** reads (`GetOrSet`) with TTL
- **Cache invalidation** on updates
- **Distributed lock** (safe updates)
- **Pub/Sub** for cache bust notifications
- **Batch** & **Transaction** demos
- Works with **Azure Cache for Redis** or **local Redis**

---

## üöß **Prereqs**

```bash
dotnet --version  # .NET 8+
dotnet new webapi -n ShopMini
cd ShopMini
dotnet add package StackExchange.Redis
```

Create `appsettings.json` (dev only; use Key Vault/env in prod):

```json
{
  "Redis": {
    "ConnectionString": "yourcache.redis.cache.windows.net:6380,password=__SECRET__,ssl=True,abortConnect=False"
  }
}
```

> For local testing (Docker Desktop):
> `docker run -p 6379:6379 --name redis -d redis`
> Connection string: `"localhost:6379,ssl=False"`

---

## 1Ô∏è‚É£ **Program.cs** ‚Äî wire Redis (one multiplexer), DI, controllers

```csharp
using StackExchange.Redis;

var builder = WebApplication.CreateBuilder(args);

var redisConn = builder.Configuration["Redis:ConnectionString"]
               ?? Environment.GetEnvironmentVariable("REDIS_CONNECTION_STRING")
               ?? "localhost:6379,ssl=False";

builder.Services.AddSingleton<IConnectionMultiplexer>(_ =>
    ConnectionMultiplexer.Connect(redisConn));

// light wrapper to get logical DB #0
builder.Services.AddSingleton<IDatabase>(sp =>
    sp.GetRequiredService<IConnectionMultiplexer>().GetDatabase());

builder.Services.AddSingleton<IProductRepository, FakeProductRepository>();
builder.Services.AddSingleton<IAppCache, RedisAppCache>();
builder.Services.AddSingleton<IRedisLock, RedisLock>();
builder.Services.AddSingleton<INotifier, RedisNotifier>();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();
app.UseSwagger();
app.UseSwaggerUI();

MapProductEndpoints(app);
MapOpsEndpoints(app);

app.Run();
```

---

## 2Ô∏è‚É£ **Domain + Fake Repository** (simulate DB latency)

`Models/Product.cs`

```csharp
public record Product(int Id, string Name, double Price);
```

`Data/FakeProductRepository.cs`

```csharp
public interface IProductRepository
{
    Task<Product?> GetAsync(int id);
    Task UpsertAsync(Product product);
}

public sealed class FakeProductRepository : IProductRepository
{
    private readonly Dictionary<int, Product> _store = new()
    {
        [1] = new(1, "Keyboard", 49.9),
        [2] = new(2, "Mouse", 29.9),
        [3] = new(3, "Monitor", 199.0)
    };

    public async Task<Product?> GetAsync(int id)
    {
        await Task.Delay(120);                 // simulate slow DB
        _store.TryGetValue(id, out var p);
        return p;
    }

    public async Task UpsertAsync(Product product)
    {
        await Task.Delay(80);
        _store[product.Id] = product;
    }
}
```

---

## 3Ô∏è‚É£ **Redis Cache-Aside helper** (Strings + TTL)

`Caching/RedisAppCache.cs`

```csharp
using StackExchange.Redis;
using System.Text.Json;

public interface IAppCache
{
    Task<T?> GetOrSetAsync<T>(string key, Func<Task<T?>> factory, TimeSpan ttl);
    Task RemoveAsync(string key);
}

public sealed class RedisAppCache : IAppCache
{
    private readonly IDatabase _db;
    private static readonly JsonSerializerOptions Json = new(JsonSerializerDefaults.Web);

    public RedisAppCache(IDatabase db) => _db = db;

    public async Task<T?> GetOrSetAsync<T>(string key, Func<Task<T?>> factory, TimeSpan ttl)
    {
        var hit = await _db.StringGetAsync(key);
        if (hit.HasValue) return JsonSerializer.Deserialize<T>(hit!, Json);

        var value = await factory();
        if (value is not null)
        {
            var json = JsonSerializer.Serialize(value, Json);
            await _db.StringSetAsync(key, json, ttl);             // StringSet with TTL
        }
        return value;
    }

    public Task RemoveAsync(string key) => _db.KeyDeleteAsync(key);
}
```

---

## 4Ô∏è‚É£ **Redis Distributed Lock** (safe update) + Pub/Sub notifier

`Locking/RedisLock.cs`

```csharp
using StackExchange.Redis;

public interface IRedisLock
{
    Task<bool> TryAcquireAsync(string key, string token, TimeSpan ttl);
    Task ReleaseAsync(string key, string token);
}

public sealed class RedisLock : IRedisLock
{
    private readonly IDatabase _db;
    public RedisLock(IDatabase db) => _db = db;

    public Task<bool> TryAcquireAsync(string key, string token, TimeSpan ttl) =>
        _db.StringSetAsync(key, token, ttl, when: When.NotExists);  // SET NX PX

    public Task ReleaseAsync(string key, string token)
    {
        // Lua for safe unlock (delete only if token matches)
        var script = LuaScript.Prepare(@"
            if redis.call('get', KEYS[1]) == ARGV[1]
            then return redis.call('del', KEYS[1]) else return 0 end");
        return _db.ScriptEvaluateAsync(script, new RedisKey[] { key }, new RedisValue[] { token });
    }
}
```

`Notifications/RedisNotifier.cs`

```csharp
using StackExchange.Redis;

public interface INotifier
{
    Task PublishInvalidationAsync(int productId);
}

public sealed class RedisNotifier : INotifier
{
    private readonly IConnectionMultiplexer _mux;
    public RedisNotifier(IConnectionMultiplexer mux) => _mux = mux;

    public Task PublishInvalidationAsync(int productId)
    {
        var sub = _mux.GetSubscriber();
        return sub.PublishAsync("cache:product:invalidate", productId.ToString());
    }
}
```

(Optional) Subscribe somewhere at startup if you want multi-instance cache busting:

```csharp
// in Program.cs after building services (if needed):
var mux = app.Services.GetRequiredService<IConnectionMultiplexer>();
var sub = mux.GetSubscriber();
await sub.SubscribeAsync("cache:product:invalidate", async (ch, msg) =>
{
    var db = app.Services.GetRequiredService<IDatabase>();
    await db.KeyDeleteAsync($"product:{msg}");
});
```

---

## 5Ô∏è‚É£ **Endpoints** ‚Äî read (cache-aside), update (invalidate), batch, transaction

`Endpoints.cs`

```csharp
using StackExchange.Redis;

public static class Endpoints
{
    public static void MapProductEndpoints(WebApplication app)
    {
        app.MapGet("/products/{id:int}", async (int id, IAppCache cache, IProductRepository repo) =>
        {
            var ttl = TimeSpan.FromMinutes(5);
            var product = await cache.GetOrSetAsync(
                key: $"product:{id}",
                factory: () => repo.GetAsync(id),
                ttl: ttl);

            return product is null ? Results.NotFound() : Results.Ok(product);
        });

        app.MapPut("/products/{id:int}", async (int id, Product input,
            IProductRepository repo, IAppCache cache, INotifier notifier, IRedisLock locker) =>
        {
            if (id != input.Id) return Results.BadRequest("ID mismatch.");

            var lockKey = $"lock:product:{id}";
            var token = Guid.NewGuid().ToString();

            if (!await locker.TryAcquireAsync(lockKey, token, TimeSpan.FromSeconds(15)))
                return Results.StatusCode(423); // Locked

            try
            {
                await repo.UpsertAsync(input);                 // DB first
                await cache.RemoveAsync($"product:{id}");       // then invalidate cache
                await notifier.PublishInvalidationAsync(id);    // notify other instances
                return Results.Ok(input);
            }
            finally
            {
                await locker.ReleaseAsync(lockKey, token);
            }
        });
    }

    public static void MapOpsEndpoints(WebApplication app)
    {
        app.MapPost("/ops/batch", async (IDatabase db) =>
        {
            // Batch (not atomic) ‚Äì fewer round trips
            var b = db.CreateBatch();
            var t1 = b.StringSetAsync("k1", "v1", TimeSpan.FromMinutes(1));
            var t2 = b.StringSetAsync("k2", "v2", TimeSpan.FromMinutes(1));
            var t3 = b.StringGetAsync("k1");
            b.Execute();
            await Task.WhenAll(t1, t2, t3);
            return Results.Ok(new { k1 = (string?)await db.StringGetAsync("k1") });
        });

        app.MapPost("/ops/transaction", async (IDatabase db) =>
        {
            // Transaction (atomic with condition)
            var tran = db.CreateTransaction();
            tran.AddCondition(Condition.KeyNotExists("order:1001"));
            var set = tran.StringSetAsync("order:1001", "created", TimeSpan.FromMinutes(5));
            bool committed = await tran.ExecuteAsync();
            return Results.Ok(new { committed });
        });

        app.MapGet("/ops/pub", async (IConnectionMultiplexer mux) =>
        {
            var sub = mux.GetSubscriber();
            await sub.PublishAsync("news", "hello-subscribers");
            return Results.Ok("published");
        });

        app.MapGet("/ops/sub", async (IConnectionMultiplexer mux) =>
        {
            var sub = mux.GetSubscriber();
            await sub.SubscribeAsync("news", (ch, msg) => Console.WriteLine($"SUB> {msg}"));
            return Results.Ok("subscribed (check console)");
        });
    }
}
```

---

## 6Ô∏è‚É£ **Run & Test**

```bash
dotnet run
```

Open Swagger: `https://localhost:PORT/swagger`

### Test flow

1. **GET** `/products/1` ‚Üí first time ~120ms (fake DB)
   Subsequent calls < 2ms (from Redis, TTL 5m)
2. **PUT** `/products/1` with body:

   ```json
   { "id": 1, "name": "Keyboard Pro", "price": 59.9 }
   ```

   ‚Äì update DB, **invalidate cache**, publish invalidation to other instances

3. **GET** `/products/1` ‚Üí warm cache again with fresh data

### Extra demos

- **Batch**: `POST /ops/batch`
- **Transaction**: `POST /ops/transaction`
- **Pub/Sub**: `GET /ops/sub` then `GET /ops/pub` (watch console)

---

## üìå **Where the Redis SDK classes show up (so you can memorize)**

- **`ConnectionMultiplexer`** ‚Üí created once; used to `.GetDatabase()`, `.GetSubscriber()`, `.GetServer(...)`
- **`IDatabase`** ‚Üí `StringSet/Get`, `KeyDelete/Expire`, `CreateBatch()`, `CreateTransaction()`
- **`ISubscriber`** ‚Üí `Subscribe`, `Publish` (pub/sub)
- **`ITransaction`** ‚Üí `AddCondition`, `StringSetAsync`, `ExecuteAsync` (atomic)
- **`IBatch`** ‚Üí `StringSetAsync`, `Execute()` (group commands, not atomic)

---

## üèÅ **Production checklist** (quick)

- Use **TLS (6380)** and private networking (VNet/Private Link) for Azure Cache.
- Keep one **ConnectionMultiplexer**; use async APIs.
- **TTL everywhere**; key format like `entity:{id}`; keep values small.
- Monitor **CPU, ops/sec, memory, hit ratio, evictions** (Azure Monitor).
- Consider **clustering** (Premium/Enterprise) for scale; **persistence** if you need recovery.
- Prefer **Entra ID** over static keys when possible; store secrets in **Key Vault**.
