# ‚ö° **Azure Cache for Redis ‚Äî End-to-End Implementation**

## üéØ **What you‚Äôll build**

- An **Azure Cache for Redis** instance (secure, TLS).
- Verify it with **redis-cli** (PING/SET/GET/EXPIRE).
- A **.NET app** that uses Redis with the **Cache-Aside** pattern.

---

## 1Ô∏è‚É£ **Create the cache (Azure Portal)**

1. In Azure Portal: **Create resource ‚Üí Azure Cache for Redis**
2. Fill the basics:

   - **DNS name**: `myapp-cache-001`
   - **Location**: closest to your app (minimize latency)
   - **Tier** (typical):

     - **Basic/Standard**: dev/test
     - **Premium**: VNet, clustering, persistence, better SLA
     - **Enterprise/Enterprise Flash**: Redis OSS 6/7 with advanced features

3. **Networking**:

   - Start with **Public endpoint + TLS** (default).
   - For prod: prefer **Private Endpoint** or **VNet injection**.

4. **Advanced**:

   - **Access Keys** auth: **Enabled** (default).
   - Optionally enable **Entra ID (Azure AD)** for modern auth.
   - Consider **Clustering** if you need >13GB or horizontal sharding.

5. **Review + Create** ‚Üí **Create**.
6. After deploy, open the resource:

   - **Hostname**: `myapp-cache-001.redis.cache.windows.net`
   - **Ports**: 6380 (TLS)
   - **Access keys**: Primary/Secondary (rotate periodically)

> Security tip: For production, use **Private Link**, restrict Firewall rules, and consider **Entra ID** over static keys.

---

## 2Ô∏è‚É£ **Verify with redis-cli (TLS)**

Install redis-cli (Windows/macOS/Linux). Then:

```bash
redis-cli -h myapp-cache-001.redis.cache.windows.net -p 6380 --tls -a "<ACCESS_KEY>"
```

Quick smoke test:

```text
> PING
PONG
> SET name "admin"
OK
> GET name
"admin"
> EXPIRE name 5
(integer) 1
> TTL name
(integer) 3
# wait‚Ä¶
> GET name
(nil)
```

> That proves TLS connectivity + key auth + TTL behavior.

---

## 3Ô∏è‚É£ **.NET ‚Äî connect with StackExchange.Redis**

### 3.1 Install package

```bash
dotnet add package StackExchange.Redis
```

### 3.2 Register a single, shared ConnectionMultiplexer (DI)

> Best practice: **one ConnectionMultiplexer per app** (it‚Äôs thread-safe & handles pooling).

```csharp
// Program.cs (ASP.NET Core)
using StackExchange.Redis;

var builder = WebApplication.CreateBuilder(args);

// Store in Key Vault or env var in production
var redisConn = builder.Configuration["Redis:ConnectionString"]
    // Example format (do not hardcode keys in prod):
    // "myapp-cache-001.redis.cache.windows.net:6380,password=***,ssl=True,abortConnect=False"
    ?? Environment.GetEnvironmentVariable("REDIS_CONNECTION_STRING");

builder.Services.AddSingleton<IConnectionMultiplexer>(_ =>
    ConnectionMultiplexer.Connect(redisConn));

builder.Services.AddSingleton<IDatabase>(sp =>
    sp.GetRequiredService<IConnectionMultiplexer>().GetDatabase());

builder.Services.AddControllers();
var app = builder.Build();
app.MapControllers();
app.Run();
```

### 3.3 Implement the Cache-Aside pattern (simple wrapper)

```csharp
public interface IAppCache
{
    Task<T?> GetOrSetAsync<T>(string key, Func<Task<T>> factory, TimeSpan ttl);
    Task RemoveAsync(string key);
}

public sealed class RedisAppCache : IAppCache
{
    private readonly IDatabase _db;
    private static readonly JsonSerializerOptions _json = new(JsonSerializerDefaults.Web);

    public RedisAppCache(IDatabase db) => _db = db;

    public async Task<T?> GetOrSetAsync<T>(string key, Func<Task<T>> factory, TimeSpan ttl)
    {
        var cached = await _db.StringGetAsync(key);
        if (cached.HasValue)
            return JsonSerializer.Deserialize<T>(cached!, _json);

        var value = await factory();

        // only cache non-null/non-empty results as you prefer
        if (value is not null)
        {
            var json = JsonSerializer.Serialize(value, _json);
            await _db.StringSetAsync(key, json, ttl);
        }

        return value;
    }

    public Task RemoveAsync(string key) => _db.KeyDeleteAsync(key);
}
```

Register and use:

```csharp
builder.Services.AddSingleton<IAppCache, RedisAppCache>();
```

Example endpoint:

```csharp
app.MapGet("/products/{id:int}", async (int id, IAppCache cache) =>
{
    var ttl = TimeSpan.FromMinutes(5);

    var product = await cache.GetOrSetAsync(
        key: $"product:{id}",
        factory: async () =>
        {
            // simulate slow DB/API call
            await Task.Delay(100);
            return new { Id = id, Name = $"Item-{id}", Price = 19.99 };
        },
        ttl: ttl);

    return Results.Ok(product);
});
```

> Flow: **GET** ‚Üí try Redis ‚Üí if miss, fetch DB/API ‚Üí store in Redis with TTL ‚Üí return.

---

## üóûÔ∏è **Serialization choices** (what to store)

- **Strings** with JSON ‚Üí simplest & human-readable.
- **Hashes** for partially updating fields (e.g., `HSET user:42 plan "pro"`).
- **Binary** (MessagePack/Protobuf) if you need smaller payloads & faster ser/deser.

> Keep values **small** and **key names predictable** (`entity:Id`), and **always set TTL**.

---

## ‚úÖ **Production hardening** (must-do list)

- **Connection**

  - Single `ConnectionMultiplexer` per process.
  - Use **TLS (6380)**.
  - Put connection info in **Key Vault** or env vars.

- **Networking & Security**

  - Prefer **Private Endpoint** or **VNet** in Premium/Enterprise.
  - Restrict public access; rotate **Access Keys** if used.
  - Consider **Entra ID** authentication.

- **Scaling & Availability**

  - Choose tier by **memory needs & features** (Premium for VNet, clustering, persistence).
  - Use **Clustering** for big data/high throughput.
  - For DR, use **Geo-replication** (Enterprise tiers).

- **Data management**

  - **TTL everywhere** (e.g., 5‚Äì60 minutes typical).
  - Watch **evictions** (Redis maxmemory policy) & memory fragmentation.
  - If you need durability, enable **persistence** (RDB/AOF in Premium/Enterprise).

- **Observability**

  - Monitor: **CPU, Server Load, Ops/sec, Memory**, Cache hits/misses.
  - Export metrics to **Azure Monitor**/**App Insights**.
  - Create alerts on **high evictions**, **low hit ratio**, **connection spikes**.

- **Patterns**

  - Reads: **Cache-Aside** (above).
  - Writes: invalidate or update cache after DB write.
  - Hot keys: keep TTL shorter; consider **local memory cache** in front of Redis for ultra-hot items.

---

## ‚ö†Ô∏è **Quick troubleshooting**

- **Timeouts** ‚Üí increase `syncTimeout`/`asyncTimeout` minimally; check network latency/VNet DNS.
- **TLS errors** ‚Üí ensure `ssl=True` and use port **6380**.
- **Auth failures** ‚Üí rotate key; confirm you‚Äôre using **Primary** or **Secondary** key correctly.
- **Low hit ratio** ‚Üí confirm you call Redis first; pick a **sensible TTL**; avoid over-unique keys.
- **Evictions** ‚Üí size your cache; reduce value size; set TTLs; consider higher tier or clustering.

---

## üèÅ **TL;DR**

1. Create Redis (Portal) ‚Üí enable TLS, pick right tier/networking.
2. Test with `redis-cli` (PING/SET/GET/EXPIRE).
3. Use **StackExchange.Redis** with **one ConnectionMultiplexer**.
4. Implement **Cache-Aside** with TTL.
5. Harden security (Private Link/Entra), monitor, and scale (clustering/persistence) as needed.
