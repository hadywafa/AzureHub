# ‚ö° Azure Cache for Redis + .NET (StackExchange.Redis)

## üß© What you get

- A single, shared, resilient Redis connection (TLS)
- Clean **Cache-Aside** helpers (with TTL)
- Basic ‚Üí advanced operations (hashes, batches, transactions, pub/sub)
- CLI verification tips + production hardening checklist

---

## üì¶ Install

```bash
dotnet add package StackExchange.Redis
```

---

## üîê Secure Connection (TLS, one multiplexer)

> Best practice: **one** `ConnectionMultiplexer` per process (it‚Äôs thread-safe and does pooling/reconnects).

**appsettings.json (dev):**

```json
{
  "Redis": {
    "ConnectionString": "yourcache.redis.cache.windows.net:6380,password=__SECRET__,ssl=True,abortConnect=False"
  }
}
```

**Program.cs (ASP.NET Core):**

```csharp
using StackExchange.Redis;

var builder = WebApplication.CreateBuilder(args);

// Prefer Key Vault / env var in prod
var redisConn = builder.Configuration["Redis:ConnectionString"]
               ?? Environment.GetEnvironmentVariable("REDIS_CONNECTION_STRING");

builder.Services.AddSingleton<IConnectionMultiplexer>(_ =>
    ConnectionMultiplexer.Connect(redisConn));

builder.Services.AddSingleton<IDatabase>(sp =>
    sp.GetRequiredService<IConnectionMultiplexer>().GetDatabase());

builder.Services.AddControllers();
var app = builder.Build();
app.MapControllers();
app.Run();
```

> Notes
> ‚Ä¢ **TLS**: use port **6380** + `ssl=True`
> ‚Ä¢ **abortConnect=False** allows the app to start while Redis is briefly unreachable
> ‚Ä¢ Store secrets in **Azure Key Vault** or env vars (never commit keys)

---

## üèóÔ∏è Core Classes & Interfaces in `StackExchange.Redis`

### 1Ô∏è‚É£ `ConnectionMultiplexer`

- **What it is**:
  The _main gateway_ between your app and Redis.
  Think of it like the **SQL connection pool**, but for Redis.
- **Usage**:
  Created **once** and reused across the app. Thread-safe.
- **Common methods/properties**:

  - `Connect` / `ConnectAsync(connectionString)` ‚Üí establish connection
  - `.GetDatabase()` ‚Üí get an `IDatabase` instance
  - `.GetSubscriber()` ‚Üí get `ISubscriber` (for pub/sub)
  - `.GetServer(host, port)` ‚Üí run server-side ops (like keys, stats)

---

### 2Ô∏è‚É£ `IDatabase`

- **What it is**:
  The workhorse for CRUD on keys. Lightweight proxy from `ConnectionMultiplexer`.
- **Common methods**:

  - **String operations**

    - `StringSet(key, value, expiry)`
    - `StringGet(key)`
    - `StringIncrement(key)` / `StringDecrement(key)`

  - **Key operations**

    - `KeyDelete(key)`
    - `KeyExists(key)`
    - `KeyExpire(key, timespan)`

  - **Hash operations**

    - `HashSet(key, field, value)`
    - `HashGet(key, field)`
    - `HashGetAll(key)`

  - **List operations**

    - `ListLeftPush(key, value)`
    - `ListRightPop(key)`
    - `ListRange(key)`

  - **Set operations**

    - `SetAdd(key, value)`
    - `SetMembers(key)`
    - `SetContains(key, value)`

  - **Sorted Set operations**

    - `SortedSetAdd(key, member, score)`
    - `SortedSetRangeByScore(key)`

  - **Transactions & Batch**

    - `CreateTransaction()`
    - `CreateBatch()`

---

### 3Ô∏è‚É£ `ISubscriber`

- **What it is**:
  Handles **publish/subscribe** messaging.
- **Common methods**:

  - `Subscribe(channel, handler)` ‚Üí listen to messages
  - `Publish(channel, message)` ‚Üí send message
  - `Unsubscribe(channel)`

---

### 4Ô∏è‚É£ `ITransaction`

- **What it is**:
  Lets you run multiple commands atomically (all or none).
- **Common methods**:

  - `AddCondition(Condition.KeyNotExists(key))`
  - `StringSetAsync(...)`, `HashSetAsync(...)` (same as `IDatabase`, but queued)
  - `ExecuteAsync()` ‚Üí commit

---

### 5Ô∏è‚É£ `IBatch`

- **What it is**:
  Queue up multiple commands ‚Üí sent together (not atomic, just fewer network trips).
- **Common methods**:
  Same as `IDatabase` (e.g., `StringSetAsync`, `HashGetAsync`)
  but executed after `.Execute()`.

---

### 6Ô∏è‚É£ `IServer`

- **What it is**:
  Lets you run Redis server commands (diagnostics, keys, perf info).
  _‚ö†Ô∏è Use carefully in prod ‚Äî can be heavy if you scan large keyspaces._
- **Common methods**:

  - `Keys(pattern: "*")` ‚Üí enumerate keys
  - `Info()` ‚Üí server stats
  - `FlushDatabase()` ‚Üí clear DB

---

## üß™ Basics: Strings + TTL

```csharp
public class DemoController : ControllerBase
{
    private readonly IDatabase _db;
    public DemoController(IDatabase db) => _db = db;

    [HttpGet("/set")]
    public async Task<string> Set()
    {
        await _db.StringSetAsync("favorite:flavor", "i-love-rocky-road", TimeSpan.FromMinutes(5));
        return "OK";
    }

    [HttpGet("/get")]
    public async Task<string?> Get()
        => await _db.StringGetAsync("favorite:flavor");
}
```

Common ops (cheat sheet):

```csharp
await _db.StringSetAsync("k", "v", TimeSpan.FromSeconds(30)); // set with TTL
string? v = await _db.StringGetAsync("k");
await _db.KeyExpireAsync("k", TimeSpan.FromMinutes(2));       // change TTL
bool exists = await _db.KeyExistsAsync("k");
await _db.KeyDeleteAsync("k");
long n = await _db.StringIncrementAsync("counter");
```

---

## üß± Cache-Aside Helper (recommended pattern)

```csharp
using System.Text.Json;

public interface IAppCache
{
    Task<T?> GetOrSetAsync<T>(string key, Func<Task<T>> factory, TimeSpan ttl);
    Task RemoveAsync(string key);
}

public sealed class RedisAppCache : IAppCache
{
    private readonly IDatabase _db;
    private static readonly JsonSerializerOptions Json = new(JsonSerializerDefaults.Web);
    public RedisAppCache(IDatabase db) => _db = db;

    public async Task<T?> GetOrSetAsync<T>(string key, Func<Task<T>> factory, TimeSpan ttl)
    {
        var cached = await _db.StringGetAsync(key);
        if (cached.HasValue)
            return JsonSerializer.Deserialize<T>(cached!, Json);

        var value = await factory();
        if (value is not null)
        {
            var json = JsonSerializer.Serialize(value, Json);
            await _db.StringSetAsync(key, json, ttl);
        }
        return value;
    }

    public Task RemoveAsync(string key) => _db.KeyDeleteAsync(key);
}
```

**Register & use:**

```csharp
builder.Services.AddSingleton<IAppCache, RedisAppCache>;

// Example
app.MapGet("/products/{id:int}", async (int id, IAppCache cache) =>
{
    return await cache.GetOrSetAsync(
        key: $"product:{id}",
        factory: async () =>
        {
            await Task.Delay(100); // simulate DB
            return new { Id = id, Name = $"Item-{id}", Price = 19.99 };
        },
        ttl: TimeSpan.FromMinutes(5));
});
```

---

## üß∞ Advanced Operations (most useful in real apps)

### 1) Hashes (partial fields, e.g., profiles)

```csharp
await _db.HashSetAsync("user:42", new HashEntry[] {
    new("name", "Sara"), new("plan", "pro")
});
string? name = await _db.HashGetAsync("user:42", "name");
HashEntry[] all = await _db.HashGetAllAsync("user:42");
```

### 2) Batching (fewer round trips; not atomic)

```csharp
var batch = _db.CreateBatch();
var t1 = batch.StringSetAsync("k1", "v1");
var t2 = batch.StringSetAsync("k2", "v2");
batch.Execute();
await Task.WhenAll(t1, t2);
```

### 3) Transactions (MULTI/EXEC; atomic on server)

```csharp
var tran = _db.CreateTransaction();
tran.AddCondition(Condition.KeyNotExists("order:1001"));
var tSet = tran.StringSetAsync("order:1001", "created");
bool committed = await tran.ExecuteAsync(); // all or nothing
```

### 4) Pub/Sub (lightweight notifications)

```csharp
var mux = sp.GetRequiredService<IConnectionMultiplexer>();
ISubscriber sub = mux.GetSubscriber();

// Subscribe
await sub.SubscribeAsync("news", (ch, msg) => Console.WriteLine($"Got: {msg}"));

// Publish
await sub.PublishAsync("news", "Breaking: Redis is awesome!");
```

### 5) Distributed Lock (simple pattern with NX + TTL)

```csharp
string lockKey = "lock:invoice:42";
string token = Guid.NewGuid().ToString();
bool acquired = await _db.StringSetAsync(lockKey, token, TimeSpan.FromSeconds(30), when: When.NotExists);
if (acquired)
{
    try
    {
        // critical section
    }
    finally
    {
        // safe release via LUA to avoid deleting someone else‚Äôs lock
        var script = LuaScript.Prepare(@"
            if redis.call('get', KEYS[1]) == ARGV[1]
            then return redis.call('del', KEYS[1]) else return 0 end");
        await _db.ScriptEvaluateAsync(script, new RedisKey[] { lockKey }, new RedisValue[] { token });
    }
}
```

---

## üß™ CLI Verification (TLS)

```bash
redis-cli -h yourcache.redis.cache.windows.net -p 6380 --tls -a "<ACCESS_KEY>"
> PING
PONG
> SET demo "hello"
OK
> GET demo
"hello"
> EXPIRE demo 5
(integer) 1
> TTL demo
(integer) 3
> GET demo
(nil)   # after it expires
```

---

## üß± Full Console Sample (TTL demo)

```csharp
using StackExchange.Redis;

class Program
{
    static async Task Main()
    {
        var cs = Environment.GetEnvironmentVariable("REDIS_CONNECTION_STRING")
                 ?? "yourcache.redis.cache.windows.net:6380,password=__SECRET__,ssl=True,abortConnect=False";

        using var mux = await ConnectionMultiplexer.ConnectAsync(cs);
        var db = mux.GetDatabase();

        Console.WriteLine("Enter a value to cache for 30s:");
        var key = Guid.NewGuid().ToString();
        var value = Console.ReadLine();

        bool ok = await db.StringSetAsync(key, value, TimeSpan.FromSeconds(30));
        Console.WriteLine(ok
            ? $"Stored '{value}' at key {key} (TTL 30s)"
            : "Set failed");

        Console.WriteLine($"GET -> {await db.StringGetAsync(key)}");
        Console.WriteLine("Waiting 30s‚Ä¶");
        await Task.Delay(30000);
        Console.WriteLine($"GET after expire -> {await db.StringGetAsync(key) ?? "(nil)"}");
    }
}
```

---

## üõ°Ô∏è Production Hardening (checklist)

- **Connection**

  - Single `ConnectionMultiplexer`; prefer async APIs.
  - Tune timeouts sparingly: `connectTimeout`, `syncTimeout` (keep small), `keepAlive`.

- **Security**

  - TLS (6380), Private Endpoint/VNet on Premium/Enterprise.
  - Prefer **Microsoft Entra ID** over static keys when feasible.
  - Keep secrets in **Key Vault**; rotate keys.

- **Data**

  - Always set **TTL** for cached items.
  - Use predictable keys (`entity:{id}`), keep values small.
  - Watch **evictions**; size your cache; consider **clustering**.

- **Ops/Monitoring**

  - Track: CPU, server load, ops/sec, memory used, hit ratio, evictions, connections.
  - Export to **Azure Monitor / App Insights**; set alerts.

- **Patterns**

  - Reads: **Cache-Aside** (shown).
  - Writes: update DB then invalidate/update cache.
  - Hot keys: shorter TTL; optionally add in-process memory cache layer in front.

---

## üîë Memory Hook (to remember easily)

üëâ Imagine a Redis **company**:

- `ConnectionMultiplexer` = üè¢ **Office Building** (1 per company)
- `IDatabase` = üë®‚Äçüíª **Employee Desk** (where actual work happens)
- `ISubscriber` = üì¢ **HR Announcement System** (pub/sub)
- `ITransaction` = üìù **Contract Agreement** (atomic, all or none)
- `IBatch` = üì¶ **Bulk Mailroom** (sends many letters together)
- `IServer` = üîç **IT Admin Console** (server stats & tools)

---

## üß† Quick Memory Hooks

- **One Multiplexer** ‚úÖ
- **TLS 6380** ‚úÖ
- **Cache-Aside + TTL** ‚úÖ
- **Hashes for partial fields** ‚úÖ
- **Batch ‚â† Transaction** (use Transaction for atomic) ‚úÖ
- **Pub/Sub for notifications** ‚úÖ
- **Lua for safe lock release** ‚úÖ
