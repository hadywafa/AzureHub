# âš¡ Azure Cache for Redis

## ğŸ“– What Is It?

Azure Cache for Redis is a **fully managed, in-memory cache service** based on the open-source **Redis** (Remote Dictionary Server).

Itâ€™s designed for:

- âš¡ **Ultra-fast data access** (sub-millisecond latency).
- ğŸ‘¯ **High-throughput workloads** (millions of requests/sec).
- ğŸ–‡ï¸ **Decoupling backend bottlenecks** (offloading repeated reads from DB/API).

---

## ğŸ—ï¸ Internal Architecture

Azure takes open-source **Redis** and wraps it with:

1. **Clustered infrastructure** (scale-out with sharding).
2. **High availability** (replicas across VMs/zones).
3. **Monitoring, patching, auto-failover** handled by Azure.
4. **Enterprise security** (VNet, TLS, RBAC, Private Link, etc.).

**Internally, Redis itself:**

- Stores everything **in-memory** (RAM, not disk).
- Supports multiple data structures:

  - ğŸ”‘ **Strings** â†’ cache HTML fragments, JSON, or tokens.
  - ğŸ“œ **Lists** â†’ message queues.
  - ğŸ”€ **Sets / Sorted Sets** â†’ leaderboards, unique tags.
  - ğŸ““ **Hashes** â†’ user profile data.
  - ğŸ”” **Pub/Sub** â†’ event notifications.

---

## ğŸ”„ How It Works (Flow)

<div align="left" style="background-color: #282833ff ;border-radius: 10px;border: 2px solid white">

```mermaid
---
config:
  look: handDrawn
  theme: dark # dark,neutral
title: "How Redis Works"
---
flowchart LR
A[App Client] -->|Cache Lookup| B{Azure Cache for Redis}
B -->|Hit ğŸ”¥| C[Return Cached Data]
B -->|Miss âŒ| D[Database / API]
D --> E[Add Result to Redis]
E --> A
```

- Step 1: App checks Redis first (cache-aside).
- Step 2: If **cache hit**, return instantly.
- Step 3: If **cache miss**, query DB/API â†’ add to Redis â†’ return.
- Step 4: Next request = âš¡ instant.

</div>

---

## ğŸ”‘ **Cache Access Patterns**

1. **Cache-Aside (Lazy Loading)**

   - App first checks cache â†’ if missing, pull from DB.
   - Most common pattern.

2. **Write-Through**

   - Writes go to DB + cache at the same time.
   - Ensures cache always has fresh data.

3. **Read-Through**

   - App always talks to cache, and cache itself fetches from DB if missing.
   - Less common in Azure; cache-aside is more typical.

4. **Write-Behind**

   - App writes to cache only â†’ cache flushes to DB later.
   - Risky if cache fails, but good for high-write workloads.

---

## ğŸ” Security

- Supports **TLS encryption** for traffic.
- **Private endpoints** â†’ restrict access inside VNet.
- **Azure RBAC** + **Access Keys**.
- Enterprise tier adds **Active Geo-Replication** for DR.

---

## âš™ï¸ Deployment Tiers

<div align="center" style="background-color: #ffffffff ;border-radius: 10px;border: 2px solid white;margin:0 30px;">
  <img src="image/2.azure-cache-for-redis-overview/1759009224256.png" alt="Capture Configuration" style="border-radius: 10px; border: 2px solid white; width: 60%; background-color: #ffffffff">
</div>

- **Basic** â†’ Single node (cheap, no SLA).
- **Standard** â†’ Two-node primary/replica (99.9% SLA).
- **Premium** â†’ Persistence, clustering, VNet isolation, better SLA.
- **Enterprise / Enterprise Flash** â†’ Uses Redis OSS 6.x/7.x, DR, larger memory with SSD backing.

---

## ğŸ’¡ Real-World Use Cases

1. **Session Store** ğŸ§‘â€ğŸ’»

   - Store user session state (shopping cart, auth tokens).
   - Works across multiple web servers â†’ stateless apps.

2. **Caching Hot Data** ğŸ”¥

   - Frequently-read data like product catalogs, user profiles.
   - Prevents hammering SQL or Cosmos DB.

3. **Pub/Sub Messaging** ğŸ“¢

   - Real-time chat apps, leaderboards, notifications.

4. **Rate Limiting / Throttling** ğŸš¦

   - Keep counters in Redis for API call limits per user.

5. **Background Jobs / Queues** â³

   - Use Redis Lists/Streams as lightweight queues.

---

## ğŸ–¥ï¸ Hands-On: Using Redis in .NET

Install package:

```bash
dotnet add package StackExchange.Redis
```

### Connect to Redis

```csharp
using StackExchange.Redis;

var redis = ConnectionMultiplexer.Connect("yourcache.redis.cache.windows.net:6380,password=YourPassword,ssl=True,abortConnect=False");
IDatabase db = redis.GetDatabase();
```

### Store & Retrieve

```csharp
// Write
db.StringSet("user:123", "John Doe");

// Read
string user = db.StringGet("user:123");
Console.WriteLine(user); // Output: John Doe
```

### Lists (Queue Example)

```csharp
db.ListRightPush("tasks", "Task1");
db.ListRightPush("tasks", "Task2");

string nextTask = db.ListLeftPop("tasks");
Console.WriteLine(nextTask); // Task1
```

### Pub/Sub

```csharp
ISubscriber sub = redis.GetSubscriber();

// Subscribe
sub.Subscribe("news", (channel, message) => {
    Console.WriteLine($"Received: {message}");
});

// Publish
sub.Publish("news", "Breaking: Redis is awesome!");
```

---

## âš”ï¸ Azure Cache vs Database

- **DB** â†’ Persistent, slower, stores all data.
- **Redis** â†’ Volatile (in-memory), super-fast, stores only _hot/needed_ data.
- Use **together** â†’ Redis reduces DB load.

---

## ğŸ§  Easy Way to Memorize

Think of Azure Cache for Redis like **RAM for your cloud app**:

- **Redis = RAM** â†’ fast, temporary, holds hot stuff.
- **DB = Disk** â†’ permanent, slower, holds all stuff.
- **Cache-aside = Sticky Note** â†’ "if not in note, go check the book."
