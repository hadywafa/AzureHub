# üåç Cosmos DB ‚Äì Global Distribution & Partitioning

## üó∫Ô∏è Global Distribution ‚Äì The Big Picture

Cosmos DB was designed for **planet-scale applications**. That means:

- Data lives **close to users** (low latency worldwide).
- Failover happens **automatically** (disaster recovery built-in).
- Developers don‚Äôt need to manage replication themselves.

**How it works:**

- Each **Cosmos DB account** can be associated with **multiple Azure regions**.
- Cosmos DB automatically replicates data to those regions using **multi-master replication protocol**.
- Developers choose the **consistency level** (we‚Äôll cover later).

üìå **Exam Note**: By default, writes go to the **write region**. You can enable **multi-region writes** for true multi-master.

---

## üîÑ Failover Behavior

- **Automatic Failover** ‚Üí Cosmos switches traffic to the next priority region if the write region fails.
- **Manual Failover** ‚Üí You trigger it (e.g., maintenance/test).
- Failover priorities are configured per region.

üëâ Example Exam Question:
_‚ÄúYou need 99.999% availability and automatic failover across 3 regions. Which setting must be enabled?‚Äù_
‚úîÔ∏è Enable **multi-region writes** + configure **automatic failover**.

---

## üß© Partitioning ‚Äì The Heart of Scalability

Cosmos DB‚Äôs scale magic = **partitioning**.

Think of it like this:

- **Logical Partition** = Group of items sharing the same **Partition Key value**.
- **Physical Partition** = Actual storage + compute unit managed by Azure.

```mermaid
graph TD
    A[Container] --> B1["Partition Key = "Electronics""]
    A --> B2["Partition Key = "Books""]
    A --> B3["Partition Key = "Clothes""]

    B1 --> C1[Physical Partition #1]
    B2 --> C2[Physical Partition #2]
    B3 --> C3[Physical Partition #3]
```

- You define a **Partition Key path** (like `/category`).
- Cosmos DB hashes the partition key value ‚Üí maps it to a **physical partition**.
- Each physical partition has a fixed RU and storage quota (‚âà 50 GB, 10,000 RU/s).

üìå Cosmos DB **splits partitions automatically** when you outgrow one.

---

## ‚ö° Why Partitioning Matters

Partitioning affects:

1. **Performance** ‚Äì Queries targeting a single partition are faster + cheaper.
2. **Scaling** ‚Äì Load is distributed evenly only if partition key has **high cardinality** (many unique values).
3. **RU Consumption** ‚Äì Cross-partition queries = more RU usage.

üëâ **Bad Partition Key**: `/country` (only a few values, e.g., "US", "UK", "IN").  
üëâ **Good Partition Key**: `/userId` (millions of unique values).

üìå **Exam Tip**: Always choose a partition key with **high cardinality** and **even access patterns**.

---

## üì¶ Partition Routing

- **Point Reads/Writes**: If you supply `id + partitionKey`, Cosmos directly goes to the right partition (fast, cheap).
- **Queries Without Partition Key**: Cosmos fans out to **all partitions** ‚Üí slower, expensive.

üëâ Example:

```sql
-- Efficient: hits only one partition
SELECT * FROM Products WHERE category = 'Electronics' AND id = '123'

-- Expensive: fan-out query
SELECT * FROM Products WHERE price > 1000
```

---

## üß≠ Multi-Region Writes vs Single-Region Writes

| Mode                    | Behavior                                                   | Use Case                                   |
| ----------------------- | ---------------------------------------------------------- | ------------------------------------------ |
| **Single Write Region** | One primary write region, multiple read regions            | Simpler apps, write-heavy in one geography |
| **Multi-Region Writes** | All regions accept writes, conflict resolution rules apply | Global apps with active users everywhere   |

üìå Conflict resolution defaults to **last-write-wins**, but you can configure **custom conflict resolution policies** (like stored procedures).

---

## üÜö AWS Comparison

| Concept                | Cosmos DB                           | DynamoDB                       |
| ---------------------- | ----------------------------------- | ------------------------------ |
| **Global Replication** | Built-in, multi-master option       | DynamoDB Global Tables         |
| **Partition Key**      | Mandatory, drives scaling           | Mandatory, drives scaling      |
| **Partition Split**    | Automatic                           | Automatic                      |
| **Failover**           | Configurable priority (auto/manual) | Region-level, more manual      |
| **Multi-API**          | SQL, Mongo, Cassandra, etc.         | Only Dynamo API (with PartiQL) |

---

## üõ†Ô∏è Implementation Example

### Create a Multi-Region Account (Azure CLI)

```bash
az cosmosdb create \
  --name mycosmos \
  --resource-group myrg \
  --locations regionName=eastus failoverPriority=0 \
  --locations regionName=westeurope failoverPriority=1 \
  --default-consistency-level Session
```

### Add a Container with Partition Key (C# SDK)

```csharp
Container container = await db.CreateContainerIfNotExistsAsync(
    id: "products",
    partitionKeyPath: "/category", // Partition Key
    throughput: 400
);
```

---

## üéØ Exam Gotchas (Global Dist. + Partitioning)

- **Partition Key is mandatory** for containers (except fixed containers <20 GB).
- **Cross-partition queries cost more RU**.
- **Unit of scale = Container**, not Database.
- **Multi-Region Writes** = active-active, conflicts possible.
- **Automatic failover** needs to be explicitly enabled.
- **SLA (99.999%)** only applies when you use **multi-region writes**.
