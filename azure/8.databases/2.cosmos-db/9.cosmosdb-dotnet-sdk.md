# **Azure Cosmos DB .NET SDK (SQL API)**

## üß∞ packages you need

```xml
<ItemGroup>
  <PackageReference Include="Microsoft.Azure.Cosmos" Version="3.*" />
  <PackageReference Include="Azure.Identity" Version="1.*" />
</ItemGroup>
```

- `Microsoft.Azure.Cosmos`: the data-plane SDK (v3/v4).
- `Azure.Identity`: for **Managed Identity** / AAD auth via `DefaultAzureCredential`.

---

## üîå Connect: `CosmosClient` & `CosmosClientOptions`

### Core classes

- **`CosmosClient`** ‚Äì root client (thread-safe, reuse one per process).
- **`CosmosClientOptions`** ‚Äì tuning (retries, regions, serialization, bulk).
- **`Database`**, **`Container`** ‚Äì handles to logical resources.

### minimal (keys)

```csharp
var client = new CosmosClient(endpoint, primaryKey);
```

### best practice (managed identity / AAD)

```csharp
using Azure.Identity;
var cred = new DefaultAzureCredential(); // MI in Azure; az login locally
var options = new CosmosClientOptions {
    ApplicationName = "MyApp",
    ApplicationPreferredRegions = new[] { "East US", "West Europe" }, // low latency reads
    AllowBulkExecution = true, // enable bulk if you do parallel writes
    MaxRetryAttemptsOnRateLimitedRequests = 9,
    MaxRetryWaitTimeOnRateLimitedRequests = TimeSpan.FromSeconds(30),
    SerializerOptions = new CosmosSerializationOptions { PropertyNamingPolicy = CosmosPropertyNamingPolicy.CamelCase }
};
var client = new CosmosClient(endpoint, cred, options);
```

### Connection mode (rarely changed)

- default **Gateway** (HTTPS through gateway).
- **Direct** for lower latency + more connections:

```csharp
options.ConnectionMode = ConnectionMode.Direct;
```

---

## üèóÔ∏è Create or get db & container

### main methods

- `CosmosClient.CreateDatabaseIfNotExistsAsync(name)`
- `Database.CreateContainerIfNotExistsAsync(id, partitionKeyPath, throughput?)`
- `CosmosClient.GetDatabase(name)`, `Database.GetContainer(id)`

### example

```csharp
var db = await client.CreateDatabaseIfNotExistsAsync("store");
var container = await db.CreateContainerIfNotExistsAsync(
    id: "products", partitionKeyPath: "/category", throughput: 400);
```

---

## üì¶ Model

```csharp
public record Product(
    string id,
    string name,
    string category,
    double price,
    string? description = null
);
```

> tip: keep `id` as string; choose **high-cardinality** partition key (e.g., `/category` only if it has many values).

---

## ‚úçÔ∏è CRUD: `Container` core methods

### Create

- `CreateItemAsync<T>(item, partitionKey, ItemRequestOptions?)`

```csharp
await container.CreateItemAsync(new Product("p1","Laptop","Electronics",1200), new PartitionKey("Electronics"));
```

### Read (point read ‚Äì cheapest!)

- `ReadItemAsync<T>(id, partitionKey)`

```csharp
var resp = await container.ReadItemAsync<Product>("p1", new PartitionKey("Electronics"));
var product = resp.Resource;
```

### Replace (full document update)

- `ReplaceItemAsync<T>(item, id, partitionKey)`

```csharp
var updated = product with { price = 1099 };
await container.ReplaceItemAsync(updated, updated.id, new PartitionKey(updated.category));
```

### Delete

- `DeleteItemAsync<T>(id, partitionKey)`

```csharp
await container.DeleteItemAsync<Product>("p1", new PartitionKey("Electronics"));
```

---

## ü©π Partial updates: `PatchItemAsync`

Use when you need to update just a few properties (saves RUs).

```csharp
using Microsoft.Azure.Cosmos;

await container.PatchItemAsync<Product>(
    id: "p1",
    partitionKey: new PartitionKey("Electronics"),
    patchOperations: new[]
    {
        PatchOperation.Replace("/price", 999),
        PatchOperation.Add("/tags", new[] {"gaming","portable"})
    });
```

---

## üîé Query: SQL, request options, paging

### Query methods

- `GetItemQueryIterator<T>(QueryDefinition, continuationToken?, QueryRequestOptions?)`
- `QueryDefinition` with parameters
- `QueryRequestOptions` to **pin partition** (huge RU saver)

### Parameterized query (single partition)

```csharp
var q = new QueryDefinition("SELECT * FROM c WHERE c.category = @cat AND c.price >= @min")
            .WithParameter("@cat", "Electronics")
            .WithParameter("@min", 500);

var it = container.GetItemQueryIterator<Product>(
            q,
            requestOptions: new QueryRequestOptions {
                PartitionKey = new PartitionKey("Electronics"), // avoids cross-partition fan-out
                MaxItemCount = 50
            });

var results = new List<Product>();
while (it.HasMoreResults)
{
    var page = await it.ReadNextAsync();
    results.AddRange(page);
    // page.ContinuationToken for manual paging (rarely needed in apps)
}
```

### Cross-partition query (only when necessary)

```csharp
var itAll = container.GetItemQueryIterator<Product>(
    new QueryDefinition("SELECT * FROM c WHERE c.price >= @min").WithParameter("@min", 1000));
// Costs more RU ‚Äì design data to avoid this when possible.
```

---

## üß™ Transactional batch (same partition key)

Atomic operations across multiple items with the **same** partition key.

### Key methods

- `Container.CreateTransactionalBatch(partitionKey)`
- chain `CreateItem`, `ReplaceItem`, `DeleteItem`, `PatchItem`
- `ExecuteAsync()`

### Example

```csharp
var pk = new PartitionKey("Electronics");
var batch = container.CreateTransactionalBatch(pk)
    .CreateItem(new Product("p2","Phone","Electronics",699))
    .PatchItem("p1", new[] { PatchOperation.Replace("/price", 949) });

TransactionalBatchResponse res = await batch.ExecuteAsync();
if (!res.IsSuccessStatusCode) { /* handle errors */ }
```

---

## üöö High-throughput inserts: bulk & parallelism

- enable `AllowBulkExecution = true` in `CosmosClientOptions`.
- write using many concurrent tasks (SDK optimizes RU + TCP).

```csharp
var items = Enumerable.Range(0, 1000).Select(i =>
    new Product($"p{i}", $"Item{i}", i%2==0 ? "Electronics" : "Books", i));

var tasks = items.Select(p =>
    container.CreateItemAsync(p, new PartitionKey(p.category)));

await Task.WhenAll(tasks);
```

---

## üîÅ Change feed (read changes over time)

Great for event-driven processing, projections, CQRS, etc.

### pull model (simple)

```csharp
var iterator = container.GetChangeFeedIterator<Product>(
    ChangeFeedStartFrom.Now(), ChangeFeedMode.Incremental);

while (true)
{
    var response = await iterator.ReadNextAsync();
    foreach (var item in response)
        Console.WriteLine($"Changed: {item.id}");
    await Task.Delay(1000);
}
```

### serverless trigger model (Azure Functions)

- **Cosmos DB Trigger** (needs a **lease** container to track progress).
- You already saw the Functions snippet earlier.

---

## ‚öôÔ∏è Request/operation options you‚Äôll actually use

### `ItemRequestOptions`

- `IfMatchEtag` (optimistic concurrency control)
- `ConsistencyLevel` (override per request)

```csharp
var read = await container.ReadItemAsync<Product>("p1", new PartitionKey("Electronics"));
var etag = read.ETag;

var updated = read.Resource with { price = 929 };
await container.ReplaceItemAsync(updated, updated.id, new PartitionKey(updated.category),
    new ItemRequestOptions { IfMatchEtag = etag }); // fails if document changed
```

### `QueryRequestOptions`

- `PartitionKey`
- `MaxItemCount`
- `ConsistencyLevel`

---

## üìà Throughput & management from SDK

### read current throughput

```csharp
ThroughputResponse tr = await container.ReadThroughputAsync();
Console.WriteLine(tr.Resource?.Throughput); // null if inherited from database
```

### update to autoscale

```csharp
await container.ReplaceThroughputAsync(
    ThroughputProperties.CreateAutoscaleThroughput(10000)); // scales 1000‚Äì10000 RU/s
```

---

## üß≠ Indexing policy (SDK fetch/update)

> usually set at create time (IaC). you can still read/replace via SDK.

```csharp
var props = await container.ReadContainerAsync();
var indexing = props.Resource.IndexingPolicy;

indexing.ExcludedPaths.Add(new ExcludedPath { Path = "/description/*" });

props.Resource.IndexingPolicy = indexing;
await container.ReplaceContainerAsync(props.Resource);
```

---

## üßæ Diagnostics, logging, retries

### get per-call diagnostics

```csharp
try
{
    var r = await container.ReadItemAsync<Product>("p404", new PartitionKey("Electronics"));
}
catch (CosmosException ex)
{
    Console.WriteLine(ex.StatusCode);      // e.g., NotFound, TooManyRequests
    Console.WriteLine(ex.Diagnostics);     // request timeline, regions hit, RU charge
}
```

### retry behavior (throttling 429)

- SDK auto-retries up to `MaxRetryAttemptsOnRateLimitedRequests`.
- Keep `MaxRetryWaitTimeOnRateLimitedRequests` reasonable (e.g., 30s).

---

## üß± Stream api (advanced perf)

If you already have JSON, avoid (de)serialization overhead:

```csharp
using var stream = new MemoryStream(Encoding.UTF8.GetBytes(json));
var resp = await container.CreateItemStreamAsync(stream, new PartitionKey("Electronics"));
if (resp.IsSuccessStatusCode) { /* ... */ }
```

---

## üß™ LINQ (optional)

The SDK has a LINQ provider; SQL + `QueryDefinition` is clearer and more portable for most teams, but LINQ exists:

```csharp
var q = container.GetItemLinqQueryable<Product>(allowSynchronousQueryExecution: false)
                 .Where(p => p.category == "Electronics" && p.price >= 500)
                 .ToFeedIterator();

while (q.HasMoreResults)
    foreach (var p in await q.ReadNextAsync()) Console.WriteLine(p.name);
```

---

## üß† Cheat cards (memorize fast)

**objects you always touch:**

- `CosmosClient` ‚Üí `Database` ‚Üí `Container`

**CRUD you‚Äôll actually call:**

- `CreateItemAsync`, `ReadItemAsync`, `ReplaceItemAsync`, `DeleteItemAsync`, `PatchItemAsync`

**query trio:**

- `QueryDefinition` + params
- `GetItemQueryIterator<T>(..., QueryRequestOptions{ PartitionKey = ... })`
- iterate pages with `ReadNextAsync()`

**scale & ops:**

- `ReadThroughputAsync`, `ReplaceThroughputAsync(Autoscale)`
- indexing: `ReadContainerAsync` ‚Üí tweak `IndexingPolicy` ‚Üí `ReplaceContainerAsync`

**resilience:**

- Prefer **Managed Identity**, one `CosmosClient`, **Direct** mode for low latency, **PreferredRegions**, retry settings.

**RU hygiene:**

- point reads with `id + partitionKey`
- set `PartitionKey` on queries
- use **Patch** instead of **Replace** for small updates
- pre-create **composite indexes** for common filters + `ORDER BY`

---

## üß© End-to-end tiny demo (copy-paste)

```csharp
using System.Text.Json;
using Azure.Identity;
using Microsoft.Azure.Cosmos;

var endpoint = "https://<your-account>.documents.azure.com/";
var cred = new DefaultAzureCredential();

var client = new CosmosClient(endpoint, cred, new CosmosClientOptions {
    ConnectionMode = ConnectionMode.Direct,
    ApplicationPreferredRegions = new[] { "East US" },
    MaxRetryAttemptsOnRateLimitedRequests = 9,
    MaxRetryWaitTimeOnRateLimitedRequests = TimeSpan.FromSeconds(30),
});

var db = await client.CreateDatabaseIfNotExistsAsync("store");
var container = await db.CreateContainerIfNotExistsAsync("products", "/category", 400);

var p1 = new Product("p1","Laptop","Electronics",1200);
await container.CreateItemAsync(p1, new PartitionKey(p1.category));

var read = await container.ReadItemAsync<Product>("p1", new PartitionKey("Electronics"));
Console.WriteLine($"RU charge (read): {read.RequestCharge}");

await container.PatchItemAsync<Product>("p1", new PartitionKey("Electronics"),
    new[] { PatchOperation.Replace("/price", 1099) });

var q = new QueryDefinition("SELECT * FROM c WHERE c.category = @c")
            .WithParameter("@c", "Electronics");
var it = container.GetItemQueryIterator<Product>(q,
    requestOptions: new QueryRequestOptions { PartitionKey = new PartitionKey("Electronics") });

while (it.HasMoreResults)
{
    foreach (var item in await it.ReadNextAsync())
        Console.WriteLine(JsonSerializer.Serialize(item));
}

await container.DeleteItemAsync<Product>("p1", new PartitionKey("Electronics"));

public record Product(string id, string name, string category, double price);
```
