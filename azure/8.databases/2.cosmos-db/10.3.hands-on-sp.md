# üß† What are Stored Procedures in Cosmos DB?

- **Server-side JavaScript** functions you upload to a **container**.
- Run **inside the database engine** and can perform **multiple operations atomically** **within a single logical partition** (same partition key value).
- Great for: reducing round-trips, enforcing invariants, and doing **ACID** multi-item changes in one go.

> Scope rule (critical): a stored proc can **only read/write items in one logical partition** (i.e., a single value of your partition key). That‚Äôs how Cosmos DB guarantees transactionality.

---

## üß≠ When should you use them?

Use a stored procedure when you need **any combination** of:

1. **Atomic multi-item operations** within a partition
   e.g., ‚Äúupdate order + its items together or roll back all.‚Äù
2. **Business logic close to data** to cut RU + latency
   e.g., bulk upserts of 100 items with one network call.
3. **Conditional workflows** that must be all-or-nothing
   e.g., only insert if a guard document says capacity left.

### Consider alternatives

- **Stored Procedure (sproc)** in Cosmos DB **does not** run automatically or intercept requests.
- It **runs only when your app explicitly calls it** (like calling a function on the server).
- If you want ‚Äúmiddleware-like interception,‚Äù that‚Äôs what **Triggers** are for:

  - **Pre-trigger**: runs **before** a create/replace operation.
  - **Post-trigger**: runs **after** a create/replace operation.

- **TransactionalBatch** (SDK feature) is often simpler for multi-item insert/update/delete in one partition.
- **Change Feed + Functions** for asynchronous pipelines.

> Still, stored procedures shine when you want **custom control flow** and **looping** server-side, not just a batch of simple ops.

---

## üß± How they work (quick internals)

- Written in **JavaScript** using the built-ins:

  - `getContext()` ‚Üí request/response context
  - `getCollection()` ‚Üí data operations (query/create/replace/delete)

- You call them with:

  - **ID** of the stored procedure
  - A **PartitionKey** value (the transaction‚Äôs partition)
  - Optional **parameters** (JSON serializable)

- They execute with **bounded time/RU**, so typical patterns use **continuations** (callbacks) and **early returns** when RU/time is tight.

---

## ‚öôÔ∏è What actually happens when a sproc runs?

- You call it from your app via SDK/REST: `ExecuteStoredProcedureAsync("sprocId", partitionKey, params...)`.
- Cosmos routes the call to the **target logical partition** (based on the partition key **you pass**).
- The **JavaScript** sproc runs **inside that partition**, can read/write **only items with that same partition key value**, and is **atomic** (ACID) within that scope.
- It returns a **response body** (whatever you set in `getResponse().setBody(...)`) or throws, which rolls back the transaction.

---

<div>

```mermaid
sequenceDiagram
    autonumber
    participant App as Client App (.NET)
    participant SDK as Cosmos .NET SDK
    participant GW as Cosmos Gateway/Direct
    participant Part as Target Logical Partition
    participant JS as Sproc Runtime (JavaScript)
    participant Store as Storage/Index (Partition Data)

    App->>SDK: ExecuteStoredProcedureAsync("bulkUpsert", pk="Electronics", [docs])
    SDK->>GW: Auth (AAD/Key), route request (container + sprocId + PK)
    GW->>Part: Route to partition owning PK="Electronics"
    Part->>JS: Initialize sproc context (getContext/getCollection)
    JS->>Store: create/upsert/read/replace/delete items (only PK="Electronics")
    Note over JS,Store: Operations are transactional (ACID) within this partition
    alt RU/time remaining
        JS-->>Part: Continue processing next item
        Part-->>JS: OK
    else RU/time exhausted
        JS-->>Part: setBody({ updated: n, partial: true })
    end
    JS-->>Part: setBody({ updated: total })
    Part-->>GW: Return sproc result + RU charge + diagnostics
    GW-->>SDK: HTTP 200 + body (or error)
    SDK-->>App: Sproc result (deserialized)
```

</div>

---

## ‚öñÔ∏è When do you use each: sproc vs trigger?

### 1Ô∏è‚É£ Stored Procedure

- **How it runs:** Only when **you call it**.
- **Scope:** One **logical partition** (same partition key value).
- **Use for:** Complex multi-step logic, loops, conditionals, multi-item **atomic** updates, custom validation + writes in one transaction.

### 2Ô∏è‚É£ Trigger (middleware-like)

- **How it runs:** Automatically **when attached** to a create/replace operation.

  - **Pre-trigger**: runs **before** the write; can modify the document or reject the op.
  - **Post-trigger**: runs **after** the write; good for audit, side-effects.

- **Scope:** The single item being written (same partition, since the write itself is scoped).
- **Use for:** Validation, stamping metadata, audit trails, enforcing invariants per item.

> UDFs (user-defined functions) are different again: small JS functions used **inside queries** for custom calculations (no I/O, no writes).

---

## üõ†Ô∏è Full Hands-On: Create, Register, Execute

We‚Äôll build a stored proc `bulkUpsert` that:

- Accepts an array of documents (all with the **same partition key value**),
- Upserts them one by one,
- Returns how many it inserted/updated.

Assume our container is **`products`** with partition key **`/category`**.

### 1) Stored Procedure (JavaScript)

```javascript
// id: bulkUpsert
function bulkUpsert(docs) {
  var context = getContext();
  var coll = context.getCollection();
  var response = context.getResponse();

  if (!docs || !docs.length) {
    response.setBody({ updated: 0 });
    return;
  }

  var count = 0;

  // Try to upsert each doc; stop if we run out of time/RU
  tryUpsert(docs[count]);

  function tryUpsert(doc) {
    // Ensure doc has the correct partition key value (required for transaction scope)
    // Example: doc.category must be same for all docs
    var accepted = coll.upsertDocument(coll.getSelfLink(), doc, function (err, docCreated) {
      if (err) throw err;

      count++;

      if (count >= docs.length) {
        // done
        response.setBody({ updated: count });
      } else {
        // continue
        tryUpsert(docs[count]);
      }
    });

    // If engine can‚Äôt accept more work in this tick (time/RU bounded), return what we have
    if (!accepted) {
      response.setBody({ updated: count, partial: true });
    }
  }
}
```

> Notes
>
> - `upsertDocument` creates or replaces by `id`.
> - We bail out early if the engine can‚Äôt accept more work; the caller can re-invoke with the remaining docs.
> - All docs must share the **same `category`** (the partition key value).

### 2) Register the Stored Procedure (C#/.NET)

```csharp
using Microsoft.Azure.Cosmos;

// client, db, container already created‚Ä¶
var sprocBody = File.ReadAllText("bulkUpsert.js");

var sprocProps = new StoredProcedureProperties
{
    Id = "bulkUpsert",
    Body = sprocBody
};

// Create or update (idempotent-ish pattern)
try
{
    await container.Scripts.CreateStoredProcedureAsync(sprocProps);
}
catch (CosmosException ex) when (ex.StatusCode == System.Net.HttpStatusCode.Conflict)
{
    await container.Scripts.ReplaceStoredProcedureAsync(sprocProps);
}
```

### 3) Execute the Stored Procedure (C#/.NET)

```csharp
var categoryPk = "Electronics"; // partition value for the whole transaction
var docs = new[]
{
    new { id = "p101", name = "Headphones", category = categoryPk, price = 199 },
    new { id = "p102", name = "Keyboard",   category = categoryPk, price = 89  },
    new { id = "p103", name = "Mouse",      category = categoryPk, price = 49  }
};

// Execute with partition key + params (params must match JS signature)
StoredProcedureExecuteResponse<dynamic> rsp =
    await container.Scripts.ExecuteStoredProcedureAsync<dynamic>(
        storedProcedureId: "bulkUpsert",
        partitionKey: new PartitionKey(categoryPk),
        parameters: new dynamic[] { docs });

Console.WriteLine(rsp.Resource); // { "updated": 3 }  (or partial true if it stopped early)
```

---

## ‚è±Ô∏è Bounded Execution Model in Cosmos DB

### üìñ What It Means

- **All server-side code (Stored Procedures, Triggers, UDFs)** in Cosmos DB must finish within a **bounded execution time** (‚âà a few seconds, enforced by RU + resource limits).
- If the execution **completes within the limit** ‚Üí changes are **committed atomically**.
- If the execution **times out or errors** ‚Üí the entire transaction is **rolled back** (no partial updates).

> üëâ This ensures **ACID** transactions at the partition level.  
> üí° Maximum execution time for a stored procedure is **5 seconds**.

---

### üí≠ Example

Imagine you run a stored procedure to update an airport‚Äôs code:

- ‚úÖ If it runs fast and finishes ‚Üí the new code is saved.
- ‚ùå If it takes too long (e.g., too many reads/writes) ‚Üí Cosmos aborts and **rolls back all updates**.

This prevents **half-updated data**.

---

### üñºÔ∏è Bounded Execution Flow

<div align="center">

```mermaid
flowchart TD
    A[Start Stored Proc] --> B{Exec within time/RU?}
    B -- Yes --> C[Commit all changes]
    B -- No/Error --> D[Rollback all changes]
    C --> E[Return Success]
    D --> F[Return Error]
```

</div>

---

### üìù Exam Tip

- Always assume **bounded runtime** for sprocs/triggers/UDFs.
- Design sprocs to do **small work per call**.
- For bulk ops, combine with **continuation model** (next section).

---

## üîÅ Transaction Continuation

### üìñ What It Means

- Cosmos DB provides a **continuation model** for long-running sprocs.
- Instead of failing when the **execution bound is hit**, a sproc can:

  - Do **partial work** (e.g., process first 100 docs).
  - Return a **continuation token** (like a pointer/marker).
  - Client re-calls the sproc, passing the token, so it resumes where it left off.

üëâ This way, bulk operations are broken into **safe, resumable chunks**.

---

### üí≠ Example

Updating 10,000 airport records in one partition:

- First call ‚Üí updates 1,000 docs, then returns token.
- Second call ‚Üí resumes with token, updates next 1,000.
- Repeat until all docs are processed.

Every **chunk is ACID within itself**.

---

### üñºÔ∏è Continuation Flow

<div align="center">

```mermaid
sequenceDiagram
    participant App as Client App
    participant SProc as Stored Procedure
    participant DB as Cosmos Partition

    App->>SProc: Call bulkUpdate(token=null)
    SProc->>DB: Process batch of docs (e.g., 1000)
    alt Execution limit reached
        SProc-->>App: Return { processed:1000, continuationToken:"ptr1" }
        App->>SProc: Call bulkUpdate(token="ptr1")
        SProc->>DB: Process next batch
        SProc-->>App: Return { processed:2000, continuationToken:"ptr2" }
    else Completed
        SProc-->>App: Return { processed:10000, done:true }
    end
```

</div>

---

<div align="center">
  <img src="image/10.3.hands-on-sp/1758054805615.png" alt="Bounded Execution Model" style="border-radius: 10px; border: 2px solid; width: 80%">
</div>

---

## ‚úçÔ∏è Another classic pattern: transactional ‚Äútransfer‚Äù

If you need **read-modify-write** across **multiple docs** in the **same partition**, a stored procedure can:

1. Query doc A (ensure invariants),
2. Update doc A,
3. Update doc B,
4. Return success or throw to roll back everything.

> This is similar to `TransactionalBatch`, but a sproc lets you **query/branch** mid-transaction in JavaScript.

---

## üß© Common options, tips & gotchas

- **Partition scope**: You must pass the **partition key value** when executing. All reads/writes must target that same value.
- **Time/RU bounded**: If your loop is big, design for **partial progress** and re-invoke with remaining work (the example above handles this).
- **Security**:

  - Key-based apps: fine.
  - **AAD/RBAC**: ensure your principal has data plane rights that allow scripts (e.g., **Cosmos DB Built-in Data Contributor**).

- **Versioning**: Treat sproc body as code; store in source control and redeploy via CI/CD.
- **Debugging**: Return useful info in the response body (`counts`, `ids processed`) and log from your app on failures.
- **When not to use**:

  - Cross-partition transactions (not supported).
  - Simple same-partition CRUD without branching ‚Üí prefer **TransactionalBatch** (cleaner, typed).

- **Triggers & UDFs (for context)**:

  - **Pre-trigger**: validate/augment docs before create/replace.
  - **Post-trigger**: audit/log after write.
  - **UDFs**: custom scalar functions usable inside SQL queries (no I/O).

- Stored procedures **must finish within bounded execution time**.
- If they don‚Äôt ‚Üí **rollback happens automatically**.
- Use **continuation tokens** to implement **resumable transactions**.

---

## üìé Minimal ‚Äúcheat sheet‚Äù to memorize

- **Where**: Stored on **container**; execute with **partition key**.
- **Language**: **JavaScript** with `getContext()/getCollection()`.
- **Why**: **Atomic** multi-item work in **one partition**; fewer round-trips.
- **Call**: `container.Scripts.ExecuteStoredProcedureAsync<T>(id, pk, params)`
- **Bulk**: Loop `createDocument/upsertDocument`; stop when not `accepted` (partial progress).
- **Alt**: Prefer **TransactionalBatch** for simple multi-item ops; sprocs for custom logic.
