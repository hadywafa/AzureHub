# ğŸ“‚ Cosmos DB â€“ Data Modeling & Indexing

## ğŸ—ƒï¸ How Data is Stored

- Cosmos DB stores everything as **JSON documents** internally.
- Regardless of which API (SQL, Mongo, Cassandra, Table, Gremlin) â†’ data is translated into JSON.
- Each **item** = one JSON document.

ğŸ‘‰ Think of a **container** as a table/collection with many JSON items.

Example:

```json
{
  "id": "p1",
  "name": "Laptop",
  "category": "Electronics",
  "price": 1200,
  "tags": ["gaming", "portable"]
}
```

---

## ğŸ§© Data Modeling Principles

When designing a schema:

1. **Partition Key** choice is critical â†’ drives scalability.
2. Cosmos DB is **schema-less** (you can add new fields easily).
3. **Denormalization** is common (store related data together).

   - Example: Instead of splitting "Orders" and "OrderItems" â†’ nest OrderItems inside the Order.

4. Aim for **query efficiency**: Model data to avoid expensive cross-partition joins.

ğŸ‘‰ Exam Tip: Cosmos DB prefers **embedding** over joining (like DynamoDB).

---

## ğŸ” Indexing in Cosmos DB

### 1. Automatic Indexing

- Cosmos DB **indexes every property by default** (no need to define secondary indexes like DynamoDB).
- This makes queries flexible but can increase **RU cost**.

### 2. Indexing Policies

- You can customize **which fields get indexed**.
- Two modes:

  - **Consistent (default)** â†’ index updated synchronously with writes (stronger, but more RU cost).
  - **Lazy** â†’ index updated asynchronously (cheaper, but less consistent).

### 3. Excluding Properties from Index

- Example: Exclude large text/blob fields from indexing to reduce RU consumption.

Example Policy (exclude `description` field):

```json
{
  "indexingMode": "consistent",
  "includedPaths": [{ "path": "/*" }],
  "excludedPaths": [{ "path": "/description/*" }]
}
```

---

## ğŸ“Š Querying Data (SQL API)

Cosmos DBâ€™s SQL API supports SQL-like queries.

Examples:

- **Point Read (fastest, cheapest)**

```sql
SELECT * FROM Products p WHERE p.id = "p1" AND p.category = "Electronics"
```

ğŸ‘‰ RU â‰ˆ 1 (hits one partition).

- **Cross-Partition Query (more expensive)**

```sql
SELECT * FROM Products p WHERE p.price > 1000
```

ğŸ‘‰ RU higher, because it scans all partitions.

- **JOINs (supported but costly)**

```sql
SELECT o.id, i.productName
FROM Orders o
JOIN i IN o.items
```

ğŸ‘‰ Supported only within the same document, not across containers.

---

## ğŸ“Š Indexing Types

Cosmos DB supports multiple index types:

- **Range indexes** â†’ Efficient for comparisons (`>`, `<`, `=`, BETWEEN).
- **Hash indexes** â†’ Exact matches.
- **Spatial indexes** â†’ Geo queries (locations, radius search).
- **Composite indexes** â†’ Optimize multi-field queries (e.g., ORDER BY `price` + `category`).

ğŸ‘‰ Example: Composite index for queries sorted by `category` and `price`.

```json
{
  "compositeIndexes": [
    [
      { "path": "/category", "order": "ascending" },
      { "path": "/price", "order": "descending" }
    ]
  ]
}
```

---

## âš¡ RU & Query Cost Optimization

- **Point reads with id + partition key** â†’ cheapest (1 RU).
- **Cross-partition scans** â†’ expensive.
- **Custom indexing policies** can reduce RU cost by excluding unnecessary fields.
- **Composite indexes** reduce RU for multi-property queries.

---

## ğŸ†š AWS Comparison

| Cosmos DB                                  | DynamoDB                                        |
| ------------------------------------------ | ----------------------------------------------- |
| Auto-indexes all fields (default)          | Only partition key + optional secondary indexes |
| Custom indexing policies (include/exclude) | Must define Global/Local Secondary Indexes      |
| Composite indexes                          | Global secondary indexes with sort key          |
| Query language: SQL API                    | PartiQL (recently added)                        |

ğŸ‘‰ Cosmos = more flexible out of the box, DynamoDB = more manual.

---

## ğŸ› ï¸ Implementation Examples

### Create Container with Custom Indexing (Azure CLI)

```bash
az cosmosdb sql container create \
  --account-name mycosmos \
  --database-name mydb \
  --name products \
  --partition-key-path "/category" \
  --idx @indexpolicy.json
```

Where `indexpolicy.json` contains:

```json
{
  "indexingMode": "consistent",
  "excludedPaths": [{ "path": "/description/*" }]
}
```

### Query Example (C# SDK)

```csharp
var query = container.GetItemQueryIterator<dynamic>(
    "SELECT * FROM c WHERE c.category = 'Electronics'"
);

while (query.HasMoreResults)
{
    foreach (var item in await query.ReadNextAsync())
    {
        Console.WriteLine(item);
    }
}
```

---

## ğŸ¯ Exam Gotchas

- **All properties are indexed by default** (unless excluded).
- **Cross-partition queries cost more RU**.
- **Point reads with partition key are cheapest**.
- **JOINs only work within the same document** (not across containers).
- **Composite indexes** must be explicitly defined for multi-property queries.
- **Exclude large fields from indexing** to save RU.

ğŸ‘‰ Example Exam Question:
_â€œYou query a container with high RU consumption. You discover large text fields are being indexed unnecessarily. What should you do?â€_
âœ”ï¸ Modify **indexing policy** to exclude those fields.
