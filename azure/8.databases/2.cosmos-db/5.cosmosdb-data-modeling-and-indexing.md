# 📂 Cosmos DB – Data Modeling & Indexing

## 🗃️ How Data is Stored

- Cosmos DB stores everything as **JSON documents** internally.
- Regardless of which API (SQL, Mongo, Cassandra, Table, Gremlin) → data is translated into JSON.
- Each **item** = one JSON document.

👉 Think of a **container** as a table/collection with many JSON items.

Example:

```json
{
  "id": "p1",
  "name": "Laptop",
  "category": "Electronics",
  "price": 1200,
  "tags": ["gaming", "portable"]
}
```

---

## 🧩 Data Modeling Principles

When designing a schema:

1. **Partition Key** choice is critical → drives scalability.
2. Cosmos DB is **schema-less** (you can add new fields easily).
3. **Denormalization** is common (store related data together).

   - Example: Instead of splitting "Orders" and "OrderItems" → nest OrderItems inside the Order.

4. Aim for **query efficiency**: Model data to avoid expensive cross-partition joins.

👉 Exam Tip: Cosmos DB prefers **embedding** over joining (like DynamoDB).

---

## 🔎 Indexing in Cosmos DB

### 1. Automatic Indexing

- Cosmos DB **indexes every property by default** (no need to define secondary indexes like DynamoDB).
- This makes queries flexible but can increase **RU cost**.

### 2. Indexing Policies

- You can customize **which fields get indexed**.
- Two modes:

  - **Consistent (default)** → index updated synchronously with writes (stronger, but more RU cost).
  - **Lazy** → index updated asynchronously (cheaper, but less consistent).

### 3. Excluding Properties from Index

- Example: Exclude large text/blob fields from indexing to reduce RU consumption.

Example Policy (exclude `description` field):

```json
{
  "indexingMode": "consistent",
  "includedPaths": [{ "path": "/*" }],
  "excludedPaths": [{ "path": "/description/*" }]
}
```

---

## 📊 Querying Data (SQL API)

Cosmos DB’s SQL API supports SQL-like queries.

Examples:

- **Point Read (fastest, cheapest)**

```sql
SELECT * FROM Products p WHERE p.id = "p1" AND p.category = "Electronics"
```

👉 RU ≈ 1 (hits one partition).

- **Cross-Partition Query (more expensive)**

```sql
SELECT * FROM Products p WHERE p.price > 1000
```

👉 RU higher, because it scans all partitions.

- **JOINs (supported but costly)**

```sql
SELECT o.id, i.productName
FROM Orders o
JOIN i IN o.items
```

👉 Supported only within the same document, not across containers.

---

## 📊 Indexing Types

Cosmos DB supports multiple index types:

- **Range indexes** → Efficient for comparisons (`>`, `<`, `=`, BETWEEN).
- **Hash indexes** → Exact matches.
- **Spatial indexes** → Geo queries (locations, radius search).
- **Composite indexes** → Optimize multi-field queries (e.g., ORDER BY `price` + `category`).

👉 Example: Composite index for queries sorted by `category` and `price`.

```json
{
  "compositeIndexes": [
    [
      { "path": "/category", "order": "ascending" },
      { "path": "/price", "order": "descending" }
    ]
  ]
}
```

---

## ⚡ RU & Query Cost Optimization

- **Point reads with id + partition key** → cheapest (1 RU).
- **Cross-partition scans** → expensive.
- **Custom indexing policies** can reduce RU cost by excluding unnecessary fields.
- **Composite indexes** reduce RU for multi-property queries.

---

## 🆚 AWS Comparison

| Cosmos DB                                  | DynamoDB                                        |
| ------------------------------------------ | ----------------------------------------------- |
| Auto-indexes all fields (default)          | Only partition key + optional secondary indexes |
| Custom indexing policies (include/exclude) | Must define Global/Local Secondary Indexes      |
| Composite indexes                          | Global secondary indexes with sort key          |
| Query language: SQL API                    | PartiQL (recently added)                        |

👉 Cosmos = more flexible out of the box, DynamoDB = more manual.

---

## 🛠️ Implementation Examples

### Create Container with Custom Indexing (Azure CLI)

```bash
az cosmosdb sql container create \
  --account-name mycosmos \
  --database-name mydb \
  --name products \
  --partition-key-path "/category" \
  --idx @indexpolicy.json
```

Where `indexpolicy.json` contains:

```json
{
  "indexingMode": "consistent",
  "excludedPaths": [{ "path": "/description/*" }]
}
```

### Query Example (C# SDK)

```csharp
var query = container.GetItemQueryIterator<dynamic>(
    "SELECT * FROM c WHERE c.category = 'Electronics'"
);

while (query.HasMoreResults)
{
    foreach (var item in await query.ReadNextAsync())
    {
        Console.WriteLine(item);
    }
}
```

---

## 🎯 Exam Gotchas

- **All properties are indexed by default** (unless excluded).
- **Cross-partition queries cost more RU**.
- **Point reads with partition key are cheapest**.
- **JOINs only work within the same document** (not across containers).
- **Composite indexes** must be explicitly defined for multi-property queries.
- **Exclude large fields from indexing** to save RU.

👉 Example Exam Question:
_“You query a container with high RU consumption. You discover large text fields are being indexed unnecessarily. What should you do?”_
✔️ Modify **indexing policy** to exclude those fields.
