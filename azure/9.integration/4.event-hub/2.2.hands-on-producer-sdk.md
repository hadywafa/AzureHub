# ðŸŸ¦ Event Hubs Producer in .NET (Azure.Messaging.EventHubs)

## 0) Install packages

```bash
dotnet add package Azure.Messaging.EventHubs
dotnet add package Azure.Messaging.EventHubs.Producer
```

---

## 1) Producer anatomy (what youâ€™ll use)

- **`EventHubProducerClient`** â€“ the class that connects and sends.
- **`EventData`** â€“ the event (bytes) + optional properties (headers).
- **`EventDataBatch`** â€“ a size-aware container; it keeps you under the brokerâ€™s max message size.
- **Partitioning** â€“ pick **Partition Key** (recommended) for per-key ordering, or target a **Partition Id** explicitly (advanced).
- **Retry** â€“ built in; configure with `EventHubProducerClientOptions.RetryOptions`.

---

## 2) Connect a producer

```csharp
using Azure.Messaging.EventHubs.Producer;

string ehConnStr = "<EVENT_HUBS_CONNECTION_STRING>";  // at namespace or hub scope
string ehName    = "<EVENT_HUB_NAME>";

var producer = new EventHubProducerClient(ehConnStr, ehName);

// If youâ€™re behind strict firewalls, you can force WebSockets:
// var producer = new EventHubProducerClient(
//     ehConnStr, ehName,
//     new EventHubProducerClientOptions { TransportType = EventHubsTransportType.AmqpWebSockets });
```

Dispose when done:

```csharp
await producer.DisposeAsync();
```

---

## 3) Send a single event (hello world)

```csharp
using Azure.Messaging.EventHubs;

var data = new EventData(BinaryData.FromString("{\"msg\":\"hello\"}"));
// optional application properties (headers)
data.Properties["source"] = "api";
data.Properties["schemaVersion"] = "1.0";

await producer.SendAsync(new[] { data });   // sends immediately (no batching logic)
```

> Works, but for real apps **always batch** to maximize throughput and avoid size errors.

---

## 4) Send with **automatic batching** (preferred)

```csharp
// Create a batch without partition hints
using EventDataBatch batch = await producer.CreateBatchAsync();

bool added = batch.TryAdd(new EventData(BinaryData.FromString("{\"id\":1}")));
added &= batch.TryAdd(new EventData(BinaryData.FromString("{\"id\":2}")));
added &= batch.TryAdd(new EventData(BinaryData.FromString("{\"id\":3}")));

if (!added)
{
    // If an event didnâ€™t fit, youâ€™d send the current batch and start a new one.
    // (Shown in the next example)
}

await producer.SendAsync(batch);
```

### Pattern for streaming many events with rollover:

```csharp
async Task SendManyAsync(IEnumerable<EventData> events)
{
    using var batch = await producer.CreateBatchAsync();
    EventDataBatch current = batch;

    foreach (var evt in events)
    {
        if (!current.TryAdd(evt))
        {
            await producer.SendAsync(current);
            current = await producer.CreateBatchAsync();

            if (!current.TryAdd(evt))
                throw new InvalidOperationException("Single event too large for a batch.");
        }
    }

    if (current.Count > 0)
        await producer.SendAsync(current);
}
```

---

## 5) Partitioning: **Partition Key vs Partition Id**

- **Partition Key (recommended):** preserves **ordering per key** and balances load via hashing.
  Example: all events for `UserId=U123` stay in order.

```csharp
var options = new CreateBatchOptions { PartitionKey = "U123" }; // same key = same partition
using var batch = await producer.CreateBatchAsync(options);

batch.TryAdd(new EventData(BinaryData.FromString("{\"orderId\":\"O1\"}")));
batch.TryAdd(new EventData(BinaryData.FromString("{\"orderId\":\"O2\"}")));

await producer.SendAsync(batch);
```

- **Partition Id (advanced):** pin events to a specific partition (you manage balancing and hot-spots yourself).

```csharp
var options = new CreateBatchOptions { PartitionId = "2" }; // target partition #2 explicitly
using var batch = await producer.CreateBatchAsync(options);
// add events...
await producer.SendAsync(batch);
```

> Tip: Prefer **Partition Key** unless you have a hard requirement to control the exact partition.

---

## 6) JSON helper (clean serialization)

```csharp
using System.Text.Json;

EventData ToEvent(object obj) =>
    new EventData(new BinaryData(JsonSerializer.Serialize(obj)));

var evt = ToEvent(new { UserId = "U123", OrderId = "O456", Status = "Created", Ts = DateTime.UtcNow });
evt.Properties["type"] = "OrderCreated";
await producer.SendAsync(new[] { evt });
```

---

## 7) Retries, timeouts, and diagnostics

```csharp
using Azure.Core;

var producer = new EventHubProducerClient(
    ehConnStr, ehName,
    new EventHubProducerClientOptions
    {
        RetryOptions = new EventHubsRetryOptions
        {
            Mode = EventHubsRetryMode.Exponential,
            TryTimeout = TimeSpan.FromSeconds(30),      // per operation
            MaximumRetries = 8,
            Delay = TimeSpan.FromMilliseconds(200),
            MaximumDelay = TimeSpan.FromSeconds(5)
        }
    });
```

Handle transient exceptions:

```csharp
try
{
    await producer.SendAsync(batch);
}
catch (Azure.Messaging.EventHubs.EventHubsException ex) when (ex.IsTransient)
{
    // Log + retry your SendAsync logic
}
```

---

## 8) Throughput & performance tips

- **Reuse one `EventHubProducerClient` per process** (itâ€™s thread-safe). Avoid per-send creation.
- **Batch!** Use `EventDataBatch` and roll over when `TryAdd` returns false.
- **Parallelism:** Itâ€™s safe to `SendAsync` multiple batches concurrently (e.g., `Task.WhenAll`) if you have lots of data.
- **Payload size:** Keep individual events small (KBs). A single event larger than the broker max will **never** fit (you must split/compress).
- **Compression:** Do it yourself (e.g., GZip the body) and set a header (`contentEncoding=gzip`) for your consumers to interpret.
- **Keys:** Use **Partition Key** for per-entity ordering (e.g., per UserId / DeviceId).
- **Backpressure:** If producers outpace consumers, consider **more partitions** and scale out consumers.
- **Firewall:** If direct AMQP is blocked, set `TransportType = AmqpWebSockets`.

---

## 9) End-to-end mini example

Send **order status** events keyed by `UserId` to keep each userâ€™s timeline ordered:

```csharp
var producer = new EventHubProducerClient(ehConnStr, ehName);

async Task SendOrderTimelineAsync(string userId, IEnumerable<object> orderEvents)
{
    var batch = await producer.CreateBatchAsync(new CreateBatchOptions { PartitionKey = userId });

    foreach (var e in orderEvents.Select(ToEvent))
    {
        if (!batch.TryAdd(e))
        {
            await producer.SendAsync(batch);
            batch = await producer.CreateBatchAsync(new CreateBatchOptions { PartitionKey = userId });

            if (!batch.TryAdd(e))
                throw new InvalidOperationException("Event too large for an empty batch.");
        }
    }

    if (batch.Count > 0)
        await producer.SendAsync(batch);
}

await SendOrderTimelineAsync("U123", new object[]
{
    new { UserId="U123", OrderId="O456", Status="Created",   Ts=DateTime.UtcNow },
    new { UserId="U123", OrderId="O456", Status="Paid",      Ts=DateTime.UtcNow.AddSeconds(2) },
    new { UserId="U123", OrderId="O456", Status="Shipped",   Ts=DateTime.UtcNow.AddSeconds(10) },
    new { UserId="U123", OrderId="O456", Status="Delivered", Ts=DateTime.UtcNow.AddHours(2) }
});
```

All four events for `U123` will hash to the **same partition**, preserving **per-user order**.

---

## 10) Troubleshooting checklist

- **`Event too large`** â†’ your single event body exceeds max size. Split or compress.
- **`TryAdd` returns false immediately for first event** â†’ the event alone is too big.
- **Hot partition** (one key dominates) â†’ choose a better key (e.g., `UserId%N + OrderId`) or shard key space.
- **Throttling** â†’ increase **Throughput Units/Processing Units** or spread load across more partitions.
- **Connection blocked** â†’ use **AMQP over WebSockets**.

---

### TL;DR

- Use **`EventHubProducerClient`** and **`EventDataBatch`**.
- Prefer **Partition Key** for ordering, avoid hard **Partition Id** unless necessary.
- Configure **retries**, **timeouts**, and **WebSockets** if needed.
- **Reuse** the producer, **batch** your events, and **send concurrently** for throughput.
