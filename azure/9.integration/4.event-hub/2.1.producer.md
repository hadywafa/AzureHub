# 🚀 Azure Event Hubs Producer in .NET (SDK Deep Dive)

## 🔹 Step 0: Install NuGet Packages

```bash
dotnet add package Azure.Messaging.EventHubs
dotnet add package Azure.Messaging.EventHubs.Producer
```

---

## 🔹 Step 1: Meet Your Cast (Core Classes)

| Class                    | Role                                                                              |
| ------------------------ | --------------------------------------------------------------------------------- |
| `EventHubProducerClient` | 🎬 The star → connects to Event Hub and sends events                              |
| `EventData`              | 📦 The message itself (body + metadata)                                           |
| `EventDataBatch`         | 📚 A smart container → ensures you don’t exceed Event Hub’s max message size      |
| `CreateBatchOptions`     | 🎯 Lets you target **Partition Key** (for order) or **Partition Id** (fixed slot) |

---

## 🔹 Step 2: Create a Producer Client

```csharp
var producer = new EventHubProducerClient(
    "<EVENT_HUB_CONNECTION_STRING>",
    "<EVENT_HUB_NAME>"
);

// Behind firewalls? Force WebSockets
// new EventHubProducerClient(..., new EventHubProducerClientOptions {
//     TransportType = EventHubsTransportType.AmqpWebSockets
// });
```

👉 **Best practice:** Create one `EventHubProducerClient` per process — it’s thread-safe. Don’t create/dispose for every send.

---

## 🔹 Step 3: Hello World (Single Event)

```csharp
var evt = new EventData(BinaryData.FromString("{\"msg\":\"hello world\"}"));
evt.Properties["source"] = "api";
evt.Properties["schemaVersion"] = "1.0";

await producer.SendAsync(new[] { evt });
```

✅ Works fine, but for real workloads → **always batch**.

---

## 🔹 Step 4: Send in Batches (Preferred Way)

```csharp
using EventDataBatch batch = await producer.CreateBatchAsync();

batch.TryAdd(new EventData(BinaryData.FromString("{\"id\":1}")));
batch.TryAdd(new EventData(BinaryData.FromString("{\"id\":2}")));

await producer.SendAsync(batch);
```

⚡ **Pro Tip:** `TryAdd` returns `false` when the batch is full → send the current batch and start a new one.

---

## 🔹 Step 5: Partitioning (Order vs Scale)

💡 Event Hubs splits data across **partitions**. You decide how events are mapped:

### Option A – Partition Key (recommended ✅)

Keeps **per-key ordering** (e.g., all orders for `UserId=123` in the same partition).

```csharp
var options = new CreateBatchOptions { PartitionKey = "User123" };
using var batch = await producer.CreateBatchAsync(options);

batch.TryAdd(new EventData(BinaryData.FromString("{\"order\":\"O1\"}")));
batch.TryAdd(new EventData(BinaryData.FromString("{\"order\":\"O2\"}")));

await producer.SendAsync(batch);
```

### Option B – Partition Id (advanced ⚠️)

Pin events to **exact partition** (you handle load-balancing).

```csharp
var options = new CreateBatchOptions { PartitionId = "2" }; // force partition #2
using var batch = await producer.CreateBatchAsync(options);

batch.TryAdd(new EventData(BinaryData.FromString("{\"order\":\"O3\"}")));
await producer.SendAsync(batch);
```

---

## 🔹 Step 6: JSON Helper (Clean Serialization)

```csharp
using System.Text.Json;

EventData ToEvent(object obj) =>
    new EventData(new BinaryData(JsonSerializer.Serialize(obj)));

await producer.SendAsync(new[] {
    ToEvent(new { UserId="U123", OrderId="O456", Status="Created" })
});
```

---

## 🔹 Step 7: Retry + Timeout Settings

```csharp
var producer = new EventHubProducerClient(
    connStr, hubName,
    new EventHubProducerClientOptions {
        RetryOptions = new EventHubsRetryOptions {
            Mode = EventHubsRetryMode.Exponential,
            MaximumRetries = 8,
            TryTimeout = TimeSpan.FromSeconds(30),
            Delay = TimeSpan.FromMilliseconds(200),
            MaximumDelay = TimeSpan.FromSeconds(5)
        }
    });
```

Handle transient errors:

```csharp
catch (EventHubsException ex) when (ex.IsTransient)
{
    // Retry logic here
}
```

---

## 🔹 Step 8: Mini Example – Order Timeline (Preserve User Order)

```csharp
async Task SendOrderTimelineAsync(string userId)
{
    var options = new CreateBatchOptions { PartitionKey = userId };
    using var batch = await producer.CreateBatchAsync(options);

    batch.TryAdd(ToEvent(new { UserId=userId, OrderId="O456", Status="Created" }));
    batch.TryAdd(ToEvent(new { UserId=userId, OrderId="O456", Status="Paid" }));
    batch.TryAdd(ToEvent(new { UserId=userId, OrderId="O456", Status="Shipped" }));

    await producer.SendAsync(batch);
}
```

📌 Result: All events for `U123` go to the **same partition** → consumer sees a perfectly ordered timeline.

---

## 🔹 Step 9: Performance Checklist

✅ Reuse one `EventHubProducerClient` per process
✅ Batch events (`EventDataBatch`)
✅ Use **Partition Key** for ordering; avoid fixed Partition Id unless required
✅ Compress large events (GZip) yourself
✅ Scale by adding **Throughput Units** and/or more **partitions**
✅ Parallelize sending (`Task.WhenAll`) for higher throughput

---

## 🏁 Summary

- **Producer = `EventHubProducerClient`**
- **Event = `EventData` (+ headers/properties)**
- **Batch = `EventDataBatch` (TryAdd loop → SendAsync)**
- **Partitioning = key-based (order) vs id-based (manual load balance)**
- **Scaling = reuse producer + batch + parallel send**

Think of Event Hub producer like a **restaurant waiter** 🍽️:

- `EventData` = the dish
- `EventDataBatch` = the tray
- `Partition Key` = keeps all dishes for a table together
- `Producer` = the waiter carrying trays to the right kitchen door (partition)
