# 🟦 Event Hub Consumer in .NET SDK

Azure Event Hubs provides **.NET SDK clients** that help you consume (read) events safely and efficiently. The main star here is the **`EventProcessorClient`**, which handles **partition ownership, load balancing, and checkpointing** for you.

Let’s break this down.

---

## 1. 🔑 Setup & Prerequisites

Install the package:

```bash
dotnet add package Azure.Messaging.EventHubs
dotnet add package Azure.Messaging.EventHubs.Processor
dotnet add package Azure.Storage.Blobs
```

Why Blob Storage?
👉 Because checkpoints (offsets) are stored there.

---

## 2. 🛠️ Basic Components

### 📦 EventHubConsumerClient (low-level)

- Lets you read from partitions manually.
- You control partition assignment, checkpointing, etc.
- Good for custom scenarios.

### ⚙️ EventProcessorClient (recommended)

- A **higher-level abstraction**.
- Handles:

  - Partition distribution across multiple instances (VMs/Pods).
  - Tracking offsets via checkpoint store (Blob Storage).
  - Failover and scaling.

👉 Most production apps should use `EventProcessorClient`.

---

## 3. 🧑‍💻 Example: EventProcessorClient

Here’s a **basic consumer** in C#:

```csharp
using Azure.Messaging.EventHubs;
using Azure.Messaging.EventHubs.Consumer;
using Azure.Messaging.EventHubs.Processor;
using Azure.Storage.Blobs;

class Program
{
    private const string ehConnectionString = "<EVENTHUBS_CONNECTION_STRING>";
    private const string ehName = "<EVENTHUB_NAME>";
    private const string blobConnectionString = "<BLOB_CONNECTION_STRING>";
    private const string blobContainerName = "checkpoints";

    static async Task Main()
    {
        // 1. Create Blob container client for checkpoints
        var storageClient = new BlobContainerClient(blobConnectionString, blobContainerName);

        // 2. Create the EventProcessorClient
        var processor = new EventProcessorClient(
            storageClient,
            EventHubConsumerClient.DefaultConsumerGroupName, // e.g. "$Default"
            ehConnectionString,
            ehName);

        // 3. Register event handler
        processor.ProcessEventAsync += async (ProcessEventArgs args) =>
        {
            Console.WriteLine($"Partition: {args.Partition.PartitionId}, " +
                              $"Sequence: {args.Data.SequenceNumber}, " +
                              $"Body: {args.Data.EventBody}");

            // ✅ Periodic checkpoint
            if (args.Data.SequenceNumber % 100 == 0)
            {
                await args.UpdateCheckpointAsync(args.CancellationToken);
            }
        };

        // 4. Register error handler
        processor.ProcessErrorAsync += (ProcessErrorEventArgs args) =>
        {
            Console.WriteLine($"Error in partition {args.PartitionId}: {args.Exception}");
            return Task.CompletedTask;
        };

        // 5. Start processing
        await processor.StartProcessingAsync();

        Console.WriteLine("Press ENTER to stop...");
        Console.ReadLine();

        // 6. Stop processing
        await processor.StopProcessingAsync();
    }
}
```

---

## 4. 🔄 How it Works Behind the Scenes

1. **Claiming partitions**
   Each VM/instance running this code will claim ownership of partitions using Blob leases.

   - If you have **4 partitions and 2 VMs**, each gets ~2 partitions.
   - If 1 VM dies, the other VM claims all 4.

2. **Processing events**
   Events arrive in `ProcessEventAsync`.
   You handle them there (store in DB, trigger workflows, etc.).

3. **Checkpointing**
   Call `UpdateCheckpointAsync()` after you finish processing a batch.
   This stores the **offset + sequence number** in Blob Storage.

4. **Failure recovery**
   If a VM dies, another VM picks up the partition and resumes from the last checkpoint.

---

## 5. 🧩 Manual Consumer (EventHubConsumerClient)

If you want **more control**:

```csharp
using Azure.Messaging.EventHubs;
using Azure.Messaging.EventHubs.Consumer;

var consumer = new EventHubConsumerClient(
    EventHubConsumerClient.DefaultConsumerGroupName,
    "<CONNECTION_STRING>",
    "<EVENTHUB_NAME>");

await foreach (PartitionEvent partitionEvent in consumer.ReadEventsAsync())
{
    Console.WriteLine($"Partition: {partitionEvent.Partition.PartitionId}");
    Console.WriteLine($"Data: {partitionEvent.Data.EventBody}");
}
```

👉 Downside: You must **manage partition distribution and checkpointing yourself**.

---

## 6. 💡 Best Practices

- **Use EventProcessorClient** unless you need hardcore custom logic.
- **Idempotency is key**: expect duplicates (at-least-once delivery).
- **Checkpoint wisely**:

  - Too often = performance hit.
  - Too rare = more replay after failover.
  - Rule of thumb: every **100–500 events** or every **30s**.

- **Scale consumers by partition count**:

  - Each partition → 1 active reader per consumer group.
  - For N partitions, max N concurrent readers in a consumer group.

- **Separate consumer groups** for different apps (e.g., analytics pipeline vs real-time alerting).

---

Do you want me to also show you a **checkpointing conflict demo** (what happens if 2 consumers in same group try to checkpoint the same partition), so you see how the SDK handles it?
