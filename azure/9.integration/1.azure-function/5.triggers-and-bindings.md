# ğŸ”” **Triggers & Bindings in Azure Functions**

Azure Functions becomes powerful because it can react to events (**triggers**) and easily connect to services (**bindings**) without boilerplate code.

---

```mermaid
flowchart LR
    subgraph ExternalServices["ğŸŒ External Services"]
        HTTPReq["HTTP Request"]
        QueueMsg["Queue Message"]
        TimerEvt["Timer Event"]
        BlobEvt["Blob Event"]
    end

    subgraph AzureFunction["âš¡ Azure Function"]
        Trigger["ğŸ”” Trigger (1 per function)"]
        Code["ğŸ“ Function Code"]
        InputB["â¬…ï¸ Input Binding(s)"]
        OutputB["â¡ï¸ Output Binding(s)"]
    end

    subgraph Destinations["ğŸ“¤ Destinations"]
        BlobStore["Blob Storage"]
        TableStore["Table Storage"]
        CosmosDB["Cosmos DB"]
        HttpResp["HTTP Response"]
    end

    %% Flows
    HTTPReq --> Trigger
    QueueMsg --> Trigger
    TimerEvt --> Trigger
    BlobEvt --> Trigger

    Trigger --> |optional| InputB
    InputB --> |optional|Code
    Code --> |optional| OutputB

    OutputB --> BlobStore
    OutputB --> TableStore
    OutputB --> CosmosDB
    OutputB --> HttpResp
```

- **Triggers (ğŸ””)**: exactly **one per function**, comes from external event (HTTP, Queue, Timer, Blob).
- **Input Bindings (â¬…ï¸)**: optional, provide extra data _into_ the function.
- **Function Code (ğŸ“)**: your business logic.
- **Output Bindings (â¡ï¸)**: optional, send processed data _out_ to Azure services.
- **Destinations (ğŸ“¤)**: could be Blob Storage, Cosmos DB, Table Storage, or just an HTTP response.

---

## **ğŸ“¥ Triggers** (The â€œStart Buttonâ€ ğŸš€)

- **Definition**: A trigger is an event that **starts** a function.
- **Rule**: Each function must have **exactly one trigger**.
- **Examples**:

  - `HttpTrigger` â†’ when an HTTP request is received
  - `QueueTrigger` â†’ when a new message appears in Azure Queue Storage
  - `TimerTrigger` â†’ scheduled (like a CRON job)
  - `BlobTrigger` â†’ when a blob is added/updated in Azure Storage

ğŸ‘‰ Think of triggers as **â€œwhat wakes your function upâ€**.

---

## **ğŸ“¤ Bindings** (The â€œConnectorsâ€ ğŸ”—)

- **Definition**: Bindings provide a **declarative way** to connect your function to external services (databases, queues, storage) **without writing integration code**.
- **Types**:

  - **Input binding** â†’ brings data _into_ your function
  - **Output binding** â†’ sends data _out_ of your function
  - **In-Out binding** â†’ read + update the same resource

ğŸ‘‰ Think of bindings as **â€œpipes that move data in/outâ€** of your function automatically.

---

## âœğŸ» **Example**: Queue â†’ Blob (Combined Flow ğŸ“¦ â†’ â˜ï¸)

Scenario:

- Trigger: New queue message
- Input binding: Reads queue message
- Output binding: Writes result to Blob storage

```json
{
  "bindings": [
    {
      "type": "queueTrigger",
      "direction": "in",
      "name": "myQueueItem",
      "queueName": "orders",
      "connection": "AzureWebJobsStorage"
    },
    {
      "type": "blob",
      "direction": "out",
      "name": "outputBlob",
      "path": "processed/{rand-guid}.txt",
      "connection": "AzureWebJobsStorage"
    }
  ]
}
```

- Function is triggered when a message appears in `orders` queue
- Data is saved into Blob Storage automatically (`processed/â€¦txt`)

---

## ğŸ–¥ï¸ **Language-Specific Configurations**

- **C# / Java**: use **attributes/annotations**

  ```csharp
  public static void Run(
      [HttpTrigger(AuthorizationLevel.Function, "post")] HttpRequest req,
      [Table("MyTable", Connection="AzureWebJobsStorage")] IAsyncCollector<MyEntity> tableBinding)
  ```

- **JavaScript, Python, PowerShell, TypeScript**: use **function.json**
- **C#** can use either (attributes or JSON).

---

## âœğŸ» **Example:** HTTP â†’ Table Storage (Full Flow ğŸŒ â†’ ğŸ“Š)

Bindings (function.json):

```json
{
  "bindings": [
    {
      "type": "httpTrigger",
      "direction": "in",
      "name": "req",
      "authLevel": "function",
      "methods": ["post"]
    },
    {
      "type": "http",
      "direction": "out",
      "name": "$return"
    },
    {
      "type": "table",
      "direction": "out",
      "name": "outputTable",
      "tableName": "MyTable",
      "connection": "AzureWebJobsStorage",
      "partitionKey": "{partitionKey}",
      "rowKey": "{rowKey}"
    }
  ]
}
```

- Trigger: HTTP POST request
- Output: HTTP response
- Output: Row written to Table Storage

---

## âš ï¸ Using SDK Instead of Bindings (More Control)

Instead of declarative bindings, you can write integration logic in code. Example (C# with Azure.Data.Tables SDK):

- Read request body â†’ parse JSON â†’ connect to Table Storage â†’ insert row.
- Advantage: **flexibility** (custom logic, advanced scenarios).
- Disadvantage: More code compared to bindings.

---

## ğŸ“Œ Binding Directions (ğŸ”„ Quick Summary)

- **Trigger (always IN)** â†’ starts the function
- **Input binding (IN)** â†’ pulls data into the function
- **Output binding (OUT)** â†’ pushes data out
- **In-Out binding (IN-OUT)** â†’ read/update resource

---

## âœğŸ» Sample C# Function Using the Azure Storage SDK

Below is an example C# function that processes an HTTP POST request. The function deserializes the JSON payload and writes an entity to Azure Table Storage using the Azure.Data.Tables SDK.

```cs
using System.IO;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Extensions.Http;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using Azure.Data.Tables;
using Azure;


public static class WebToTableFunction
{
    [FunctionName("WebToTableFunction")]
    public static async Task<IActionResult> Run(
        [HttpTrigger(AuthorizationLevel.Function, "post", Route = null)] HttpRequest req,
        ILogger log)
    {
        log.LogInformation("C# HTTP trigger function processed a request.");


        string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
        dynamic data = JsonConvert.DeserializeObject(requestBody);


        string partitionKey = data?.partitionKey;
        string rowKey = data?.rowKey;
        string name = data?.name;
        string email = data?.email;


        if (string.IsNullOrEmpty(partitionKey) || string.IsNullOrEmpty(rowKey))
        {
            return new BadRequestObjectResult("Please pass both partitionKey and rowKey in the request body");
        }


        string storageConnectionString = Environment.GetEnvironmentVariable("AzureWebJobsStorage");
        TableServiceClient tableServiceClient = new TableServiceClient(storageConnectionString);
        TableClient tableClient = tableServiceClient.GetTableClient(tableName: "UserDetails");


        await tableClient.CreateIfNotExistsAsync();


        var entity = new TableEntity(partitionKey, rowKey)
        {
            { "Name", name },
            { "Email", email }
        };


        await tableClient.AddEntityAsync(entity);


        return new OkObjectResult("Data has been written to Azure Table Storage.");
    }
}
```

## ğŸ“Š Quick Comparison Table

| Feature      | Trigger     | Input Binding               | Output Binding              | In-Out Binding        |
| ------------ | ----------- | --------------------------- | --------------------------- | --------------------- |
| Purpose      | Start fn    | Bring data in               | Send data out               | Read + update         |
| Count per fn | 1 only      | Many allowed                | Many allowed                | Limited usage         |
| Examples     | Http, Timer | Queue message, Blob content | Cosmos DB write, Email send | Table row read/update |

---

## âœ… Key Takeaways

- **One trigger per function**.
- **Multiple bindings allowed** (input/output).
- Bindings save you from boilerplate integration code.
- Use **attributes (C#/Java)** or **function.json (JS/Python/etc.)**.
- You can always fall back to SDKs for advanced control.
