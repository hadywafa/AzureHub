# ‚úçüèª Real Azure Functions examples

> **Scenario:** An **HTTP POST** receives JSON `{ partitionKey, rowKey, name, email }`, writes a row to **Azure Table Storage**, and returns a success message.  
> We‚Äôll do it once in **.NET (isolated, .NET 8)** and once in **Python**. Both include **all folders/files**, runnable locally with **Azurite** (or real Storage).

---

## ‚úÖ Example 1 ‚Äî .NET 8 (Isolated Worker) ‚Äî HTTP ‚Üí Azure Table (via SDK)

### üìÅ Folder Structure

```ini
HttpToTableDotnet/
‚îú‚îÄ host.json
‚îú‚îÄ local.settings.json             # local dev settings (DO NOT COMMIT SECRETS)
‚îú‚îÄ HttpToTableDotnet.csproj
‚îú‚îÄ Program.cs                      # generic host for .NET isolated functions
‚îî‚îÄ Functions/
   ‚îî‚îÄ WebToTable.cs                # the function code (HTTP trigger)
```

### üìÑ `host.json`

```json
{
  "version": "2.0",
  "extensions": {
    "http": {
      "routePrefix": "api"
    }
  }
}
```

### üóùÔ∏è `local.settings.json` (local only)

> Use Azurite locally (`UseDevelopmentStorage=true`) or paste a real connection string.

```json
{
  "IsEncrypted": false,
  "Values": {
    "AzureWebJobsStorage": "UseDevelopmentStorage=true",
    "FUNCTIONS_WORKER_RUNTIME": "dotnet-isolated",
    "WEBSITE_VNET_ROUTE_ALL": "1"
  }
}
```

### üì¶ `HttpToTableDotnet.csproj`

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <AzureFunctionsVersion>v4</AzureFunctionsVersion>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <OutputType>Exe</OutputType>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Azure.Functions.Worker" Version="1.21.0" />
    <PackageReference Include="Microsoft.Azure.Functions.Worker.Extensions.Http" Version="3.1.0" />
    <PackageReference Include="Microsoft.Azure.Functions.Worker.Sdk" Version="1.17.4" OutputItemType="Analyzer" />
    <PackageReference Include="Azure.Data.Tables" Version="12.9.1" />
  </ItemGroup>
</Project>
```

### üß† `Program.cs`

```csharp
using Microsoft.Azure.Functions.Worker;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

var host = new HostBuilder()
    .ConfigureFunctionsWorkerDefaults() // middleware, binding, etc.
    .ConfigureServices(s =>
    {
        s.AddLogging();
    })
    .Build();

host.Run();
```

### ‚ö° `Functions/WebToTable.cs`

```csharp
using System.Net;
using System.Text.Json;
using Azure;
using Azure.Data.Tables;
using Microsoft.Azure.Functions.Worker;
using Microsoft.Azure.Functions.Worker.Http;
using Microsoft.Extensions.Logging;

namespace HttpToTableDotnet.Functions;

public class WebToTable
{
    private readonly ILogger<WebToTable> _logger;

    public WebToTable(ILogger<WebToTable> logger)
    {
        _logger = logger;
    }

    public record UserDto(string partitionKey, string rowKey, string? name, string? email);

    [Function("WebToTable")]
    public async Task<HttpResponseData> Run(
        [HttpTrigger(AuthorizationLevel.Function, "post", Route = "WebToTable")] HttpRequestData req)
    {
        _logger.LogInformation("Processing HTTP request...");

        // Read body
        var body = await new StreamReader(req.Body).ReadToEndAsync();
        var data = JsonSerializer.Deserialize<UserDto>(body, new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true
        });

        var res = req.CreateResponse();

        if (data is null || string.IsNullOrWhiteSpace(data.partitionKey) || string.IsNullOrWhiteSpace(data.rowKey))
        {
            res.StatusCode = HttpStatusCode.BadRequest;
            await res.WriteStringAsync("Please provide partitionKey and rowKey in the JSON body.");
            return res;
        }

        try
        {
            // Storage connection
            var storage = Environment.GetEnvironmentVariable("AzureWebJobsStorage");
            var tableServiceClient = new TableServiceClient(storage);
            var tableClient = tableServiceClient.GetTableClient("UserDetails");

            await tableClient.CreateIfNotExistsAsync();

            var entity = new TableEntity(data.partitionKey, data.rowKey)
            {
                { "Name", data.name ?? string.Empty },
                { "Email", data.email ?? string.Empty }
            };

            await tableClient.AddEntityAsync(entity);

            res.StatusCode = HttpStatusCode.OK;
            await res.WriteStringAsync("Data has been written to Azure Table Storage.");
        }
        catch (RequestFailedException ex)
        {
            _logger.LogError(ex, "Azure Tables error");
            res.StatusCode = HttpStatusCode.InternalServerError;
            await res.WriteStringAsync($"Storage error: {ex.Message}");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unhandled error");
            res.StatusCode = HttpStatusCode.InternalServerError;
            await res.WriteStringAsync("Unhandled server error.");
        }

        return res;
    }
}
```

> ‚ÑπÔ∏è **function.json** is **auto-generated** for .NET isolated from attributes during build. A typical generated file for this function looks like:

```json
{
  "generatedBy": "Microsoft.Azure.Functions.Worker.Sdk",
  "configurationSource": "attributes",
  "bindings": [
    { "type": "httpTrigger", "methods": ["post"], "authLevel": "function", "name": "req", "route": "WebToTable" }
  ],
  "scriptFile": "../bin/HttpToTableDotnet.dll",
  "entryPoint": "HttpToTableDotnet.Functions.WebToTable.Run"
}
```

### ‚ñ∂Ô∏è Run Locally

```bash
# (Install Azure Functions Core Tools + Azurite first)
func start --verbose
```

### üß™ Test

```bash
curl -X POST "http://localhost:7071/api/WebToTable" \
  -H "Content-Type: application/json" \
  -d '{
        "partitionKey": "1",
        "rowKey": "1",
        "name": "John Doe",
        "email": "john@gmail.com"
      }'
```

---

## ‚úÖ Example 2 ‚Äî Python (v1 JSON model) ‚Äî HTTP ‚Üí Azure Table (via SDK)

> Using the classic **function.json** model (very explicit and matches your refs). We‚Äôll use the **Azure Data Tables SDK** in code.

### üìÅ Folder Structure

```ini
HttpToTablePy/
‚îú‚îÄ host.json
‚îú‚îÄ local.settings.json
‚îú‚îÄ requirements.txt
‚îî‚îÄ HttpToTable/                # one function = one folder
   ‚îú‚îÄ __init__.py             # function code
   ‚îî‚îÄ function.json           # trigger & bindings (HTTP in/out)
```

### üìÑ `host.json`

```json
{
  "version": "2.0",
  "extensions": {
    "http": {
      "routePrefix": "api"
    }
  }
}
```

### üóùÔ∏è `local.settings.json` (local only)

```json
{
  "IsEncrypted": false,
  "Values": {
    "FUNCTIONS_WORKER_RUNTIME": "python",
    "AzureWebJobsStorage": "UseDevelopmentStorage=true"
  }
}
```

### üì¶ `requirements.txt`

```txt
azure-functions==1.20.0
azure-data-tables==12.5.0
```

### ‚öôÔ∏è `HttpToTable/function.json`

> Trigger: HTTP POST. Output: HTTP response (we‚Äôll return a string).
> (We handle Table write via SDK in code.)

```json
{
  "bindings": [
    {
      "type": "httpTrigger",
      "direction": "in",
      "authLevel": "function",
      "name": "req",
      "methods": ["post"],
      "route": "WebToTable"
    },
    {
      "type": "http",
      "direction": "out",
      "name": "$return"
    }
  ]
}
```

### üß† `HttpToTable/__init__.py`

```python
import json
import logging
import os

import azure.functions as func
from azure.data.tables import TableServiceClient, TableEntity
from azure.core.exceptions import HttpResponseError

app_logger = logging.getLogger("HttpToTable")

def main(req: func.HttpRequest) -> func.HttpResponse:
    app_logger.info("Processing Python HTTP request...")

    try:
        body = req.get_body()
        data = json.loads(body.decode("utf-8")) if body else {}

        partition_key = (data.get("partitionKey") or "").strip()
        row_key = (data.get("rowKey") or "").strip()
        name = (data.get("name") or "").strip()
        email = (data.get("email") or "").strip()

        if not partition_key or not row_key:
            return func.HttpResponse(
                "Please provide partitionKey and rowKey in the JSON body.",
                status_code=400
            )

        storage_conn = os.environ.get("AzureWebJobsStorage")
        table_service = TableServiceClient.from_connection_string(storage_conn)
        table_client = table_service.get_table_client("UserDetails")

        # Create table if missing
        table_client.create_table_if_not_exists()

        entity = TableEntity()
        entity["PartitionKey"] = partition_key
        entity["RowKey"] = row_key
        entity["Name"] = name
        entity["Email"] = email

        table_client.create_entity(mode="fail", entity=entity)

        return func.HttpResponse(
            "Data has been written to Azure Table Storage.",
            status_code=200
        )

    except HttpResponseError as ex:
        app_logger.exception("Azure Tables error")
        return func.HttpResponse(f"Storage error: {ex.message}", status_code=500)
    except Exception as ex:
        app_logger.exception("Unhandled error")
        return func.HttpResponse("Unhandled server error.", status_code=500)
```

### ‚ñ∂Ô∏è Run Locally

```bash
# from the HttpToTablePy directory
func start --verbose
```

### üß™ Test

```bash
curl -X POST "http://localhost:7071/api/WebToTable" \
  -H "Content-Type: application/json" \
  -d '{
        "partitionKey": "2",
        "rowKey": "2",
        "name": "Mark Doe",
        "email": "mark.doe@example.com"
      }'
```

---

## üõ†Ô∏è Notes & Tips

- **Azurite**: If you don‚Äôt have a real Storage account for local dev, install/run **Azurite** and keep `UseDevelopmentStorage=true` in `local.settings.json`.
- **Table name**: Code uses **`UserDetails`**. You can change it in code.
- **Security**: `local.settings.json` is **not deployed**; for Azure, set **Application Settings** (same keys) on the Function App.
- **Authorization**: Both examples use `AuthorizationLevel.Function` ‚Üí you‚Äôll need the function key when running in Azure. For local, Function Core Tools usually bypass or inject a default key.
