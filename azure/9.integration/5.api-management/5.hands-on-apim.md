# üöÄ Hands-On: Azure Functions behind APIM with Auth, Throttling & Transform

You got it! Here‚Äôs a **end-to-end** project that:

- deploys a **C# Azure Function (HTTP trigger)**
- puts it **behind Azure API Management (APIM)**
- adds **rate limiting**, **JWT validation (Entra ID)**, and a **response transform**
- tests from the **Developer Portal**

Everything is done with Azure CLI + a tiny Function. You can swap languages later if you like.

---

## üìå Prereqs & Variables

**1.Login in terminal:**

```bash
az login --use-device-code
```

**2.Define Variables:**

```bash
# === change these if you like ===
export RG=rg-apim-func-demo
export LOC=eastus
export SA=stapimfunc$RANDOM           # must be globally unique
export PLAN=plan-func-demo
export FUNCAPP=func-apim-demo$RANDOM  # must be globally unique
export APIM=apim-func-demo$RANDOM     # must be globally unique
export API_ID=hello-api
export API_PATH=hello
export OP_ID=get-hello
```

**3.Create resource group:**

```bash
az group create -n $RG -l $LOC -o table
```

---

## üìå 1) Create a Function App (dotnet isolated) + Deploy code

**1.Create storage, plan, function app:**

```bash
az storage account create -g $RG -n $SA -l $LOC --sku Standard_LRS

az functionapp plan create -g $RG -n $PLAN -l $LOC --min-instances 0 --max-burst 10 --sku EP1 --is-linux

az functionapp create \
-g $RG -p $PLAN -n $FUNCAPP \
--runtime dotnet-isolated \
--functions-version 4 \
--storage-account $SA
```

**2.Create a **minimal HTTP trigger** (we‚Äôll zip-deploy). Put these two files in a folder `funcapp/` locally.**

- **funcapp/Program.cs**

  ```csharp
  using Microsoft.Azure.Functions.Worker;
  using Microsoft.Azure.Functions.Worker.Http;
  using Microsoft.Extensions.Hosting;
  using Microsoft.Extensions.DependencyInjection;
  using System.Net;
  using System.Text.Json;

  var host = new HostBuilder()
      .ConfigureFunctionsWorkerDefaults()
      .Build();

  host.Run();

  public class Hello
  {
      [Function("Hello")]
      public static HttpResponseData Run(
          [HttpTrigger(AuthorizationLevel.Function, "get", Route = "hello")] HttpRequestData req)
      {
          var res = req.CreateResponse(HttpStatusCode.OK);
          res.Headers.Add("Content-Type", "application/json");
          var payload = new { message = "Hello from Azure Functions!", ts = DateTime.UtcNow };
          res.WriteString(JsonSerializer.Serialize(payload));
          return res;
      }
  }
  ```

- **funcapp/.funcignore** (keep deployments clean)

  ```ini
  bin
  obj
  local.settings.json
  ```

- Build & package (needs .NET 8 SDK):

  ```bash
  pushd funcapp
  dotnet new tool-manifest
  dotnet tool install Azure.Functions.Tool --version 4.*
  dotnet restore
  dotnet build -c Release
  zip -r ../app.zip . -x "bin/*" -x "obj/*"
  popd
  ```

- Zip deploy:

  ```bash
  az functionapp deployment source config-zip \
  -g $RG -n $FUNCAPP --src ./app.zip
  ```

- Grab the default **function key** (APIM will use it to call backend):

  ```bash
  FUNCNAME=Hello
  FUNC_KEY=$(az functionapp function keys list -g $RG -n $FUNCAPP --function-name $FUNCNAME --query default -o tsv)
  echo "Function key: $FUNC_KEY"
  ```

- Test direct (bypass APIM for now):

  ```bash
  FUNC_BASE=https://$FUNCAPP.azurewebsites.net
  curl -s "$FUNC_BASE/api/hello?code=$FUNC_KEY" | jq .
  ```

---

## üìå 2) Create APIM (Consumption) + a Backend API

**1.Create APIM (serverless, pay-per-call):**

```bash
az apim create \
  -g $RG -n $APIM -l $LOC \
  --publisher-name "Demo" \
  --publisher-email "admin@example.com" \
  --sku Consumption
```

**2.Create a **blank API** in APIM that will forward to your Function:**

```bash
# Create the API shell (no subscription key needed; we‚Äôll use JWT instead)
az apim api create \
  --resource-group $RG \
  --service-name $APIM \
  --api-id $API_ID \
  --display-name "Hello API" \
  --path $API_PATH \
  --protocols https \
  --subscription-required false

# Add one GET operation mapped to /hello
az apim api operation create \
  --resource-group $RG \
  --service-name $APIM \
  --api-id $API_ID \
  --operation-id $OP_ID \
  --display-name "GetHello" \
  --method GET \
  --url-template /hello
```

**We‚Äôll set **policies** on the API to:**

- **call the Function backend**
- pass the **x-functions-key**
- **rate-limit** requests
- later: **validate JWT**
- **transform** the response

---

## üìå 3) Add a Backend Call + Rate Limit + Transform (Policies)

**1.Create a local file `policies.xml`:**

```xml
<policies>
  <inbound>
    <!-- 1) throttling: 10 calls per minute per client IP -->
    <rate-limit-by-key calls="10" renewal-period="60" counter-key="@(context.Request.IpAddress)" />

    <!-- 2) forward to Function backend -->
    <set-backend-service base-url="https://{{FUNCAPP}}.azurewebsites.net" />
    <!-- Add function key -->
    <set-header name="x-functions-key" exists-action="override">
      <value>{{FUNC_KEY}}</value>
    </set-header>

    <rewrite-uri template="/api/hello" />
    <base />
  </inbound>

  <backend>
    <base />
  </backend>

  <outbound>
    <!-- 3) simple response transform: wrap payload -->
    <set-body>
      @{
          var body = context.Response.Body.As<JObject>(preserveContent: true);
          var wrapped = new JObject
          {
              ["ok"] = true,
              ["via"] = "apim",
              ["data"] = body
          };
          return wrapped.ToString();
      }
    </set-body>
    <base />
  </outbound>

  <on-error>
    <base />
  </on-error>
</policies>
```

**2.Replace tokens and upload:**

```bash
sed "s/{{FUNCAPP}}/$FUNCAPP/g; s/{{FUNC_KEY}}/$FUNC_KEY/g" policies.xml > policies-final.xml

az apim api policy update \
  --resource-group $RG \
  --service-name $APIM \
  --api-id $API_ID \
  --xml-file policies-final.xml
```

**3.Get your APIM invoke base URL:**

```bash
APIM_HOST=$(az apim show -g $RG -n $APIM --query gatewayUrl -o tsv)
echo "APIM base: $APIM_HOST/$API_PATH"
curl -s "$APIM_HOST/$API_PATH/hello" | jq .
```

You should see the **wrapped** response (with `ok`, `via`, `data`).

---

## üìå 4) Add **JWT Validation** (Microsoft Entra ID)

**1.Create a **Web app registration** (OIDC) for the **consumer** of your API:**

```bash
TENANT_ID=$(az account show --query tenantId -o tsv)
APP_NAME="APIM Client"
CLIENT_APP_ID=$(az ad app create --display-name "$APP_NAME" --query appId -o tsv)
echo "Client AppId (audience): $CLIENT_APP_ID"
```

> Optionally, Add a Web redirect URI later if you‚Äôll do an actual OAuth code flow. For quick tests, you can use **Graph Explorer** or your own script to fetch a token for `api://CLIENT_APP_ID` if you configure an audience that way; the key point is the **aud** must match what APIM expects.

**2.Update **APIM API policy** to require JWT:**

**3.Create `policies-jwt.xml` (same as before, plus `<validate-jwt>`):**

```xml
<policies>
  <inbound>
    <!-- JWT validation first -->
    <validate-jwt header-name="Authorization" require-scheme="Bearer" failed-validation-httpcode="401" failed-validation-error-message="Unauthorized">
      <openid-config url="https://login.microsoftonline.com/{{TENANT_ID}}/v2.0/.well-known/openid-configuration" />
      <required-claims>
        <claim name="aud" match="any">
          <value>{{CLIENT_APP_ID}}</value>
        </claim>
      </required-claims>
    </validate-jwt>

    <!-- throttling -->
    <rate-limit-by-key calls="10" renewal-period="60" counter-key="@(context.Request.IpAddress)" />

    <!-- backend = Function -->
    <set-backend-service base-url="https://{{FUNCAPP}}.azurewebsites.net" />
    <set-header name="x-functions-key" exists-action="override">
      <value>{{FUNC_KEY}}</value>
    </set-header>
    <rewrite-uri template="/api/hello" />
    <base />
  </inbound>

  <backend>
    <base />
  </backend>

  <outbound>
    <set-body>
      @{
          var body = context.Response.Body.As<JObject>(preserveContent: true);
          var wrapped = new JObject
          {
              ["ok"] = true,
              ["via"] = "apim",
              ["data"] = body
          };
          return wrapped.ToString();
      }
    </set-body>
    <base />
  </outbound>

  <on-error>
    <base />
  </on-error>
</policies>
```

**4.Replace Placeholders with actual variables:**

```bash
sed "s/{{TENANT_ID}}/$TENANT_ID/g; s/{{CLIENT_APP_ID}}/$CLIENT_APP_ID/g; s/{{FUNCAPP}}/$FUNCAPP/g; s/{{FUNC_KEY}}/$FUNC_KEY/g" policies-jwt.xml > policies-jwt-final.xml
```

**5.Apply:**

```bash
az apim api policy update \
  --resource-group $RG \
  --service-name $APIM \
  --api-id $API_ID \
  --xml-file policies-jwt-final.xml
```

> Now requests **must** include a **Bearer token** whose `aud` = your **CLIENT_APP_ID**.

**6.Quick test without token (should be 401):**

```bash
curl -i "$APIM_HOST/$API_PATH/hello"
```

**7.Test **with** token:**

> obtain an access token for the audience you configured (e.g., via your own confidential client code, Postman, or device code sample). Then:

```bash
export TOKEN="eyJhbGciOi..."  # your access token
curl -s -H "Authorization: Bearer $TOKEN" "$APIM_HOST/$API_PATH/hello" | jq .
```

---

## üñºÔ∏è 5) Developer Portal (Try-It UI)

**Turn on the (new) developer portal and test:**

- In Portal: **API Management** ‚Üí your instance ‚Üí **Developer portal** ‚Üí Publish
- Since we set `subscriptionRequired=false`, consumers can call with **JWT only** (no APIM key).
- If you want to require APIM subscription keys **plus** JWT, set `--subscription-required true` on the API and assign products/keys.

---

## üéÅ 6) Extras (quick wins)

- **Caching** at gateway (outbound or inbound)

  ```xml
  <cache-store duration="30" />
  ```

- **Masking headers** or adding CORS

  ```xml
  <set-header name="X-Powered-By" exists-action="delete" />
  <cors allow-credentials="false">
    <allowed-origins>
      <origin>https://yourapp.com</origin>
    </allowed-origins>
    <allowed-methods preflight-result-max-age="300">
      <method>GET</method>
    </allowed-methods>
  </cors>
  ```

- **Rewrite/compose** payloads using Liquid templates or C#-like policy expressions.

---

## üßº 7) Clean up

```bash
az group delete -n $RG -y
```

---

## üß† What you built

- A **Function App** (dotnet isolated) with **HTTP trigger**
- **APIM** front door with:

  - **Function key** forwarding
  - **Rate limiting (10/min per IP)**
  - **JWT validation** (Entra ID; `aud` enforced)
  - **Response transformation** (wrap body)

- **Dev portal** to explore & test
