# ğŸ”„ **Revisions vs. Versions in APIM**

## ğŸ“Œ 1. API **Revisions**

- **Purpose** â†’ _Non-breaking updates_ and _safe rollouts_.
- Think of it like **Git branches for your API definition**: you can edit, test, and roll back without impacting consumers.
- Only **administrators** see revisions; consumers donâ€™t.
- A revision can eventually be **made current** (like merging into `main`).

### ğŸ› ï¸ Example â€“ Revisions

Suppose you already published `Employee API v1`.
Now you want to add a new header requirement without breaking clients.

#### Steps:

1. Go to **API Management â†’ APIs â†’ Select `Employee API`**.
2. Click **Revisions â†’ Add Revision**.

   - Name: `rev2`
   - Description: _Added x-trace-id header requirement_

3. In this revision, update the **Inbound policy**:

   ```xml
   <inbound>
     <base />
     <validate-headers>
       <header name="x-trace-id" />
     </validate-headers>
   </inbound>
   ```

4. Test it using the APIM Test Console.

   - Old revision still works for consumers.
   - You validate new behavior in revision 2.

5. Once ready â†’ click **Make Revision Current**.

   - All clients now use revision 2.

âœ… **Impact**: Consumers didnâ€™t need to change anything.
Revisions = **safe edits, staging, rollback**.

---

## ğŸ“Œ 2. API **Versions**

- **Purpose** â†’ _Breaking changes_ and _API lifecycle management_.
- Exposed to **consumers** with different **endpoints**.
- Each version can have its own **operations, schema, policies**.
- Typically used when you change **contract** (URI, response schema, auth model).

### ğŸ› ï¸ Example â€“ Versions

Suppose you have `Employee API`:

- **v1** â†’ returns salary in **float**.
- **v2** â†’ returns salary in **object** (`{ amount, currency }`).

Thatâ€™s a breaking change, so you need **API versions**.

#### Steps:

1. Go to **API Management â†’ APIs â†’ Add API â†’ Select Version Set**.
2. Create a **Version Set**:

   - Name: `EmployeeAPI`
   - Versioning scheme: **Path-based** (`/v1/`, `/v2/`)

3. Add first API:

   - Name: `Employee API v1`
   - Suffix: `/v1/employee`
   - Backend: `https://backend/api/employee`

4. Add second API:

   - Name: `Employee API v2`
   - Suffix: `/v2/employee`
   - Backend: `https://backend-v2/api/employee`

5. Consumers can now choose:

   - `/v1/employee` â†’ legacy apps.
   - `/v2/employee` â†’ new apps with richer schema.

âœ… **Impact**: Consumers see **both versions** and decide which one to use.
Versions = **breaking changes, coexistence**.

---

## âš–ï¸ **Comparison Table**

| Feature         | **Revisions** ğŸ› ï¸   | **Versions** ğŸš€                     |
| --------------- | ------------------ | ----------------------------------- |
| Visibility      | Admin-only         | Consumer-facing                     |
| Purpose         | Non-breaking edits | Breaking changes                    |
| Endpoint        | Same endpoint      | Different endpoint (`/v1/`, `/v2/`) |
| Lifecycle mgmt  | Staging + rollback | API evolution & coexistence         |
| Consumer Impact | None               | Consumers must pick version         |
| Analogy         | Git branches       | Product releases                    |

---

## ğŸ¯ **When to Use What?**

- **Revisions** â†’ Youâ€™re tweaking headers, rate limits, or minor response details (safe changes).
- **Versions** â†’ Youâ€™re changing schemas, endpoints, or contract in a way that would break old clients.

---

> âœ… In real projects, youâ€™ll often **combine both**:
>
> - Create **revision 2 of v1 API** for minor fixes.
> - Roll out **API v2** with a breaking schema update.
