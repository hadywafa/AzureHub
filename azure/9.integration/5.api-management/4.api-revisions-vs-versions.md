# 🔄 **Revisions vs. Versions in APIM**

## 📌 1. API **Revisions**

- **Purpose** → _Non-breaking updates_ and _safe rollouts_.
- Think of it like **Git branches for your API definition**: you can edit, test, and roll back without impacting consumers.
- Only **administrators** see revisions; consumers don’t.
- A revision can eventually be **made current** (like merging into `main`).

### 🛠️ Example – Revisions

Suppose you already published `Employee API v1`.
Now you want to add a new header requirement without breaking clients.

#### Steps:

1. Go to **API Management → APIs → Select `Employee API`**.
2. Click **Revisions → Add Revision**.

   - Name: `rev2`
   - Description: _Added x-trace-id header requirement_

3. In this revision, update the **Inbound policy**:

   ```xml
   <inbound>
     <base />
     <validate-headers>
       <header name="x-trace-id" />
     </validate-headers>
   </inbound>
   ```

4. Test it using the APIM Test Console.

   - Old revision still works for consumers.
   - You validate new behavior in revision 2.

5. Once ready → click **Make Revision Current**.

   - All clients now use revision 2.

✅ **Impact**: Consumers didn’t need to change anything.
Revisions = **safe edits, staging, rollback**.

---

## 📌 2. API **Versions**

- **Purpose** → _Breaking changes_ and _API lifecycle management_.
- Exposed to **consumers** with different **endpoints**.
- Each version can have its own **operations, schema, policies**.
- Typically used when you change **contract** (URI, response schema, auth model).

### 🛠️ Example – Versions

Suppose you have `Employee API`:

- **v1** → returns salary in **float**.
- **v2** → returns salary in **object** (`{ amount, currency }`).

That’s a breaking change, so you need **API versions**.

#### Steps:

1. Go to **API Management → APIs → Add API → Select Version Set**.
2. Create a **Version Set**:

   - Name: `EmployeeAPI`
   - Versioning scheme: **Path-based** (`/v1/`, `/v2/`)

3. Add first API:

   - Name: `Employee API v1`
   - Suffix: `/v1/employee`
   - Backend: `https://backend/api/employee`

4. Add second API:

   - Name: `Employee API v2`
   - Suffix: `/v2/employee`
   - Backend: `https://backend-v2/api/employee`

5. Consumers can now choose:

   - `/v1/employee` → legacy apps.
   - `/v2/employee` → new apps with richer schema.

✅ **Impact**: Consumers see **both versions** and decide which one to use.
Versions = **breaking changes, coexistence**.

---

## ⚖️ **Comparison Table**

| Feature         | **Revisions** 🛠️   | **Versions** 🚀                     |
| --------------- | ------------------ | ----------------------------------- |
| Visibility      | Admin-only         | Consumer-facing                     |
| Purpose         | Non-breaking edits | Breaking changes                    |
| Endpoint        | Same endpoint      | Different endpoint (`/v1/`, `/v2/`) |
| Lifecycle mgmt  | Staging + rollback | API evolution & coexistence         |
| Consumer Impact | None               | Consumers must pick version         |
| Analogy         | Git branches       | Product releases                    |

---

## 🎯 **When to Use What?**

- **Revisions** → You’re tweaking headers, rate limits, or minor response details (safe changes).
- **Versions** → You’re changing schemas, endpoints, or contract in a way that would break old clients.

---

> ✅ In real projects, you’ll often **combine both**:
>
> - Create **revision 2 of v1 API** for minor fixes.
> - Roll out **API v2** with a breaking schema update.
