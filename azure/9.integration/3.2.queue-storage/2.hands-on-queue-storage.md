# 🚀 **Creating and Managing Azure Queue Storage Queues and Messages with .NET**

Azure Queue Storage is one of the simplest yet most powerful messaging services in Azure. It helps **decouple components**, ensure **asynchronous communication**, and enable **scalable background processing**. In this walkthrough, we’ll explore how to:

1. Set up environment with required NuGet libraries.
2. Create queues programmatically with `.NET SDK`.
3. Add, retrieve, and delete messages.
4. Securely connect via **connection strings** and **Managed Identity (RBAC)**.
5. Deploy a Function App that pushes messages into a queue.
6. Verify using Azure Storage Explorer.

---

## ⚙️ Required Libraries (NuGet Packages)

To work with Azure Queue Storage in .NET, install these packages:

| Package                                     | Purpose                                                           |
| ------------------------------------------- | ----------------------------------------------------------------- |
| `Azure.Core`                                | Shared primitives, abstractions, and helpers.                     |
| `Azure.Storage.Common`                      | Infrastructure for all Azure Storage services.                    |
| `Azure.Storage.Queues`                      | Queue-specific library (create, manage, send/receive messages).   |
| `System.Configuration.ConfigurationManager` | Access `appsettings.json` or `app.config` for connection strings. |

📌 Install via CLI:

```bash
dotnet add package Azure.Core
dotnet add package Azure.Storage.Common
dotnet add package Azure.Storage.Queues
dotnet add package System.Configuration.ConfigurationManager
```

---

## 🏗️ Queue URL Structure

Each queue is part of a **Storage Account** namespace:

```ini
https://<storageAccountName>.queue.core.windows.net/<queueName>
```

Example:

```ini
https://mystorageaccount.queue.core.windows.net/orders
```

✅ `storageAccount` → Root namespace + security boundary.  
✅ `queueName` → Logical container for related messages.

---

## 📥 Creating a Queue with .NET

```csharp
using Azure.Storage.Queues;
using System.Configuration;

string connectionString = ConfigurationManager.AppSettings["StorageConnectionString"];
string queueName = "orders";

// Create queue client
QueueClient queueClient = new QueueClient(connectionString, queueName);

// Create queue if not already exists
queueClient.CreateIfNotExists();

Console.WriteLine($"Queue '{queueName}' ready for use!");
```

🔑 **Key points**:

- `QueueClient` handles all interactions with the queue.
- `CreateIfNotExists` ensures **idempotency** (no duplicate queues).

---

## ✉️ Sending a Message

```csharp
if (queueClient.Exists())
{
    queueClient.SendMessage("OrderID: 1234 | Status: Pending");
    Console.WriteLine("Message added successfully!");
}
```

📌 Notes:

- Messages support **text, JSON, or XML**.
- Max size = **64 KB**. For larger payloads → store in Blob Storage and send reference link.
- Each message can have a **TTL** (default: 7 days).

---

## 📤 Receiving & Deleting Messages

```csharp
var message = queueClient.ReceiveMessage();

if (message != null)
{
    Console.WriteLine($"Processing message: {message.Value.MessageText}");

    // Delete after successful processing
    queueClient.DeleteMessage(message.Value.MessageId, message.Value.PopReceipt);
}
```

⚡ Internals:

- Messages become **invisible** for a visibility timeout (default: 30 sec).
- If not deleted in that time → message becomes visible again.
- This ensures **at-least-once delivery**.

---

## 🔐 Authentication Options

### 1️⃣ **Shared Access Signature (SAS)**

- Token-based temporary URL.
- Useful for clients outside Azure.

### 2️⃣ **Microsoft Identity Platform (Managed Identity + RBAC)**

- Best for Azure-native apps.
- Assign role → `Storage Queue Data Contributor` → to Function App/VM/MSI.
- No secrets, fully managed by Azure AD.

  ```csharp
  using Azure.Identity;
  using Azure.Storage.Queues;

  var credential = new DefaultAzureCredential();
  var queueClient = new QueueClient(
      new Uri("https://mystorageaccount.queue.core.windows.net/orders"),
      credential
  );

  await queueClient.CreateIfNotExistsAsync();
  await queueClient.SendMessageAsync("Order created via MSI");
  ```

### 3️⃣ **Storage Account Keys (Connection String)**

- Simple but less secure.
- Best for **local development/testing**.

---

## 🔄 Function App Example (Managed Identity)

Here’s a **serverless function** that pushes messages to Queue Storage via HTTP POST:

```csharp
public static class QueuePost
{
    private const string queueName = "orders";
    private const string storageAccount = "myaccount";

    [FunctionName("QueuePost")]
    public static async Task<IActionResult> Run(
        [HttpTrigger(AuthorizationLevel.Function, "post", Route = null)] HttpRequest req,
        ILogger log)
    {
        log.LogInformation("Processing POST request...");

        string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
        var credential = new DefaultAzureCredential();
        var queueClient = new QueueClient(
            new Uri($"https://{storageAccount}.queue.core.windows.net/{queueName}"),
            credential);

        await queueClient.CreateIfNotExistsAsync();
        await queueClient.SendMessageAsync(requestBody);

        return new OkObjectResult($"Message added: {requestBody}");
    }
}
```

✅ Advantages:

- No secrets in code.
- Role-based access via Azure AD.
- Highly secure and production-ready.

---

## 🛡️ Configuring RBAC for Function App

1. Go to **Storage Account → Access Control (IAM)**.
2. Add Role Assignment → `Storage Queue Data Contributor`.
3. Select **Managed Identity** of Function App.
4. Deploy the Function → Done 🎉

---

## 🧪 Verification with Storage Explorer

1. Open **Azure Storage Explorer** (or portal).
2. Navigate to your storage account → Queues.
3. Select the `orders` queue.
4. Confirm message presence.

---

## 🔎 Multiple Consumers: Can They Process the Same Message?

👉 **By default, NO.** Azure Queue Storage ensures a **message is locked (invisible)** while a consumer processes it. Only when:

- The consumer **fails to delete it** within the visibility timeout,
- OR **crashes**,

then another consumer can pick it up.

✅ This gives **at-least-once delivery guarantee**.
❌ It does **not support multicast** (like Service Bus Topics). If you need **multiple subscribers processing the same event**, use **Azure Service Bus Topics** or **Event Grid**.

---

## 📊 Summary

- **Azure Queue Storage** → lightweight, scalable message queuing.
- Ideal for **simple background jobs** (e.g., resizing images, order updates).
- Messages: **64 KB max**, **7-day default TTL**, **at-least-once delivery**.
- Security: Choose between **SAS**, **Connection Strings**, and **Managed Identity (RBAC)**.
- For **multicast/subscriber-based patterns** → use **Service Bus Topics** or **Event Grid**.
