# ğŸ”’ **Peek-Lock Model** â€“ Azure Service Bus

## ğŸ§  **What Is It?**

Peek-Lock is a **message retrieval mode** in Azure Service Bus that allows your app to **peek at a message** and **lock it temporarily**, without deleting it immediately. This ensures **reliable processing** and gives you full control over the message lifecycle.

---

## ğŸ§± **Why Use Peek-Lock?**

- Prevents **message loss** if your app crashes or fails mid-processing
- Enables **retry logic** and **dead-lettering** for unprocessable messages
- Supports **transactional workflows** and **safe integration** with external systems

---

## ğŸ” **Lifecycle Overview**

1. **Receive with Peek-Lock**  
   Your app requests a message using `ReceiveMode.PeekLock`.  
   â†’ Service Bus returns the message and locks it for a short duration (default: 30 seconds).

2. **Process the Message**  
   Your app performs business logic (e.g., API call, DB write).

3. **Respond with One of Three Actions**:

   - âœ… `completeMessage()` â†’ Message is deleted permanently.
   - âŒ `abandonMessage()` â†’ Lock is released, message becomes visible again.
   - â˜ ï¸ `deadLetterMessage()` â†’ Message is moved to the Dead-Letter Queue.

4. **If No Response**  
   â†’ Lock expires.  
   â†’ Message becomes visible again.  
   â†’ Service Bus retries delivery until `MaxDeliveryCount` is reached.  
   â†’ Then itâ€™s auto-dead-lettered.

---

## ğŸ” **Key Properties**

| Property             | Description                                     |
| -------------------- | ----------------------------------------------- |
| **LockDuration**     | Time the message stays locked (default: 30s)    |
| **MaxDeliveryCount** | Number of retries before DLQ (default: 10)      |
| **DeliveryCount**    | Tracks how many times the message was delivered |
| **DeadLetterQueue**  | Special sub-queue for failed messages           |

---

## ğŸ§  **Developer Insight**

Peek-Lock is ideal when:

- You need **guaranteed delivery**
- Youâ€™re calling **external APIs**
- You want to **inspect failed messages**
- Youâ€™re building **custom retry logic**

Itâ€™s the backbone of **robust, fault-tolerant messaging systems**.

---

## ğŸ“Š **Sequence Diagram** â€“ Full Peek-Lock Lifecycle

<div align="center" style="background-color: #1d6c76be ;border-radius: 10px;border: 2px solid white">

```mermaid
sequenceDiagram
    participant ClientApp as ğŸ‘¨â€ğŸ’» Client Application
    participant SBQueue as ğŸ“¬ Azure Service Bus Queue
    participant CustomApp as ğŸ› ï¸ Custom Receiver App
    participant DLQ as â˜ ï¸ Dead-Letter Queue

    %% Step 1: Client sends message
    ClientApp->>SBQueue: ğŸ“¤ Send message via AMQP/HTTP

    %% Step 2: Receiver fetches message (PeekLock)
    CustomApp->>SBQueue: ğŸ” Receive message (PeekLock)
    SBQueue-->>CustomApp: ğŸ”’ Return locked message with lock token

    alt âœ… Receiver completes message
    rect rgba(33, 75, 45, 1)
        CustomApp->>SBQueue: âœ… completeMessage()
        SBQueue-->>SBQueue: ğŸ§¾ Message deleted
    end
    else âŒ Receiver abandons message
    rect rgba(113, 111, 28, 1)
        CustomApp->>SBQueue: âŒ abandonMessage()
        SBQueue-->>SBQueue: ğŸ” Message becomes visible again
    end
    else â˜ ï¸ Receiver dead-letters message
    rect rgba(162, 79, 79, 1)
        CustomApp->>SBQueue: â˜ ï¸ deadLetterMessage()
        SBQueue->>DLQ: ğŸ“¦ Move to Dead-Letter Queue
    end
    else ğŸš« No response (crash, timeout, bug)
    rect rgba(30, 27, 27, 1)
        SBQueue-->>SBQueue: â±ï¸ Lock expires
        SBQueue-->>SBQueue: ğŸ” Message becomes visible again
        loop Retry until MaxDeliveryCount
            Note over SBQueue,CustomApp: If receiver still alive with long polling
            SBQueue->>CustomApp: ğŸ” Redeliver message
            SBQueue-->>CustomApp: ğŸ”’ Lock again
            Note over CustomApp: âŒ Still no response
            SBQueue-->>SBQueue: â±ï¸ Lock expires
            SBQueue-->>SBQueue: ğŸ” Message becomes visible again
        end
        SBQueue->>DLQ: â˜ ï¸ Move to Dead-Letter Queue
    end
    end
```

</div>

---

## ğŸ§  **Peak-Lock Model Methods**

Service Bus SDK Provide three Methods for handling Peak-Lock Model

| Case               | Trigger               | Result                          |
| ------------------ | --------------------- | ------------------------------- |
| âœ… **Complete**    | `completeMessage()`   | Message deleted from queue      |
| âŒ **Abandon**     | `abandonMessage()`    | Message retried (visible again) |
| â˜ ï¸ **Dead-letter** | `deadLetterMessage()` | Message moved to DLQ            |

---

## â“ 1. What does **abandon** mean in Peek-Lock?

**Abandoning a message** does **not** extend the lock time. Instead, it means:

- You **couldnâ€™t process** the message (e.g., validation failed, transient error).
- You call `abandonMessage()` to **release the lock**.
- The message becomes **visible again** to **any receiver**, not just you.
- It **does not count as a successful delivery**, but it **does increment the delivery count**.

So yesâ€”abandon means â€œI couldnâ€™t process this, let someone else try.â€

---

## â“ 2. Why SDK Includes `abandon()` and `deadLetter()` Methods

Brilliant insight, Hady. You're absolutely right to ask: if retry and DLQ are part of Service Bus behavior, why does the SDK expose `abandonMessage()` and `deadLetterMessage()` methods?

Letâ€™s break it down clearly:

### ğŸ”¹ **Control Is Shared Between You and Service Bus**

Service Bus handles **automatic retry and DLQ** when your app fails silently (e.g., lock expires).  
But the SDK gives you **explicit control** to:

- **Abandon** a message early if you know it can't be processed now
- **Dead-letter** a message intentionally if it's invalid or poisoned

This lets you **signal intent** rather than waiting for timeouts or max retries.

---

### ğŸ”¹ **Abandon Is a Developer Shortcut**

Instead of letting the lock expire, you can:

- Call `abandonMessage()` to **release the lock immediately**
- This makes the message **available for retry faster**
- Saves time and avoids unnecessary lock duration

Think of it as saying: â€œIâ€™ve checked this message, and Iâ€™m done with itâ€”for now.â€

---

### ğŸ”¹ **Dead-letter Is a Safety Valve**

Sometimes you know a message is **bad**:

- Invalid schema
- Missing required fields
- Business rule violation

Rather than retrying it 10 times, you can:

- Call `deadLetterMessage()` directly
- Move it to DLQ for inspection or manual handling

This avoids clogging the queue with unprocessable messages.

---

### ğŸ”¹ **Service Bus Handles the Rest**

If you donâ€™t call `complete()`, `abandon()`, or `deadLetter()`:

- Service Bus will retry automatically
- After `MaxDeliveryCount`, it will DLQ the message

So the SDK gives you **manual override**, but Service Bus ensures **fallback safety**.

## â“ 3. Why does Service Bus redeliver after â±ï¸ lock expires if it's poll-based?

You're absolutely right: **Service Bus is pull-based**, not push. But here's the nuance:

### ğŸ”¹ What happens when lock expires:

- The message becomes **visible again** in the queue.
- **No automatic push** happens.
- But if your app is running a **message pump** or **polling loop**, it will **receive the message again** on the next pull.

### ğŸ”¹ Redelivery is passive:

- Service Bus doesnâ€™t pushâ€”it just **makes the message available**.
- Your app (or another receiver) **asks for messages**, and Service Bus includes it in the response.
- This is why **retry happens**: the message is still in the queue, and your app keeps polling.

### ğŸ§  Analogy:

Think of Service Bus like a shelf:

- You take an item off the shelf (PeekLock).
- If you donâ€™t finish with it, it goes back on the shelf (lock expires).
- Anyone who walks by and looks (polls) can pick it up again.
