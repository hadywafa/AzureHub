# 🛠 Mini Hands-On Project: Azure Service Bus with .NET SDK

Let’s build a **mini .NET console project** that demonstrates the **full Azure Service Bus workflow**:

- Create a **queue client**
- **Send** single + batch messages
- **Receive** with both _pull_ and _processor_
- Handle **dead-letter scenarios**
- Show **scaling with concurrency**

---

## 1. 📦 Project Setup

```bash
dotnet new console -n ServiceBusDemo
cd ServiceBusDemo
dotnet add package Azure.Messaging.ServiceBus
```

---

## 2. 🔑 Configurations

Add a config file `appsettings.json`:

```json
{
  "ServiceBus": {
    "ConnectionString": "<YOUR_CONNECTION_STRING>",
    "QueueName": "demo-queue"
  }
}
```

---

## 3. 🏗 Project Structure

```ini
ServiceBusDemo/
 ├── Program.cs
 ├── appsettings.json
 ├── Sender.cs
 ├── Receiver.cs
 ├── Processor.cs
```

---

## 4. ✉️ Sender

`Sender.cs`

```csharp
using Azure.Messaging.ServiceBus;

public class Sender
{
    private readonly ServiceBusClient _client;
    private readonly ServiceBusSender _sender;

    public Sender(string connectionString, string queueName)
    {
        _client = new ServiceBusClient(connectionString);
        _sender = _client.CreateSender(queueName);
    }

    public async Task SendSingleMessage(string content)
    {
        var message = new ServiceBusMessage(content)
        {
            MessageId = Guid.NewGuid().ToString(),
            ApplicationProperties = { ["Type"] = "Single" }
        };
        await _sender.SendMessageAsync(message);
        Console.WriteLine($"✅ Sent: {content}");
    }

    public async Task SendBatchMessages(IEnumerable<string> contents)
    {
        using var batch = await _sender.CreateMessageBatchAsync();
        foreach (var content in contents)
        {
            if (!batch.TryAddMessage(new ServiceBusMessage(content)))
                throw new Exception($"Message too large: {content}");
        }
        await _sender.SendMessagesAsync(batch);
        Console.WriteLine($"✅ Sent batch of {contents.Count()} messages.");
    }
}
```

---

## 5. 📬 Receiver (Pull Mode)

`Receiver.cs`

```csharp
using Azure.Messaging.ServiceBus;

public class Receiver
{
    private readonly ServiceBusReceiver _receiver;

    public Receiver(string connectionString, string queueName)
    {
        var client = new ServiceBusClient(connectionString);
        _receiver = client.CreateReceiver(queueName);
    }

    public async Task ReceiveMessages(int maxMessages = 3)
    {
        var messages = await _receiver.ReceiveMessagesAsync(maxMessages);
        foreach (var msg in messages)
        {
            Console.WriteLine($"📥 Received: {msg.Body}");
            await _receiver.CompleteMessageAsync(msg); // ACK
        }
    }
}
```

---

## 6. ⚡ Processor (Event-Driven)

`Processor.cs`

```csharp
using Azure.Messaging.ServiceBus;

public class Processor
{
    private readonly ServiceBusProcessor _processor;

    public Processor(string connectionString, string queueName)
    {
        var client = new ServiceBusClient(connectionString);
        _processor = client.CreateProcessor(queueName, new ServiceBusProcessorOptions
        {
            MaxConcurrentCalls = 5,
            AutoCompleteMessages = false
        });
    }

    public async Task Start()
    {
        _processor.ProcessMessageAsync += async args =>
        {
            string body = args.Message.Body.ToString();
            Console.WriteLine($"⚡ Processing: {body}");
            await args.CompleteMessageAsync(args.Message);
        };

        _processor.ProcessErrorAsync += async args =>
        {
            Console.WriteLine($"❌ Error: {args.Exception.Message}");
        };

        await _processor.StartProcessingAsync();
        Console.WriteLine("🔄 Processor started. Press Enter to stop...");
        Console.ReadLine();
        await _processor.StopProcessingAsync();
    }
}
```

---

## 7. 🖥 Program.cs (Runner)

```csharp
using Microsoft.Extensions.Configuration;

// Load config
var config = new ConfigurationBuilder()
    .AddJsonFile("appsettings.json")
    .Build();

string connStr = config["ServiceBus:ConnectionString"];
string queue = config["ServiceBus:QueueName"];

// Initialize classes
var sender = new Sender(connStr, queue);
var receiver = new Receiver(connStr, queue);
var processor = new Processor(connStr, queue);

// 1. Send single message
await sender.SendSingleMessage("Hello from Service Bus!");

// 2. Send batch messages
await sender.SendBatchMessages(new[] { "Msg1", "Msg2", "Msg3" });

// 3. Receive manually
await receiver.ReceiveMessages();

// 4. Processor demo (event-driven)
await processor.Start();

// 1. Send single message
await sender.SendSingleMessage("Hello again from Service Bus!");

// 2. Send batch messages
await sender.SendBatchMessages(new[] { "Msg4", "Msg5", "Msg6" });
```

---

## 8. 🧪 Expected Output

```ini
✅ Sent: Hello from Service Bus!
✅ Sent batch of 3 messages.
📥 Received: Hello from Service Bus!
📥 Received: Msg1
📥 Received: Msg2
📥 Received: Msg3
🔄 Processor started. Press Enter to stop...
⚡ Processing: Hello again from Service Bus!
⚡ Processing: Msg4
⚡ Processing: Msg5
⚡ Processing: Msg6
```

---

## 9. 🚀 Extensions

- Add **Dead Letter Queue** handling (`receiver.ReceiveDeferredMessageAsync`)
- Enable **Sessions** for FIFO ordering (`client.AcceptNextSessionAsync`)
- Use **Topics & Subscriptions** for Pub/Sub

---

👉 This mini-project gives you a **complete, working demo** of Service Bus in .NET: send, receive, processor, scaling concurrency.

Would you like me to **extend this project to include Topics + Subscriptions** (Pub/Sub) as the next step?
