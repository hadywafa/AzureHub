# 📨 Azure Service Bus — .NET SDK Deep Dive

Azure Service Bus is a **fully managed enterprise message broker**. With the .NET SDK (`Azure.Messaging.ServiceBus`), you can send, receive, and manage messages programmatically.

---

## 1. ⚙️ Packages & Namespaces

Add the official package:

```bash
dotnet add package Azure.Messaging.ServiceBus
```

Namespaces:

```csharp
using Azure.Messaging.ServiceBus;
```

---

## 2. 🔑 Core Classes

### 🔹 `ServiceBusClient`

- **Purpose**: Entry point to connect.
- **How**: Create with a connection string or `DefaultAzureCredential`.

```csharp
var client = new ServiceBusClient("<connection-string>");
```

---

### 🔹 `ServiceBusSender`

- **Purpose**: Send messages to a queue or topic.
- **Factory**: Created via `client.CreateSender("queueName")`.
- **Key methods**:

  - `SendMessageAsync(ServiceBusMessage message)`
  - `SendMessagesAsync(IEnumerable<ServiceBusMessage> messages)`

---

### 🔹 `ServiceBusReceiver`

- **Purpose**: Receive messages from a queue or subscription.
- **Factory**: `client.CreateReceiver("queueName")`
- **Key methods**:

  - `ReceiveMessageAsync()`
  - `ReceiveMessagesAsync(int maxMessages)`
  - `CompleteMessageAsync(message)` → remove from queue
  - `AbandonMessageAsync(message)` → release, available again
  - `DeadLetterMessageAsync(message)` → send to DLQ

---

### 🔹 `ServiceBusProcessor`

- **Purpose**: Event-driven receiver with background processing (auto-pull + handler).
- **Factory**: `client.CreateProcessor("queueName")`
- **Events**:

  - `ProcessMessageAsync` → when a message arrives
  - `ProcessErrorAsync` → when error occurs

- **Methods**:

  - `StartProcessingAsync()`
  - `StopProcessingAsync()`

---

### 🔹 `ServiceBusMessage`

- **Purpose**: Represents a message.
- **Props**:

  - `Body` → content (`BinaryData`)
  - `MessageId`, `CorrelationId`, `ReplyTo`
  - `ApplicationProperties` → custom metadata

---

## 3. ✨ Hands-On Examples

### 3.1. Send a Single Message

```csharp
var client = new ServiceBusClient("<connection-string>");
var sender = client.CreateSender("orders");

var message = new ServiceBusMessage("Order: #12345")
{
    MessageId = Guid.NewGuid().ToString(),
    ApplicationProperties = { ["Priority"] = "High" }
};

await sender.SendMessageAsync(message);
Console.WriteLine("Message sent!");
```

---

### 3.2. Send Batch

```csharp
var sender = client.CreateSender("orders");
using ServiceBusMessageBatch batch = await sender.CreateMessageBatchAsync();

batch.TryAddMessage(new ServiceBusMessage("Order #1001"));
batch.TryAddMessage(new ServiceBusMessage("Order #1002"));

await sender.SendMessagesAsync(batch);
Console.WriteLine("Batch sent!");
```

---

### 3.3. Receive Messages (Pull Mode)

```csharp
var receiver = client.CreateReceiver("orders");

ServiceBusReceivedMessage message = await receiver.ReceiveMessageAsync();
if (message != null)
{
    Console.WriteLine($"Received: {message.Body.ToString()}");
    await receiver.CompleteMessageAsync(message); // ACK
}
```

---

### 3.4. Processor (Push-Like, Event Driven)

```csharp
var processor = client.CreateProcessor("orders");

processor.ProcessMessageAsync += async args =>
{
    string body = args.Message.Body.ToString();
    Console.WriteLine($"Processing: {body}");
    await args.CompleteMessageAsync(args.Message);
};

processor.ProcessErrorAsync += async args =>
{
    Console.WriteLine($"Error: {args.Exception.Message}");
};

await processor.StartProcessingAsync();
Console.ReadKey(); // press key to stop
await processor.StopProcessingAsync();
```

---

### 3.5. Topic + Subscription

Producer:

```csharp
var sender = client.CreateSender("salesTopic");
await sender.SendMessageAsync(new ServiceBusMessage("Sale: $250"));
```

Consumer:

```csharp
var receiver = client.CreateReceiver("salesTopic", "subscribersEU");
ServiceBusReceivedMessage msg = await receiver.ReceiveMessageAsync();
Console.WriteLine(msg.Body.ToString());
await receiver.CompleteMessageAsync(msg);
```

---

## 4. 🔄 Common Patterns

- **Queue (Point-to-Point)**: Sender → Queue → One Consumer
- **Topic/Subscription (Pub/Sub)**: Sender → Topic → Multiple Subscriptions (multicast)
- **Sessions**: FIFO ordering with `SessionId`
- **DLQ (Dead Letter Queue)**: for poison/unprocessed messages

---

## 5. 📊 Scaling & Reliability

- **Scale-out receivers**: multiple processors → concurrency.
- **Prefetch**: speeds up by pulling multiple messages at once.
- **Auto-lock renewal**: prevents message lock expiration during long processing.
- **HA**: Service Bus is zone-redundant by design.

---

## 6. 🧠 Memorize Like This

- **Client** → the bus driver 🚍
- **Sender** → posts the letter ✉️
- **Receiver** → opens the letter 📬
- **Processor** → auto butler 🤵 handling letters for you
- **Message** → the envelope 📦 with ID, headers, and body
