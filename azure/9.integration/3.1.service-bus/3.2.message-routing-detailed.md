# ðŸ”ž Azure Service Bus â€“ Routing & Correlation Patterns

You can mix and match these patterns using a few **core primitives** in the modern SDK (`Azure.Messaging.ServiceBus`):

- **Queue / Topic + Subscriptions**
- **Message properties**: `MessageId`, `CorrelationId`, `SessionId`, `ReplyTo`, `ReplyToSessionId`, `ApplicationProperties`
- **Sessions** (stateful, FIFO sub-streams)
- **Subscription rules/filters** (SQL or Correlation filters)

Below Iâ€™ll explain each pattern the way youâ€™d actually build it today, show the **sequence**, and give **ready-to-drop .NET code** you can adapt.

---

## 1ï¸âƒ£ Simple Request/Reply ðŸ“¨âž¡ï¸ðŸ“¨

**When**: You need a direct answer (e.g., â€œWhatâ€™s the current inventory for SKU X?â€).  
**How**: Sender puts `CorrelationId` and `ReplyTo` on the message. Responder replies to `ReplyTo` using the **same** `CorrelationId`.

### Sequence (Queue-based)

```mermaid
sequenceDiagram
  autonumber
  actor Client
  participant ReqQueue as ðŸ“¬ requests queue
  participant InvSvc as âš™ï¸ Inventory Service
  participant ReplyQueue as ðŸ“¬ replies queue

  Client->>ReqQueue: Send(request) [CorrelationId=R1, ReplyTo=replies]
  ReqQueue-->>InvSvc: Receive(request)
  InvSvc->>ReplyQueue: Send(reply) [CorrelationId=R1]
  ReplyQueue-->>Client: Receive(reply where CorrelationId=R1)
```

### Key points

- `CorrelationId` ties request â‡„ reply.
- `ReplyTo` tells the service **where** to answer.
- For concurrency, use a **separate reply queue per caller** or a **shared reply queue** and filter by `CorrelationId`.

### .NET (modern SDK) â€“ requester & responder

```csharp
// Requester
var client = new ServiceBusClient(connStr);
var sender = client.CreateSender("requests");
var replyReceiver = client.CreateReceiver("replies"); // shared reply queue

var correlationId = Guid.NewGuid().ToString();
var msg = new ServiceBusMessage(BinaryData.FromString("{\"sku\":\"ABC-123\"}"))
{
    CorrelationId = correlationId,
    ReplyTo = "replies"
};

await sender.SendMessageAsync(msg);

// Wait for the reply that matches our CorrelationId
var reply = await replyReceiver.ReceiveMessageAsync(TimeSpan.FromSeconds(10));
while (reply != null && reply.CorrelationId != correlationId)
{
    await replyReceiver.DeadLetterMessageAsync(reply, "NoMatch", "Not our reply");
    reply = await replyReceiver.ReceiveMessageAsync(TimeSpan.FromSeconds(10));
}

// Responder
var processor = client.CreateProcessor("requests");
processor.ProcessMessageAsync += async args =>
{
    var req = args.Message;
    var inv = new { sku = "ABC-123", quantity = 42 }; // pretend lookup
    var reply = new ServiceBusMessage(BinaryData.FromObjectAsJson(inv))
    {
        CorrelationId = req.CorrelationId
    };
    var replySender = client.CreateSender(req.ReplyTo);
    await replySender.SendMessageAsync(reply);
    await args.CompleteMessageAsync(req);
};
processor.ProcessErrorAsync += e => Task.CompletedTask;
await processor.StartProcessingAsync();
```

> Tip: Instead of dead-lettering non-matching replies, itâ€™s cleaner to **peek-lock and defer** or use **sessions** (next patterns) to avoid cross-talk entirely.

---

## 2ï¸âƒ£ Multicast Request/Reply ðŸ“£âž¡ï¸ðŸ‘‚ðŸ‘‚ðŸ‘‚

**When**: One request fan-outs to multiple services that each produce a response (e.g., â€œrecalculate priceâ€ across tax, discount, shipping services).  
**How**: Publish request to a **Topic**. Each subscriber processes and sends a reply (same `CorrelationId`) to a shared **reply queue**. The caller **aggregates** N replies or times out.

### Sequence (Topic + N replies)

```mermaid
sequenceDiagram
  autonumber
  actor Client
  participant Topic as ðŸ“” requests topic
  participant SubA as ðŸ‘‚ SubA (Tax)
  participant SubB as ðŸ‘‚ SubB (Discount)
  participant SubC as ðŸ‘‚ SubC (Shipping)
  participant ReplyQ as ðŸ“¬ replies queue

  Client->>Topic: Send(request) [CorrelationId=R2, ReplyTo=replies]
  Topic-->>SubA: Request delivered
  Topic-->>SubB: Request delivered
  Topic-->>SubC: Request delivered
  SubA->>ReplyQ: reply_A [CorrelationId=R2]
  SubB->>ReplyQ: reply_B [CorrelationId=R2]
  SubC->>ReplyQ: reply_C [CorrelationId=R2]
  ReplyQ-->>Client: Collect replies where CorrelationId=R2 (until N or timeout)
```

### Key points

- Use **subscription filters** if only some services should receive certain kinds of requests.
- Aggregator can stop after **expected count** or **timeout**.
- Include `ApplicationProperties["source"]="Tax"` etc. to identify responders.

### .NET â€“ publisher, subscriber, aggregator sketch

```csharp
// Publisher (client)
var correlationId = Guid.NewGuid().ToString();
await topicSender.SendMessageAsync(new ServiceBusMessage(BinaryData.FromString("{}"))
{
    CorrelationId = correlationId,
    ReplyTo = "replies"
});

// Subscriber (e.g., Discount)
processor.ProcessMessageAsync += async args =>
{
    var req = args.Message;
    var result = new { discount = 0.1 };
    var reply = new ServiceBusMessage(BinaryData.FromObjectAsJson(result))
    {
        CorrelationId = req.CorrelationId
    };
    reply.ApplicationProperties["source"] = "discount";
    await client.CreateSender(req.ReplyTo).SendMessageAsync(reply);
    await args.CompleteMessageAsync(req);
};

// Aggregator (client) collects multiple replies
var replies = new List<ServiceBusReceivedMessage>();
var deadline = DateTime.UtcNow.AddSeconds(5);
while (DateTime.UtcNow < deadline)
{
    var m = await replyReceiver.ReceiveMessageAsync(TimeSpan.FromMilliseconds(500));
    if (m == null) continue;
    if (m.CorrelationId == correlationId)
    {
        replies.Add(m);
        await replyReceiver.CompleteMessageAsync(m);
        if (replies.Count == expectedCount) break;
    }
    else
    {
        await replyReceiver.AbandonMessageAsync(m); // or defer
    }
}
```

---

## 3ï¸âƒ£ Multiplexing ðŸ”€ (multiple streams through one entity)

**When**: You want one queue/subscription to carry **many independent streams** (e.g., order events + shipping events), but keep **per-stream ordering** and isolation.  
**How**: Use **sessions**. Set `SessionId` to the **stream key** (e.g., `order-123`), and process with a **Session Processor**. Each session is an independent FIFO lane.

### Sequence (single queue, many sessions)

```mermaid
sequenceDiagram
  autonumber
  participant Q as Queue (sessions-enabled)
  participant Proc as Session Processor

  Q->>Proc: Lock SessionId=order-123
  Proc->>Proc: Process events for order-123 in order
  Proc->>Q: Complete messages, release session
  Q->>Proc: Lock SessionId=ship-789
  Proc->>Proc: Process events for ship-789 in order
```

### Key points

- **Enable sessions** on the queue/subscription.
- Set `SessionId` per logical stream.
- A pool of processors can scale horizontally; each session is handled by exactly one processor at a time.

### .NET â€“ producer & session processor

```csharp
// Producer: two different streams into the same queue
await sender.SendMessageAsync(new ServiceBusMessage("order-created") { SessionId = "order-123" });
await sender.SendMessageAsync(new ServiceBusMessage("label-printed") { SessionId = "ship-789" });

// Session-aware processor
var sessionProcessor = client.CreateSessionProcessor("multiplexed-queue", new ServiceBusSessionProcessorOptions
{
    AutoCompleteMessages = false,
    MaxConcurrentSessions = 16,
    MaxConcurrentCallsPerSession = 1
});

sessionProcessor.ProcessMessageAsync += async args =>
{
    var body = args.Message.Body.ToString();
    var sid = args.Message.SessionId; // which stream
    // route in code if needed: args.Message.ApplicationProperties["type"]
    await args.CompleteMessageAsync(args.Message);
};
sessionProcessor.ProcessErrorAsync += e => Task.CompletedTask;
await sessionProcessor.StartProcessingAsync();
```

> Bonus: On **topics**, you can also multiplex via **subscription rules** (`CorrelationFilter`, `SqlRuleFilter`) and keep one **consumer** that branches on `ApplicationProperties["type"]`.

---

## 4ï¸âƒ£ Multiplexed Request/Reply ðŸ§µðŸ§µ âŸ· ðŸ§µðŸ§µ (many replies per request, per stream)

**When**: One request leads to a **multi-step workflow** where **several replies** belong to the **same conversation**, and youâ€™re running many conversations in parallel.
**How**: Combine **Request/Reply** with **Sessions**:

- The original request carries a `SessionId` (conversation key) and `ReplyTo` (a **sessions-enabled** reply queue).
- Downstream steps send **multiple replies** to `ReplyTo` with `ReplyToSessionId` (or set their **message** `SessionId` to the same key when publishing to the reply queue).
- The caller reads **only its session** on the reply queue, getting FIFO multi-replies for that conversation.

### Sequence

```mermaid
sequenceDiagram
  autonumber
  actor Client
  participant ReqQ as ðŸ“¬ requests Queue (sessions)
  participant Orchestrators as âš™ï¸ Step Services
  participant RepQ as ðŸ“¬ replies Queue (sessions)

  Client->>ReqQ: Send(Request) [SessionId=S42, ReplyTo=replies]
  ReqQ-->>Orchestrators: Receive S42 request, start workflow
  Orchestrators->>RepQ: Send(Reply1) [SessionId=S42]
  Orchestrators->>RepQ: Send(Reply2) [SessionId=S42]
  Orchestrators->>RepQ: Send(Reply3) [SessionId=S42]
  RepQ-->>Client: SessionReceiver(S42) reads replies 1..n in order
```

### .NET â€“ requester + multi-step responders + session-based aggregator

```csharp
// Requester: open a unique conversation session id
var sessionId = $"conv-{Guid.NewGuid()}";
await reqSender.SendMessageAsync(new ServiceBusMessage("start-workflow")
{
    SessionId = sessionId,
    ReplyTo = "replies-sessions" // sessions-enabled
});

// Responder steps: publish multiple replies into the same reply session
var stepReply1 = new ServiceBusMessage("step-1-done") { SessionId = sessionId };
await client.CreateSender("replies-sessions").SendMessageAsync(stepReply1);
// ... later ...
var stepReply2 = new ServiceBusMessage("step-2-done") { SessionId = sessionId };
await client.CreateSender("replies-sessions").SendMessageAsync(stepReply2);

// Aggregator: read ONLY this conversationâ€™s stream
var sessionReceiver = await client.AcceptSessionAsync("replies-sessions", sessionId);
var replies = new List<string>();
while (true)
{
    var m = await sessionReceiver.ReceiveMessageAsync(TimeSpan.FromSeconds(2));
    if (m == null) break; // timeout boundary between steps
    replies.Add(m.Body.ToString());
    await sessionReceiver.CompleteMessageAsync(m);
}
// replies now holds all (ordered) replies for S42
```

> Why this rocks: You avoid reply cross-talk entirely and get **clean FIFO** per conversation, even with many concurrent conversations.

---

## ðŸ¤” When to use which? (fast mental model)

- **Simple Request/Reply**: one service answers once, low fan-out, no workflow.
- **Multicast Request/Reply**: one request, **many** responders, caller aggregates results.
- **Multiplexing**: many independent **streams** through one entity, maintain ordering with **sessions**.
- **Multiplexed Request/Reply**: conversations that emit **multiple replies** over time; isolate with **sessions** end-to-end.

---

## âœ… Practical tips & gotchas

- **Set timeouts** and **max expected replies** on aggregators to prevent hangs.
- Prefer **sessions** whenever you need per-conversation ordering or isolation.
- On topics, use **Correlation/SQL filters** to reduce subscriber noise (e.g., `type = 'order'`).
- For resilience, enable **dead-lettering** on expired replies; add `MessageId` to dedupe.
- Scale: increase `MaxConcurrentSessions` and run multiple processors; SB will fairly distribute sessions.
- Security: use **SAS** or **Managed Identity**; scope per-entity rights tightly.
