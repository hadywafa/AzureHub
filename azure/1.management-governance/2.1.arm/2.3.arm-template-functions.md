# ⚙️ Functions in ARM Templates

ARM templates support a wide range of **functions** that allow you to create **dynamic, reusable, and parameterized deployments**. Functions can be used within parameters, variables, resource definitions, and outputs to compute values at runtime.

---

## 🔹 Why Functions Matter

- Make templates **dynamic** → e.g., generate unique names, IDs, or URIs.
- Reduce duplication by computing values instead of hardcoding.
- Enable **conditional logic** for multi-environment deployments.
- Simplify **string, numeric, and array manipulations**.

---

## 🔹 Categories of ARM Functions

Functions fall into major groups:

### 1. **String Functions**

Manipulate text values.

- `concat()` → Joins multiple strings.
- `toLower()` / `toUpper()` → Changes case.
- `substring(string, startIndex, length)` → Extracts a substring.
- `length(string)` → Returns length of string.
- `replace(original, old, new)` → Replaces substring.
- `format(formatString, arg1, arg2, …)` → Formats values.

📌 Example:

```json
"variables": {
  "resourceName": "[toLower(concat('stg', uniqueString(resourceGroup().id)))]"
}
```

---

### 2. **Numeric Functions**

Perform calculations.

- `add(a, b)` → Adds two numbers.
- `sub(a, b)` → Subtracts.
- `mul(a, b)` → Multiplies.
- `div(a, b)` → Divides (integer division).
- `mod(a, b)` → Remainder after division.
- `min(a, b)` / `max(a, b)` → Minimum or maximum value.

📌 Example:

```json
"variables": {
  "vmCount": "[add(parameters('baseVmCount'), 2)]"
}
```

---

### 3. **Array & Object Functions**

Work with collections.

- `array(value)` → Converts to array.
- `first(array)` / `last(array)` → Gets first or last element.
- `union(array1, array2)` → Combines arrays.
- `intersection(a1, a2)` → Returns common values.
- `length(array)` → Number of elements.
- `contains(array, value)` → Checks existence.
- `json(string)` → Converts string to JSON object.

📌 Example:

```json
"variables": {
  "vmSizes": ["Standard_B2s", "Standard_D4s_v3"],
  "chosenVm": "[variables('vmSizes')[0]]"
}
```

---

### 4. **Comparison & Logical Functions**

Add conditions and decisions.

- `equals(a, b)` → Boolean check.
- `if(condition, trueValue, falseValue)` → Conditional value.
- `not(value)` → Negates boolean.
- `and(arg1, arg2)` / `or(arg1, arg2)` → Logical operators.

📌 Example:

```json
"variables": {
  "sku": "[if(equals(parameters('environment'), 'prod'), 'Premium_LRS', 'Standard_LRS')]"
}
```

---

### 5. **Deployment & Scope Functions**

Get metadata about current deployment.

- `resourceGroup()` → Current RG info (id, location, name).
- `subscription()` → Subscription details.
- `tenant()` → Tenant ID details.
- `deployment()` → Deployment name, outputs, correlation ID.

📌 Example:

```json
"variables": {
  "rgLocation": "[resourceGroup().location]",
  "subId": "[subscription().subscriptionId]"
}
```

---

### 6. **Resource Functions**

Work with resources.

- `resourceId([subscriptionId], [resourceGroupName], resourceType, resourceName)` → Full resource ID.
- `reference(resourceId, [apiVersion])` → Gets runtime properties of a resource.
- `listKeys(resourceId, apiVersion)` → Retrieves keys (like storage account keys).
- `providers(namespace)` → Info about resource providers.

📌 Example:

```json
"variables": {
  "storageId": "[resourceId('Microsoft.Storage/storageAccounts', parameters('storageName'))]"
}
```

---

### 7. **Unique String & GUID Functions**

Generate unique but consistent values.

- `uniqueString(baseString1, baseString2, …)` → Deterministic hash string.
- `newGuid()` → Generates a unique GUID each deployment.

📌 Example:

```json
"variables": {
  "dnsLabel": "[concat('app-', uniqueString(resourceGroup().id))]"
}
```

---

### 8. **Date & Time Functions**

Limited support in ARM.

- `utcNow([format])` → Returns current UTC timestamp (ISO 8601 by default).

📌 Example:

```json
"variables": {
  "buildDate": "[utcNow('yyyy-MM-dd')]"
}
```

⚠️ Note: `utcNow()` is _non-deterministic_ → every deployment it changes. Use carefully.

---

### 9. **Deployment Script Functions (Bicep & ARM)**

When using `Microsoft.Resources/deploymentScripts`:

- `environment()` → Returns cloud environment info (AzureCloud, AzureChinaCloud, etc.).

---

## 🔹 Authentication vs Authorization in Functions Context

Some functions (like `listKeys`, `reference`) require:

- **Authentication** → You (deployment identity) must be authenticated to Azure.
- **Authorization** → You must have permission (e.g., `Microsoft.Storage/storageAccounts/listKeys/action`) to fetch sensitive info.

---

## 🔹 Examples Putting It All Together

### Generate Resource Name with Environment Prefix

```json
"variables": {
  "env": "[parameters('environment')]",
  "storageName": "[toLower(concat(parameters('env'), 'stg', uniqueString(resourceGroup().id)))]"
}
```

### Conditional SKU Selection

```json
"variables": {
  "sku": "[if(equals(parameters('env'), 'prod'), 'Premium_LRS', 'Standard_LRS')]"
}
```

### Using Reference to Fetch Storage Keys

```json
"outputs": {
  "primaryKey": {
    "type": "string",
    "value": "[listKeys(resourceId('Microsoft.Storage/storageAccounts', parameters('storageName')), '2021-09-01').keys[0].value]"
  }
}
```

---

## 🔹 Best Practices

- ✅ Use **variables + functions** for readability.
- ✅ Keep **parameters simple**, do heavy logic with functions.
- ✅ Use **`uniqueString()` for deterministic names** (not `newGuid()` unless required).
- ⚠️ Avoid overusing `utcNow()` (non-repeatable deployments).
- ✅ Always check **RBAC** before using `listKeys` or `reference`.

---

## ✅ Summary

- ARM Templates provide **powerful built-in functions** for strings, numbers, arrays, logic, deployments, and resources.
- They make templates **flexible, reusable, and environment-agnostic**.
- Functions can be combined with **variables and parameters** to create highly dynamic infrastructure definitions.
