# üì¶ Hands-on MS-Graph Best Practices

- secure auth with **MSAL (app-only)**
- **least-privilege** scopes (`.default`)
- efficient queries with **\$select / \$filter / \$top**
- robust **pagination** using the SDK‚Äôs `PageIterator<T>`
- polite **throttling (429) retry** based on `Retry-After`
- basic **structured logging** and error handling

> This uses **application permissions** (daemon/background). For delegated (user) scenarios, I note the tiny changes you‚Äôd make.

---

## üì¶ Project setup

```bash
dotnet new console -n GraphBestPractices
cd GraphBestPractices
dotnet add package Microsoft.Graph
dotnet add package Microsoft.Identity.Client
```

Create `appsettings.json` (don‚Äôt hardcode secrets in production!):

```json
{
  "TenantId": "<your-tenant-id>",
  "ClientId": "<your-app-id>",
  "ClientSecret": "<your-client-secret>"
}
```

> For prod, store secrets in **Key Vault** or platform secret store.

---

## üß† Program.cs (complete example)

```csharp
using System.Net;
using Microsoft.Graph;
using Microsoft.Identity.Client;

// -------------------------------
// Minimal config load (replace with your config system)
var cfg = System.Text.Json.JsonDocument
    .Parse(System.IO.File.ReadAllText("appsettings.json"))
    .RootElement;
string tenantId = cfg.GetProperty("TenantId").GetString()!;
string clientId = cfg.GetProperty("ClientId").GetString()!;
string clientSecret = cfg.GetProperty("ClientSecret").GetString()!;

// -------------------------------
// 1) Build a Confidential Client (APP-ONLY) with MSAL
//    - Uses client credentials (no user).
//    - Requests '.default' so we only get admin-consented app roles.
//    - Least privilege: grant only what you need in App Registration.
IConfidentialClientApplication cca =
    ConfidentialClientApplicationBuilder.Create(clientId)
        .WithTenantId(tenantId)
        .WithClientSecret(clientSecret)
        .Build();

string[] scopes = { "https://graph.microsoft.com/.default" };

// Token factory with simple in-memory cache (MSAL already caches in-memory)
async Task<string> GetAccessTokenAsync()
{
    var result = await cca.AcquireTokenForClient(scopes).ExecuteAsync();
    return result.AccessToken;
}

// -------------------------------
// 2) Create GraphServiceClient with a lightweight auth handler
var graphClient = new GraphServiceClient(new DelegateAuthenticationProvider(async request =>
{
    request.Headers.Authorization =
        new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", await GetAccessTokenAsync());
}));

// -------------------------------
// Helper: polite retry wrapper (handles Graph throttling 429 / 503)
// Reads Retry-After header; falls back to exponential backoff.
async Task<T> WithRetry<T>(Func<Task<T>> action, int maxAttempts = 5)
{
    var delay = TimeSpan.FromSeconds(2);
    for (int attempt = 1; attempt <= maxAttempts; attempt++)
    {
        try
        {
            return await action();
        }
        catch (ServiceException ex) when (
            ex.StatusCode == HttpStatusCode.TooManyRequests ||
            ex.StatusCode == HttpStatusCode.ServiceUnavailable)
        {
            TimeSpan wait = ex.ResponseHeaders?.RetryAfter?.Delta ?? delay;
            Console.WriteLine($"[WARN] Throttled ({(int)ex.StatusCode}). Waiting {wait.TotalSeconds:F0}s...");
            await Task.Delay(wait);
            delay = TimeSpan.FromSeconds(Math.Min(delay.TotalSeconds * 2, 30));
        }
    }
    throw new Exception($"Operation failed after {maxAttempts} attempts.");
}

// -------------------------------
// 3) BEST PRACTICE: Use $select / $filter / $top and handle pagination
// Example: list users (app-only requires 'User.Read.All' application permission).
// - Return only needed fields for performance ($select)
// - Filter server-side where possible ($filter)
// - Page through all results safely

var select = "id,displayName,userPrincipalName";
var filter = "startswith(displayName,'A')";   // adjust as needed
var pageSize = 25;                             // use sensible page size

Console.WriteLine("Listing users (A*) with minimal fields and paging...\n");

var page = await WithRetry(() =>
    graphClient.Users
        .Request()
        .Select(select)
        .Filter(filter)
        .Top(pageSize)
        .GetAsync());

// Use the PageIterator helper to consume all pages
var iterator = PageIterator<User>.CreatePageIterator(
    graphClient,
    page,
    (user) =>
    {
        Console.WriteLine($"{user.DisplayName,-30} {user.UserPrincipalName}");
        return true; // continue
    });

await iterator.IterateAsync();

Console.WriteLine("\nDone.");

// -------------------------------
// 4) Another example: Query optimization with $select and $top (no filter)
//    This shows basic first-page + nextLink manual paging (alternative to PageIterator).

var usersRequest = graphClient.Users
    .Request()
    .Select("id,displayName,mail")
    .Top(10);

var firstPage = await WithRetry(() => usersRequest.GetAsync());

Console.WriteLine("\nFirst 10 users (selected fields):");
foreach (var u in firstPage.CurrentPage)
    Console.WriteLine($"{u.DisplayName,-30} {u.Mail}");

while (firstPage.NextPageRequest != null)
{
    firstPage = await WithRetry(() => firstPage.NextPageRequest.GetAsync());
    foreach (var u in firstPage.CurrentPage)
        Console.WriteLine($"{u.DisplayName,-30} {u.Mail}");
    // (break early if you only wanted N pages)
}
```

---

## üîç What this demonstrates (and why it‚Äôs ‚Äúbest practice‚Äù)

- **Secure auth**: MSAL **client credentials** w/ `.default` ‚Üí you only get **admin-consented** app roles (least privilege).
- **SDK over raw HTTP**: `GraphServiceClient` handles base URL, headers, models, paging helpers.
- **Efficient queries**:

  - `$select` returns only the properties you need.
  - `$filter` narrows results server-side.
  - `$top` controls page size.

- **Pagination**:

  - `PageIterator<T>` (simple, push-based) or manual `NextPageRequest`.

- **Throttling-aware**: Exponential backoff using Graph‚Äôs `Retry-After` header.
- **Logging**: Console logs for key events; in real apps use a structured logger (Serilog, ILogger).

---

## üß™ Want delegated (user) instead?

- Replace the confidential client with a **public client** and call `AcquireTokenInteractive()` or Device Code.
- Then you can call endpoints like `/me`:

  ```csharp
  var pca = PublicClientApplicationBuilder.Create(clientId)
      .WithTenantId(tenantId)
      .WithRedirectUri("http://localhost")  // or your app‚Äôs URI
      .Build();

  var result = await pca.AcquireTokenInteractive(new[] { "User.Read" }).ExecuteAsync();
  var graphClient = new GraphServiceClient(new DelegateAuthenticationProvider(req =>
  {
      req.Headers.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", result.AccessToken);
      return Task.CompletedTask;
  }));

  var me = await graphClient.Me.Request().Select("id,displayName,userPrincipalName").GetAsync();
  Console.WriteLine($"Hello {me.DisplayName}!");
  ```

> Ensure you request the **right permission type** (delegated vs application) in App Registration, and get **consent**.

---

## üß∞ Quick checklist (copy/paste to PRs)

- [ ] Use **MSAL** for tokens (no homemade OAuth).
- [ ] Request **least privilege** (scopes/app roles).
- [ ] Use **GraphServiceClient**, not manual HttpClient.
- [ ] Add `$select`, **never** fetch the whole object when you need 2 fields.
- [ ] Handle **pagination** (`PageIterator` or `NextPageRequest`).
- [ ] Implement **429/503 retry** (respect `Retry-After`).
- [ ] Minimize local storage; if caching, **encrypt** and set **retention**.
- [ ] Test queries first in **Graph Explorer**.
