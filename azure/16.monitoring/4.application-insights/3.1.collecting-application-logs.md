# 📊 Collecting Application Logs in Application Insights

When you start sending telemetry into Application Insights, it isn’t just “logs” — it’s **metrics** + **traces** + **events**, and how they’re stored/aggregated affects cost, performance, and troubleshooting.
Here are the two fundamental approaches 👇

---

## ⚖️ Metrics Types

### 1️⃣ Log-Based Metrics

Think of them as a **journal** 📒:

- Every single event/request/trace is written down.
- Stored in the **Logs (KQL)** tables.
- You can slice/dice with **all dimensions** (URL, userId, device, custom props).
- Ideal for **deep troubleshooting** and **forensics** (e.g., “what happened to user A at 12:03 PM?”).

⚠️ Trade-off: Storage cost 💸 grows quickly if you’re high-volume.

👉 **Use when:**

- You need raw detail.
- Debugging one-off errors.
- Performance analysis on specific users/flows.

---

### 2️⃣ Pre-Aggregated Metrics

Think of them as a **scoreboard** 🎯:

- SDK or App Insights agent **aggregates** events before sending.
- You get **time-series** (e.g., request count per 1 min, avg latency per 5 min).
- Stores only **key dimensions** (operation name, region, resultCode).
- Super efficient for **dashboards + alerts**.

⚡ Lighter, cheaper, better for **scale monitoring**.

👉 **Use when:**

- App is high-traffic (millions of requests).
- You just need trends (availability, P95 latency).
- Dashboards/alerts should stay fast.

---

📌 **Analogy:**

- Log-based = CCTV camera 🎥 (records everything, costs storage).
- Pre-aggregated = Security guard’s hourly report 📝 (summarized, efficient).

---

## 🛠 Instrumenting Your Application

To collect telemetry, you have 2 paths:

### 1️⃣ Auto-Instrumentation 🚀

“No-code” way to light up telemetry.

- Supported in **.NET, Java, Node.js, Python**.
- Azure App Service / Functions → just toggle **Application Insights ON**.
- Captures:

  - Requests
  - Dependencies (SQL, APIs, storage)
  - Exceptions
  - Logs (`ILogger`, `Console.WriteLine`)

✅ Best for quick setup or POCs.  
❌ Less control over custom properties/flows.

---

### 2️⃣ Distributed Tracing 🔗

The **serious tool** for microservices.

- Tracks a request as it hops across services.
- Adds **correlation IDs** (`traceparent`, `operation_Id`).
- Lets you see the **full path** in **Application Map**.

Options:

- Use SDKs (`Microsoft.ApplicationInsights.*`) in your code.
- Or use **OpenTelemetry/OpenCensus** exporters → App Insights.

✅ Best for:

- Microservices, service bus, Event Hub, queues.
- Debugging cross-service bottlenecks.
  ❌ Requires explicit setup if not auto-propagated.

---

## 🗺 Pro Tip: Application Map

Use **Application Map** to instantly visualize:

- Services → APIs → Databases → Queues.
- Latency bottlenecks (P95, P99).
- Dependencies failing (red line 🔴).

This is your **control tower** for distributed systems. ✈️

---

## 🧠 Memorization Hack

- **Logs = Details** (good for **debugging**)
- **Metrics = Trends** (good for **monitoring**)
- **Auto-Instrumentation = Easy Mode** 🎮
- **Distributed Tracing = Deep Mode** 🔍
- **Application Map = Google Maps for microservices** 🗺

---

👉 Want me to also give you a **step-by-step .NET SDK example** that shows both **log-based (TrackEvent, TrackException)** and **pre-aggregated (automatic metrics)** in action?
