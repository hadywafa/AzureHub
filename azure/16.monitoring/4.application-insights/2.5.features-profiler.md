# 🔎 Application Insights Profiler Feature

## 📖 Official definition (humanized)

_**Application Insights Profiler** is a **code-level performance diagnostic tool**._

> Instead of just showing you _“endpoint X is slow”_ (like Performance does), Profiler tells you:  
> 👉 _“Inside endpoint X, method Y is eating 80% of CPU, calling SQL Z in a loop.”_

- Captures **call stacks & execution trees** while your app runs.
- Records **CPU usage per function** and time distribution.
- Runs **periodically** (short bursts, ~2 minutes/hour) to avoid overhead.
- Helps **developers** pinpoint _why_ something is slow.

---

## 🏗️ How Profiler works

1. Profiler attaches to your **App Service / Function / AKS pod / VM**.
2. It runs a **sampling profiler** (very low overhead).
3. Collects snapshots of the call stack across all threads.
4. Uploads these traces to Application Insights.
5. In the portal, you can view:

   - **Flame graphs** (hot path visualization).
   - **Call tree** (method hierarchy + % CPU time).
   - **Sampled traces** linked to the slow request in Performance.

---

## 🧭 Flow: Profiler trace pipeline

```mermaid
---
config:
  look: handDrawn
  theme: dark
title: "App Insights Profiler Flow"
---
flowchart LR
    A[App Service / Function Running] --> B[Profiler Agent Attached]
    B --> C["Periodic Trace Capture (2 mins/hr)"]
    C --> D[Call Stacks + CPU Usage]
    D --> E[Upload to App Insights]
    E --> F["Profiler UI in Portal (Flame Graph / Call Tree)"]
    F --> G[Developer Investigates Bottlenecks]

    classDef node fill: #c93636ff,stroke:#333,stroke-width:2px,color:#ffff;

```

---

## 📜 Sequence: How Profiler complements Performance

```mermaid
---
config:
  look: handDrawn
  theme: dark
title: "Performance + Profiler Diagnostic Journey"
---
sequenceDiagram
    participant U as User
    participant App as Application
    participant Perf as Perf Metrics (App Insights)
    participant Prof as Profiler
    participant Dev as Developer

    U->>App: /api/orders request
    App->>Perf: Record request duration (3.5s avg)
    Perf-->>Dev: "This endpoint is slow (95th percentile 4s)."

    Note over Perf: Dev knows *what* is slow

    Perf->>Prof: Trigger Profiler (periodic)
    Prof->>App: Capture call stack samples
    Prof-->>Perf: Upload trace (method-level data)
    Perf-->>Dev: "80% time spent in OrdersRepo.GetAll()"

    Note over Prof: Dev now knows *why* it’s slow
```

---

## 🖼️ What you see in the portal

- **Profiler blade** (linked from Performance → “Investigate Profiler traces”):

  - **Call tree view**: expandable tree of methods.
  - **Flame graph view**: visual blocks showing where most time is spent.

- Example:

  - `/api/orders` total time = 3.8s
  - `OrdersRepository.GetAll()` = 3.2s (SQL query)
  - `JsonSerializer.Serialize()` = 0.4s

---

## 🧪 Hands-on (how to enable)

1. **Enable Profiler**:

   - Azure Portal → App Service → Application Insights → **Profiler → Turn On**.
   - Or CLI:

     ```bash
     az webapp config set --name <app> --resource-group <rg> --enable-app-insights-profiler true
     ```

2. **Trigger load**: run traffic (Profiler won’t start without requests).
3. **Wait ~1 hour**: Profiler collects its first 2-minute sample.
4. **View traces**:

   - Go to Application Insights → **Investigate → Profiler traces**.
   - Drill into slow request trace → inspect flame graph.

---

## 🧠 Cheat sheet

- **Performance blade** = _what’s slow (endpoint-level)_
- **Profiler** = _why it’s slow (code-level, method hot paths)_
- **Overhead**: minimal (sampling, short sessions).
- **Supported on**: App Service (Windows/Linux), Azure Functions, AKS, VMs (via SDK/agent).
- **Use it when**:

  - Performance blade shows a slow endpoint but you don’t know why.
  - Customers report intermittent slowness → Profiler trace captures the culprit.

---

✅ Summary:

- Profiler is **not the same as Performance** — it’s the **microscope 🔬** to Performance’s telescope 🔭.
- Use **Performance** first (to spot slow endpoints), then **Profiler** (to root-cause code-level issues).
