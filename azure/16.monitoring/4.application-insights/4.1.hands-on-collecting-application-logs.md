# **Hands-on** Collect telemetry in Azure Application Insights

- **Path 1:** Auto-Instrumentation ðŸš€ (fastest way; minimal or no code)
- **Path 2:** Distributed Tracing ðŸ”— (end-to-end traces across services)

Iâ€™ll show **ASP.NET Core** (web) + optional **Worker** patterns, what to expect, and how to **verify in KQL**.

---

## 1ï¸âƒ£ **Auto-Instrumentation**

### ðŸ“Œ **A. ASP.NET Core** (SDK â€œautoâ€ modeâ€”1 minute)

ðŸ”¹ **1. Install:**

```bash
dotnet add package Microsoft.ApplicationInsights.AspNetCore
```

ðŸ”¹ **2. Wire it up (Program.cs):**

```csharp
var builder = WebApplication.CreateBuilder(args);

// Option 1: read from env var APPLICATIONINSIGHTS_CONNECTION_STRING
// Option 2: or from appsettings: "ApplicationInsights:ConnectionString"
builder.Services.AddApplicationInsightsTelemetry();

builder.Services.AddControllers();
var app = builder.Build();

app.MapGet("/ping", () => "pong");
app.Run();
```

> Thatâ€™s it. App Insights auto-collects **Requests, Dependencies (HTTP/SQL/etc), Exceptions, Traces, Metrics, Live Metrics**.

ðŸ”¹ 3. **(Optional) appsettings.json**

```json
{
  "ApplicationInsights": {
    "ConnectionString": "InstrumentationKey=...;IngestionEndpoint=..."
  }
}
```

ðŸ”¹ **4. What you get automatically:**

- **Requests** (incoming endpoints)
- **Dependencies** (`HttpClient`, SQL, Azure SDK calls)
- **Exceptions** (unhandled + logged)
- **Traces** (via `ILogger`)

ðŸ”¹ **5. Minimal custom telemetry:**

```csharp
app.MapPost("/checkout", (TelemetryClient tc, ILogger<Program> log) =>
{
    tc.TrackEvent("CheckoutStarted", new() { ["channel"] = "web" }, new() { ["cartTotal"] = 79.99 });
    log.LogInformation("Checkout hit");
    return Results.Ok();
});
```

---

### ðŸ“Œ **B. Azure App Service** (no code changeâ€”portal switch)

1. Deploy your web app to **App Service**.
2. In the **App Service â†’ Application Insights** blade: **Turn On**.
3. Choose **Workspace-based** and **Apply**.

> The agent auto-collects **requests, dependencies, exceptions, logs** without modifying code. Great for legacy apps.

---

### ðŸ“Œ **C. .NET Worker Service** (background jobs)

ðŸ”¹ **1. Install:**

```bash
dotnet add package Microsoft.ApplicationInsights.WorkerService
```

ðŸ”¹ **2. Program.cs:**

```csharp
using Microsoft.ApplicationInsights;

var builder = Host.CreateApplicationBuilder(args);
builder.Services.AddApplicationInsightsTelemetryWorkerService();
builder.Services.AddHostedService<Worker>();
var app = builder.Build();
await app.RunAsync();

public sealed class Worker : BackgroundService
{
    private readonly TelemetryClient _tc;
    private readonly ILogger<Worker> _log;
    public Worker(TelemetryClient tc, ILogger<Worker> log) => (_tc, _log) = (tc, log);

    protected override async Task ExecuteAsync(CancellationToken ct)
    {
        while (!ct.IsCancellationRequested)
        {
            _log.LogInformation("heartbeat");
            _tc.TrackEvent("WorkerHeartbeat");
            await Task.Delay(TimeSpan.FromSeconds(5), ct);
        }
    }
}
```

---

### ðŸ“Œ **D. Verify** (KQL quick checks)

In **Application Insights â†’ Logs**:

```kql
// Requests volume by name
requests
| summarize count() by name
| order by count_ desc

// Dependency failures
dependencies
| where success == false
| summarize fails=count() by target, name, resultCode
| top 10 by fails desc

// Custom events you tracked
customEvents
| summarize count() by name, bin(timestamp, 5m)
```

---

## 2ï¸âƒ£ **Distributed Tracing**

Weâ€™ll build two services:

- **Service A** (API Gateway / Orchestrator) calls
- **Service B** (Downstream API)

Youâ€™ll see a single transaction flow in **End-to-End Transaction** and **Application Map**.

> Modern .NET uses **W3C Trace-Context** by default. App Insights SDK automatically propagates `traceparent` over `HttpClient`.

---

### ðŸ“Œ **A. Service B** (downstream API)

**1. Install + wire:**

```bash
dotnet add package Microsoft.ApplicationInsights.AspNetCore
```

```csharp
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddApplicationInsightsTelemetry();
var app = builder.Build();

app.MapPost("/charge", async (ILogger<Program> log) =>
{
    // Simulate downstream work
    await Task.Delay(200);
    log.LogInformation("charge completed");
    return Results.Ok(new { status = "charged" });
});

app.Run();
```

---

### ðŸ“Œ **B. Service A** (orchestrator that calls Service B)

**1. Install + wire:**

```bash
dotnet add package Microsoft.ApplicationInsights.AspNetCore
```

```csharp
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddApplicationInsightsTelemetry();

// Use named HttpClient (AI auto-tracks dependencies + propagates trace headers)
builder.Services.AddHttpClient("payments", c =>
{
    c.BaseAddress = new Uri("https://localhost:5002"); // Service B URL
});

var app = builder.Build();

app.MapPost("/pay", async (IHttpClientFactory http, TelemetryClient tc) =>
{
    // Optional: start a named operation to see a clear root span
    using var op = tc.StartOperation<RequestTelemetry>("PayOrchestrator");

    var client = http.CreateClient("payments");
    var res = await client.PostAsync("/charge", new StringContent("{}"));

    if (!res.IsSuccessStatusCode)
    {
        tc.TrackException(new Exception($"Charge failed: {res.StatusCode}"));
        return Results.StatusCode(502);
    }

    return Results.Ok(new { status = "ok" });
});

app.Run();
```

**2. What happens:**

- **Request** `/pay` (Service A) is the **root span**.
- AI auto-tracks outgoing `HttpClient` call as a **dependency** and injects **trace headers**.
- Service B receives the headers â†’ AI links Bâ€™s **request** to Aâ€™s operation.
- In the portal youâ€™ll see the full chain in **End-to-End Transaction** & **Application Map**.

---

## ðŸ“Œ **C. Enrich every telemetry item** (common dimensions)

```csharp
using Microsoft.ApplicationInsights.Channel;
using Microsoft.ApplicationInsights.Extensibility;

public sealed class CommonPropsInitializer : ITelemetryInitializer
{
    public void Initialize(ITelemetry t)
    {
        t.Context.GlobalProperties["env"] = "prod";
        t.Context.GlobalProperties["service"] = "orchestrator"; // or "payments"
        t.Context.GlobalProperties["region"] = "westeurope";
    }
}
```

Register:

```csharp
builder.Services.AddSingleton<ITelemetryInitializer, CommonPropsInitializer>();
```

---

## ðŸ“Œ **D. OpenTelemetry route** (optional, if you prefer OTEL API)

Use the Azure Monitor (App Insights) exporter with OpenTelemetry:

```bash
dotnet add package Azure.Monitor.OpenTelemetry.AspNetCore
```

```csharp
using Azure.Monitor.OpenTelemetry.AspNetCore;
var builder = WebApplication.CreateBuilder(args);

// Adds OTEL Traces+Metrics and exports to App Insights using CONNECTION_STRING
builder.Services.AddOpenTelemetry().UseAzureMonitor();
```

> This is great when you already instrument with **ActivitySource / OTEL** and want to export to App Insights with minimal changes.

---

## ðŸ“Œ **E. Verify correlation** (KQL)

```kql
// Find a recent orchestrated request and see its dependency + child spans
requests
| where name == "POST /pay"
| top 1 by timestamp desc
| project operation_Id, url, duration, success

// Show all spans in the same trace
union requests, dependencies, traces, exceptions
| where operation_Id == "<paste operation_Id>"
| project timestamp, itemType = itemType, name, resultCode, duration, success, cloud_RoleName, operation_Id, id
| order by timestamp asc
```

---

## ðŸ’¡ **Production tips** (both paths)

- **Sampling**: keep default adaptive sampling; lower costs without losing patterns.
- **PII/Sensitive data**: scrub with an `ITelemetryInitializer`.
- **Alerts**: set alerts on error rate, P95 latency, dependency failures, availability.
- **Dashboards**: pin KQL charts for your SLOs.
- **Availability tests**: add synthetic tests to catch regional/endpoint issues.

---

## âœ… **TL;DR**

- **Auto-Instrumentation** (SDK or App Service switch) â†’ fastest setup; automatic Requests/Deps/Exceptions/Traces.
- **Distributed Tracing** â†’ stitch **Service A â†’ Service B** into one timeline via `HttpClient` propagation (or OTEL).
- **KQL** is your proof: query requests, dependencies, and operation correlation to confirm itâ€™s all wired.
