# ðŸ”¦ App Insight SDK

Hereâ€™s a clean, **step-by-step, copy-paste** guide to using **Azure Application Insights** from the **.NET SDK**. Iâ€™ll show both **ASP.NET Core (web API)** and **Worker/Console** patterns, plus **custom telemetry, correlation, enrichment, and filtering**. Keep this as your checklist. ðŸ’ª

---

## ðŸ“Œ 0. Create an App Insights resource & get the connection string

1. In Azure Portal: create **Application Insights** (workspace-based is fine).
2. Copy the **Connection string** (looks like `InstrumentationKey=...;IngestionEndpoint=...`).
3. Locally, set it via **env var** (recommended for dev):

```bash
setx APPLICATIONINSIGHTS_CONNECTION_STRING "InstrumentationKey=...;IngestionEndpoint=..."
```

> You can also put it in `appsettings.json` under `ApplicationInsights:ConnectionString`.

---

## ðŸ“Œ 1. ASP.NET Core (Web API) â€” quick setup

### 1.1 Install package

```bash
dotnet add package Microsoft.ApplicationInsights.AspNetCore
```

### 1.2 Wire it up (Program.cs)

```csharp
var builder = WebApplication.CreateBuilder(args);

// Use env var or appsettings: ApplicationInsights:ConnectionString
builder.Services.AddApplicationInsightsTelemetry();

// Optional: tweak default options
// builder.Services.AddApplicationInsightsTelemetry(o =>
// {
//     o.EnableAdaptiveSampling = true;   // on by default for web apps
//     o.EnableDebugLogger = false;
// });

builder.Services.AddControllers();
var app = builder.Build();

app.MapGet("/ping", (ILoggerFactory lf) =>
{
    var log = lf.CreateLogger("Ping");
    log.LogInformation("Ping called");
    return Results.Ok("pong");
});

app.Run();
```

âœ… What you get **automatically**:

- **Requests** (incoming HTTP)
- **Dependencies** (outgoing `HttpClient`, SQL, Azure SDKs, etc.)
- **Exceptions** (unhandled & logged)
- **Traces** (anything you write via `ILogger`)
- **Live Metrics** stream

### 1.3 Send custom telemetry

```csharp
using Microsoft.ApplicationInsights;
using Microsoft.ApplicationInsights.DataContracts;

app.MapPost("/checkout", (TelemetryClient tc, ILogger<Program> log) =>
{
    // Custom event
    tc.TrackEvent("CheckoutStarted", new() { ["channel"] = "web" }, new() { ["cartTotal"] = 79.99 });

    // Custom metric
    tc.TrackMetric("ItemsInCart", 3);

    // Custom trace
    log.LogInformation("Checkout request received");

    return Results.Ok(new { status = "ok" });
});
```

---

## ðŸ“Œ 2. Worker / Console app â€” quick setup

### 2.1 Create & install

```bash
dotnet new worker -n WorkerWithAI
cd WorkerWithAI
dotnet add package Microsoft.ApplicationInsights.WorkerService
```

### 2.2 Wire it up (Program.cs)

```csharp
using Microsoft.ApplicationInsights;
using Microsoft.Extensions.Hosting;

var builder = Host.CreateApplicationBuilder(args);

// Uses env var APPLICATIONINSIGHTS_CONNECTION_STRING or appsettings
builder.Services.AddApplicationInsightsTelemetryWorkerService();

// Optional: capture ILogger logs as traces (on by default in WorkerService)
builder.Services.AddHostedService<Worker>();

var app = builder.Build();
await app.RunAsync();

public sealed class Worker : BackgroundService
{
    private readonly TelemetryClient _tc;
    private readonly ILogger<Worker> _log;

    public Worker(TelemetryClient tc, ILogger<Worker> log)
        => (_tc, _log) = (tc, log);

    protected override async Task ExecuteAsync(CancellationToken ct)
    {
        while (!ct.IsCancellationRequested)
        {
            _log.LogInformation("Doing work...");
            _tc.TrackEvent("WorkerHeartbeat");
            await Task.Delay(TimeSpan.FromSeconds(5), ct);
        }
    }
}
```

---

## ðŸ“Œ 3. Correlation (distributed tracing) â€” end-to-end

**Good news:** in modern .NET, **W3C Trace-Context** is on by default. If your API calls another API with `HttpClient`, AI will propagate `traceparent` and stitch the timeline.

```csharp
builder.Services.AddHttpClient("payments");

app.MapPost("/pay", async (IHttpClientFactory http, TelemetryClient tc) =>
{
    using var op = tc.StartOperation<RequestTelemetry>("PayOrchestrator");
    var client = http.CreateClient("payments");

    var res = await client.PostAsync("https://payments.api/charge", new StringContent("{}"));

    if (!res.IsSuccessStatusCode)
        tc.TrackException(new Exception("Payment failed"));

    return Results.Ok();
});
```

> Youâ€™ll see both the incoming **request** and the outgoing **dependency** with the same operation/correlation IDs in App Insights **End-to-End Transaction** view.

---

## ðŸ“Œ 4. Enrich telemetry (add custom properties to everything)

Create a **telemetry initializer** to stamp common dimensions (env, tenant, region).

```csharp
using Microsoft.ApplicationInsights.Channel;
using Microsoft.ApplicationInsights.Extensibility;

public sealed class CommonPropsInitializer : ITelemetryInitializer
{
    public void Initialize(ITelemetry telemetry)
    {
        telemetry.Context.GlobalProperties["env"] = "prod";
        telemetry.Context.GlobalProperties["service"] = "checkout-api";
        telemetry.Context.GlobalProperties["region"] = "westeurope";
    }
}
```

Register it:

```csharp
builder.Services.AddSingleton<ITelemetryInitializer, CommonPropsInitializer>();
```

---

## ðŸ“Œ 5. Filter out noise (health checks, 404s, etc.)

Implement a **telemetry processor** to drop unwanted telemetry.

```csharp
using Microsoft.ApplicationInsights.Channel;
using Microsoft.ApplicationInsights.Extensibility;

public sealed class DropHealthChecksProcessor : ITelemetryProcessor
{
    private readonly ITelemetryProcessor _next;
    public DropHealthChecksProcessor(ITelemetryProcessor next) => _next = next;

    public void Process(ITelemetry item)
    {
        if (item is Microsoft.ApplicationInsights.DataContracts.RequestTelemetry r &&
            r.Url?.AbsolutePath?.Contains("health") == true)
            return; // drop

        _next.Process(item);
    }
}
```

Register it:

```csharp
builder.Services.AddApplicationInsightsTelemetry();
builder.Services.AddApplicationInsightsTelemetryProcessor<DropHealthChecksProcessor>();
```

---

## ðŸ“Œ 6. Handle exceptions and manual dependencies

### 6.1 Exceptions

```csharp
try
{
    throw new InvalidOperationException("Oops");
}
catch (Exception ex)
{
    // Will show stack trace + custom props
    telemetryClient.TrackException(ex, new() { ["module"] = "shipping" });
}
```

### 6.2 Custom dependency (around any external call)

```csharp
using Microsoft.ApplicationInsights;
using Microsoft.ApplicationInsights.DataContracts;

using var op = telemetryClient.StartOperation<DependencyTelemetry>("RedisGet");
try
{
    // ... call redis or any external system
    // op.Telemetry.Type = "Redis"; op.Telemetry.Target = "redis01:6379";
}
catch (Exception ex)
{
    telemetryClient.TrackException(ex);
    throw;
}
finally
{
    telemetryClient.StopOperation(op);
}
```

---

## ðŸ“Œ 7. Verify data & query in the Portal (KQL quickstart)

**Where to look:**

- **Live Metrics** â†’ immediate signal
- **Failures** â†’ exceptions, failed requests
- **Performance** â†’ p50/p95/p99
- **Logs** â†’ run KQL queries

**Useful KQL:**

```kql
// Failed endpoints (top offenders)
requests
| where success == false
| summarize fails=count() by name, resultCode
| top 10 by fails desc

// Slowest dependencies
dependencies
| summarize avg_ms=avg(duration) by target, name
| top 10 by avg_ms desc

// Custom events volume
customEvents
| summarize count() by name, bin(timestamp, 1h)

// Trace with correlation id
traces
| where customDimensions['operation_Id'] == '<paste id>'
```

---

## ðŸ“Œ 8. Production tips (essentials)

- **Sampling**: Adaptive sampling is **on by default** in web apps to keep volume/cost sane. If you need full fidelity for specific events, enrich them with `SampleRate = 100` using a custom processor (advanced).
- **PII**: Donâ€™t log secrets/PII; scrub in `ITelemetryInitializer`.
- **Connection string**: Use **env vars** or **Key Vault**; donâ€™t hardcode.
- **Dashboards & Alerts**: Pin KQL charts to dashboards; set alerts on error rate, dependency failures, or availability tests.

---

## âœ… TL;DR â€” minimal check list

1. Create AI resource, set `APPLICATIONINSIGHTS_CONNECTION_STRING`.
2. `dotnet add package Microsoft.ApplicationInsights.AspNetCore` (or WorkerService).
3. `builder.Services.AddApplicationInsightsTelemetry(...)`.
4. Use `ILogger` for traces; use `TelemetryClient` for **events, metrics, dependencies, exceptions**.
5. Enrich with `ITelemetryInitializer`, filter with `ITelemetryProcessor`.
6. Verify in **Live Metrics**, **Failures**, **Performance**, **Logs (KQL)**.
