# ✍🏻 Hands On AuthN and AuthZ in App Service

- **A. Microsoft Entra ID (workforce)**: Easy Auth + **role-based authorization** + **call Microsoft Graph**
- **B. Entra External ID (B2C)**: Easy Auth with **user flows** for consumer sign-in

And a **.NET 8 minimal API** you can deploy to App Service that reads identity from Easy Auth, enforces roles, and calls Graph.

---

## 🔐 Scenario

You have an Azure App Service (Web App / API).
You want:

1. **Sign-in** handled by App Service Authentication (Easy Auth)
2. **Roles/authorization** inside your app
3. **Call Microsoft Graph** with the **user’s access token** (no custom OAuth middleware)

---

## 🧭 Entra ID (Workforce) — Internal users, roles, Graph

### 1. Turn on Easy Auth (Portal)

- App Service → **Authentication** → **+ Add identity provider**
- Provider: **Microsoft**
- Create new **App registration** (single-tenant)
- **App Service authentication**: On
- **Unauthenticated requests**: **HTTP 401**
- Keep default **User.Read** permission (minimal)
- Save

> This creates/links an app registration in your Entra tenant and configures the Easy Auth front door.

---

### 2. Add **App Roles** (authorization)

1. Entra admin center → **App registrations** → your web app → **App roles** → **Create app role**

   - Display name: `App.Admin`
   - Allowed member types: **Users/Groups**
   - Value: `App.Admin` (this becomes the `roles` claim)

2. Assign the role to a test user/group:

   - Enterprise applications → your service principal → **Users and groups** → **Add assignment** → pick user/group + role

> After re-login, Easy Auth will pass a `roles: ["App.Admin"]` claim to your app.

---

### 3. (Optional) Allow your app to call Graph with user token

If you’ll hit `/me` (Graph), ensure:

- In **App registration → API permissions**: **Microsoft Graph / User.Read** (delegated) → **Grant admin consent**
- In App Service **Authentication** pane, make sure **Token Store** is enabled (usually default).
- Easy Auth will inject `X-MS-TOKEN-AAD-ACCESS-TOKEN` for Graph if scopes are satisfied.

---

### 4. Minimal .NET 8 API (role checks + Graph call)

**Program.cs:**

```csharp
using System.Security.Claims;

var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

// Helper: decode X-MS-CLIENT-PRINCIPAL (base64 json → ClaimsPrincipal)
static ClaimsPrincipal? FromClientPrincipal(HttpRequest req)
{
    var b64 = req.Headers["X-MS-CLIENT-PRINCIPAL"].FirstOrDefault();
    if (string.IsNullOrEmpty(b64)) return null;

    var json = System.Text.Encoding.UTF8.GetString(Convert.FromBase64String(b64));
    var doc = System.Text.Json.JsonDocument.Parse(json);
    var claims = new List<Claim>();
    var identityProvider = doc.RootElement.GetProperty("identityProvider").GetString();

    foreach (var c in doc.RootElement.GetProperty("claims").EnumerateArray())
    {
        var typ = c.GetProperty("typ").GetString()!;
        var val = c.GetProperty("val").GetString()!;
        claims.Add(new Claim(typ, val));
    }

    var id = new ClaimsIdentity(claims, authenticationType: identityProvider ?? "EasyAuth");
    return new ClaimsPrincipal(id);
}

app.MapGet("/whoami", (HttpRequest req) =>
{
    var user = FromClientPrincipal(req);
    if (user is null || !user.Identity?.IsAuthenticated == true) return Results.Unauthorized();

    var name = user.Claims.FirstOrDefault(c => c.Type is "name" or "preferred_username")?.Value ?? "unknown";
    var roles = user.FindAll("roles").Select(r => r.Value).ToArray();
    return Results.Json(new { name, roles });
});

// Role-gated endpoint (needs App.Admin)
app.MapGet("/admin", (HttpRequest req) =>
{
    var user = FromClientPrincipal(req);
    if (user is null || !user.Identity?.IsAuthenticated == true) return Results.Unauthorized();

    var isAdmin = user.IsInRole("App.Admin") || user.Claims.Any(c => c.Type == "roles" && c.Value == "App.Admin");
    return isAdmin ? Results.Text("Welcome, admin!") : Results.Forbid();
});

// Call Microsoft Graph /me using the user token from Easy Auth
app.MapGet("/me", async (HttpRequest req) =>
{
    var token = req.Headers["X-MS-TOKEN-AAD-ACCESS-TOKEN"].FirstOrDefault();
    if (string.IsNullOrEmpty(token)) return Results.Text("No Graph token. Ensure User.Read is consented & Token Store is enabled.", "text/plain");

    using var http = new HttpClient();
    var msg = new HttpRequestMessage(HttpMethod.Get, "https://graph.microsoft.com/v1.0/me");
    msg.Headers.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", token);
    var res = await http.SendAsync(msg);
    var body = await res.Content.ReadAsStringAsync();
    return Results.Content(body, "application/json");
});

app.Run();
```

**How to test:**

- Deploy to your App Service with Easy Auth enabled.
- Hit `/whoami` → see your name/roles.
- Hit `/admin` → 200 if your user has `App.Admin`; 403 otherwise.
- Hit `/me` → Graph profile JSON (if User.Read is good and token header exists).

---

## 🌍 Entra External ID (B2C) — Customer sign-in with user flows

Use this when your app serves **external customers** (email/password, social).
Core idea: configure **user flows** (sign-up/sign-in), wire Easy Auth to your B2C tenant (OIDC), and let App Service handle redirects.

> Authorization (roles) in B2C typically uses **custom attributes**, **groups**, or **app roles** (depending on your B2C/External ID setup). The app below will accept any authenticated user; you can gate by a claim such as `extension_<attr>` or group later.

### 1. Prepare External ID (B2C) tenant

- Create / use an **Entra External ID (Azure AD B2C)** tenant
- In the B2C tenant:

  - **App registrations** → **New registration** → Web app
  - Redirect URI (Web): `https://<your-app>.azurewebsites.net/.auth/login/aad/callback`
  - Expose no special permissions for now

- **User flows** (Policies) → create **Sign up and sign in** (e.g., `B2C_1_susi`)

  - Collect basic attributes (email, displayName)
  - Configure identity providers (local accounts, Google, etc.)

> Note your **Tenant name**, **Policy name**, and **App (client) ID**.

---

### 2. Configure Easy Auth (Portal)

- App Service → **Authentication** → **+ Add identity provider**
- Choose **OpenID Connect** (custom)
- **Issuer URL** (B2C authority for user flow):

  ```ini
  https://<your-b2c-tenant>.b2clogin.com/<your-b2c-tenant>.onmicrosoft.com/v2.0/
  ```

- **Metadata URL** (policy specific), typically:

  ```ini
  https://<your-b2c-tenant>.b2clogin.com/<your-b2c-tenant>.onmicrosoft.com/v2.0/.well-known/openid-configuration?p=B2C_1_susi
  ```

- **Client ID**: the app registration’s Application (client) ID in B2C tenant
- **Client secret setting name**: create/store a secret in App Settings (e.g., `B2C_CLIENT_SECRET`) then reference it here
- **Allowed token audiences**: your **Client ID**
- Save.
- Set **Unauthenticated requests** to **HTTP 401** to force sign-in.

> After saving, `/.auth/login/` should redirect to the B2C user flow.

---

### 3. .NET API code works the same

Use the **same Program.cs** above — Easy Auth still sets `X-MS-CLIENT-PRINCIPAL` and (if configured) OIDC tokens in headers.
For B2C authorization, check a **group** claim or a **custom attribute** (B2C emits them as `extension_<attributeName>` when configured in the user flow).

Example of gating by custom attribute (pseudo):

```csharp
app.MapGet("/vip", (HttpRequest req) =>
{
    var user = FromClientPrincipal(req);
    if (user is null) return Results.Unauthorized();

    var isVip = user.Claims.Any(c => c.Type.StartsWith("extension_") && c.Type.EndsWith("isVip") && c.Value == "true");
    return isVip ? Results.Ok("VIP access") : Results.Forbid();
});
```

> To emit custom attributes into tokens, add them to your B2C user flow’s **Application claims**.

---

## 🧪 Local vs Azure

- **Local dev**: You can run the app locally without Easy Auth; endpoints will show 401 (no headers).
- **Azure**: Once deployed behind Easy Auth, the identity headers exist and everything lights up.

---

## 🔧 Useful built-in endpoints

- `/.auth/login/aad` (Entra) or `/.auth/login/<oidc>` (B2C custom OIDC)
- `/.auth/logout`
- `/.auth/me` → current identity + tokens (great for debugging)

---

## 🧯 Troubleshooting quick hits

| Symptom                          | Likely cause                     | Fix                                                                                                           |
| -------------------------------- | -------------------------------- | ------------------------------------------------------------------------------------------------------------- |
| Looping redirect                 | Redirect URI mismatch            | Ensure `https://<app>.azurewebsites.net/.auth/login/aad/callback` (or OIDC equivalent) is in app registration |
| 401 on protected routes          | Easy Auth still allows anonymous | Set **Unauthenticated requests = HTTP 401**                                                                   |
| No `X-MS-TOKEN-AAD-ACCESS-TOKEN` | Token store/scopes not set       | Enable token store; ensure Graph **User.Read** delegated permission & consent                                 |
| Roles not appearing              | Role assignment not done         | Assign **App.Admin** role to user/group on the service principal                                              |
| B2C custom claims missing        | Not selected in user flow        | Add attributes to the user flow **Application claims**                                                        |

---

## ✅ Best practices

- Use **Easy Auth** for quick, secure front-door authentication.
- Keep permissions **minimal** (principle of least privilege).
- For **Graph calls**, request only what you need (e.g., `User.Read`).
- For internal apps, use **App roles**; for B2C, use **groups/custom attributes**.
- Prefer **Managed Identity** for calling **Azure resources** (Key Vault, Storage) — no secrets.

---

## 🏁 TL;DR

- **Entra ID (workforce)**: Add Microsoft provider → enable Easy Auth → add **App roles** → authorize via `roles` claim → call **Graph** with `X-MS-TOKEN-AAD-ACCESS-TOKEN`.
- **Entra External ID (B2C)**: Add **OpenID Connect** provider with **user flow** metadata → authenticate customers → (optionally) gate by **groups/custom attributes**.
- **Code**: No OIDC middleware needed — read Easy Auth headers/claims; enforce roles in your handlers.
