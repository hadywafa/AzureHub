# ‚ö° Azure Durable Functions (From Basics to Advanced)

> üìñ **Durable Functions** is an **extension of Azure Functions** that lets you write **stateful serverless workflows** in a **serverless compute environment**.
>
> - üëâ In short: It helps you manage **long-running workflows** and **state** in a **stateless function world**.

## üåü 1. What is Azure Durable Functions?

Traditional Azure Functions are **stateless**:

- Each function call runs independently.
- State must be stored externally (DB, cache, etc.).

**Durable Functions** solve this by using the **Durable Task Framework** to:

- Store **state**, **checkpoints**, and **messages**.
- Allow **orchestration** of multiple functions.
- Support long-running processes that survive restarts.

---

## üß© 2. Core Concepts

Durable Functions define workflows using three main function types:

| Function Type             | Role                                                                                        |
| ------------------------- | ------------------------------------------------------------------------------------------- |
| **Client Function**       | Entry point. Starts orchestration (e.g., HTTP trigger, queue message).                      |
| **Orchestrator Function** | Defines workflow logic. Calls activity functions in order, in parallel, or with conditions. |
| **Activity Function**     | Performs the actual work (e.g., call API, process data, send email).                        |

### Example Flow

```mermaid
flowchart LR
    A[Client Function - HTTP Trigger] --> B[Orchestrator Function]
    B -->|Call| C[Activity Function - Validate Input]
    B -->|Call| D[Activity Function - Process Payment]
    B -->|Call| E[Activity Function - Send Email]
```

---

## ‚ö° 3. Programming Model

### Example: Orchestration Function

```csharp
[FunctionName("OrderOrchestrator")]
public static async Task Run(
   [OrchestrationTrigger] IDurableOrchestrationContext context)
{
    var order = context.GetInput<Order>();
    await context.CallActivityAsync("ValidateOrder", order);
    await context.CallActivityAsync("ProcessPayment", order);
    await context.CallActivityAsync("SendConfirmation", order.CustomerEmail);
}
```

### Example: Activity Function

```csharp
[FunctionName("ValidateOrder")]
public static string ValidateOrder([ActivityTrigger] Order order)
{
    return order.IsValid ? "Valid" : "Invalid";
}
```

### Example: Client Function

```csharp
[FunctionName("StartOrder")]
public static async Task<HttpResponseMessage> StartOrder(
   [HttpTrigger(AuthorizationLevel.Function, "post")] HttpRequestMessage req,
   [DurableClient] IDurableOrchestrationClient starter)
{
    var order = await req.Content.ReadAsAsync<Order>();
    string instanceId = await starter.StartNewAsync("OrderOrchestrator", order);
    return starter.CreateCheckStatusResponse(req, instanceId);
}
```

---

## üîÑ 4. Durable Function Patterns

Durable Functions support **five key orchestration patterns**:

### 1Ô∏è‚É£ Function Chaining

Run tasks in sequence.  
‚úÖ Example: Validate ‚Üí Process ‚Üí Send Email.

```mermaid
flowchart LR
    A[Step 1] --> B[Step 2] --> C[Step 3]
```

---

### 2Ô∏è‚É£ Fan-out / Fan-in

Run tasks in parallel and aggregate results.  
‚úÖ Example: Resize images into multiple formats.

```mermaid
flowchart LR
    A[Orchestrator] --> B1[Activity A]
    A --> B2[Activity B]
    A --> B3[Activity C]
    B1 --> C[Aggregate]
    B2 --> C
    B3 --> C
```

---

### 3Ô∏è‚É£ Async HTTP APIs

Allow clients to start an orchestration and then poll for status via a **status endpoint**.  
‚úÖ Example: Long-running report generation.

---

### 4Ô∏è‚É£ Human Interaction

Workflows that pause until external input arrives.  
‚úÖ Example: Wait for manager approval before processing payment.

- Uses `WaitForExternalEvent` API.

```csharp
var approval = await context.WaitForExternalEvent<string>("ApprovalEvent");
if (approval == "Approved") {
    await context.CallActivityAsync("ProcessPayment", order);
}
```

---

### 5Ô∏è‚É£ Monitor

Recurring process that runs at intervals.  
‚úÖ Example: Monitor website health every 5 minutes until condition is met.

```csharp
while (true) {
    await context.CallActivityAsync("CheckWebsite", null);
    var nextCheck = context.CurrentUtcDateTime.AddMinutes(5);
    await context.CreateTimer(nextCheck, CancellationToken.None);
}
```

---

## ‚öôÔ∏è 5. State Management

Durable Functions maintain state by:

- **Checkpointing** every await.
- Automatically **replaying orchestrator code** to rebuild state.
- Storing state in **Azure Storage (Tables/Queues/Blobs)** or **SQL Backend**.

This ensures reliability:

- If VM crashes, orchestration can resume.
- You don‚Äôt manually manage persistence.

---

## üì¶ 6. Hosting & Scaling

Durable Functions run inside **Azure Functions runtime**.

- Can run on **Consumption Plan** (serverless autoscale).
- Or **Premium/Dedicated Plans** (for VNET, high scale, no cold starts).

Scaling is based on:

- Queue length in control/storage queues.
- Partitioned orchestrations across multiple instances.

---

## üõ† 7. Advanced Features

1. **Durable Entities**

   - Lightweight stateful objects managed by Durable Functions.
   - Replace the need for external DB for small state tracking.

   Example:

   ```csharp
   [FunctionName("Counter")]
   public static void Counter([EntityTrigger] IDurableEntityContext ctx)
   {
       switch (ctx.OperationName)
       {
           case "add": ctx.SetState(ctx.GetState<int>() + ctx.GetInput<int>()); break;
           case "get": ctx.Return(ctx.GetState<int>()); break;
       }
   }
   ```

2. **Sub-orchestrations**

   - Orchestrator can call another orchestrator.
   - Helps modularize workflows.

3. **Error Handling & Retries**

   - Built-in retry policies for transient failures.
   - Example: `CallActivityWithRetryAsync()`.

4. **Durable Timers**

   - Pause workflows until a specific time.
   - Example: `context.CreateTimer(DateTime.UtcNow.AddHours(1), CancellationToken.None);`

5. **Event Sourcing**

   - Durable Functions essentially replay orchestration code to rebuild state ‚Üí similar to event sourcing.

---

## üìâ Example Use Cases

- üßæ **Invoice Approval** ‚Üí Human interaction workflow.
- üìä **ETL Data Pipelines** ‚Üí Fan-out / fan-in with retries.
- üõí **E-commerce Orders** ‚Üí Orchestration of payment, inventory, and notifications.
- ü§ñ **IoT Processing** ‚Üí Durable Entities for device state tracking.
- üîç **Monitoring Systems** ‚Üí Monitor pattern for continuous checks.

---

## üîê 8. Limitations / Best Practices

- Orchestrator functions must be **deterministic** (no random, no DateTime.Now directly).
- Long-running orchestrations are fine (days, months).
- Store **large payloads in Blob Storage**, not directly in state.
- Use **Durable Entities** for small stateful apps.
- Watch out for **orchestration replay cost** ‚Üí design lean workflows.

---

## ‚úÖ Summary

- **Durable Functions** = Serverless + Stateful workflows.
- **Client ‚Üí Orchestrator ‚Üí Activity** model.
- Supports **patterns**: chaining, fan-out/fan-in, async APIs, human interaction, monitor.
- Manages **state & reliability** with automatic checkpointing.
- Advanced features include **durable entities, sub-orchestrations, retries, timers**.
- Perfect for **long-running, stateful, serverless workflows**.

---

üëâ Would you like me to create a **full step-by-step demo** (like we did for Logic Apps) where we build a real Durable Function orchestration ‚Äî e.g., "Order Processing Workflow" ‚Äî with screenshots + JSON outputs + status monitoring?
