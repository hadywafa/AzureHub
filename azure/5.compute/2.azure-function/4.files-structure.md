# 🏗️ Azure Functions – Function Structure

When you develop with **Azure Functions**, your project is organized into a **function app** that contains one or more **functions**. Each layer has its own configuration files, and together they define how your serverless app behaves both locally and in Azure.

---

## 📦 **Function App**

- **Definition**: A **function app** is the main unit of deployment and management in Azure Functions.
- **Role**: Groups multiple functions together so they share:

  - Same **runtime version**
  - Same **pricing plan**
  - Same **deployment method**
  - Same **global settings**

👉 Example: You may have functions like `ProcessOrders`, `SendEmails`, and `LogActivity` inside one function app, all billed under the same plan.

---

## 📂 **Typical File Structure**

Here’s what a simple function app looks like:

```ini
MyFunctionApp/
│
├── host.json               # Global config
├── local.settings.json     # Local dev settings
├── Function1/
│   ├── function.json       # Config for Function1
│   └── run.csx             # Function code (C#, or .js/.py)
│
├── Function2/
│   ├── function.json       # Config for Function2
│   └── index.js            # Function code
```

---

## ⚙️ **Function App Configuration**

### 1️⃣ Global Configuration (`host.json`)

- Applies to **all functions** in the app.
- Controls **runtime behavior**, logging, retries, and extension configs.

Example:

```json
{
  "version": "2.0",
  "extensions": {
    "http": {
      "routePrefix": "api"
    }
  },
  "logging": {
    "fileLoggingMode": "always",
    "logLevel": {
      "Function": "Information"
    }
  }
}
```

- `version`: runtime version
- `extensions.http.routePrefix`: sets global HTTP route prefix (`/api/...`)
- `logging`: defines logging mode and levels

---

### 2️⃣ Function-Level Configuration (`function.json`)

- Each **individual function** has its own `function.json`.
- Defines the **trigger** (how the function runs) and **bindings** (how it interacts with external services).

Example (HTTP-triggered function):

```json
{
  "bindings": [
    {
      "type": "httpTrigger",
      "direction": "in",
      "authLevel": "function",
      "methods": ["get", "post"]
    },
    {
      "type": "http",
      "direction": "out"
    }
  ]
}
```

- `httpTrigger`: executes function on GET/POST requests
- `authLevel: function`: requires API key
- `http` output binding: sends HTTP response

🔑 Rule: **Every function must have exactly one trigger**.

---

### 3️⃣ Local Development Configuration (`local.settings.json`)

- Used **only for local development**.
- Stores **connection strings, environment variables, CORS settings**.

Example:

```json
{
  "IsEncrypted": false,
  "Values": {
    "AzureWebJobsStorage": "UseDevelopmentStorage=true",
    "FUNCTIONS_WORKER_RUNTIME": "dotnet",
    "MyCustomSetting": "SomeValue"
  },
  "ConnectionStrings": {
    "SQLConnectionString": "Server=(localdb)\\mssqllocaldb;Database=MyDb;Trusted_Connection=True;"
  },
  "Host": {
    "CORS": "*",
    "CORSCredentials": false
  }
}
```

- `AzureWebJobsStorage`: connection to Storage (emulator locally)
- `FUNCTIONS_WORKER_RUNTIME`: defines runtime (dotnet, node, python, etc.)
- `ConnectionStrings`: DB or external resource connections
- `Host`: local CORS settings

⚠️ **Never commit secrets** in this file to source control.

---

## 🧬 **Triggers & Bindings**

- 🔔 **Trigger**: Defines when the function runs (HTTP request, queue message, timer, etc.).
- 🔗 **Bindings**: Handle how data flows **in and out** without writing plumbing code.

👉 Example: An HTTP trigger with an output binding to Cosmos DB lets you save API data straight to a database without manual connection code.

---

## ✅ **Key Takeaways**

- **Function App** = deployment unit, groups functions.
- **host.json** = global config (all functions).
- **function.json** = per-function config (trigger + bindings).
- **local.settings.json** = local-only settings.
- **Each function has exactly one trigger, plus optional bindings**.
