# ‚úçüèª Hands-On C# (.NET 8 isolated)\*\*

hands-on that covers **create ‚Üí build ‚Üí run locally ‚Üí test ‚Üí publish ‚Üí deploy**, plus how to wire it up in **VS Code**. It uses only **CLI + Core Tools**; no portal clicking.

---

## üß∞ Prerequisites (one time)

```bash
# Azure CLI
az version

# Azure Functions Core Tools v4
func --version

# .NET 8 SDK
dotnet --version

# (Optional) Azurite for local Storage emulator
azurite --version
```

If any is missing, install:

- Azure CLI: [https://aka.ms/azcli](https://aka.ms/azcli)
- Core Tools v4: [https://aka.ms/azfunctions-coretools](https://aka.ms/azfunctions-coretools)
- .NET 8 SDK: [https://dot.net](https://dot.net)
- Azurite: `npm i -g azurite` (or via VS Code extension)

---

## 0) Choose a working folder

```bash
mkdir func-csharp-demo && cd func-csharp-demo
```

---

## 1) Initialize a .NET 8 isolated Functions app

```bash
# Creates the project with .NET isolated worker + net8.0
func init MyFuncApp --worker-runtime dotnetIsolated --target-framework net8.0
cd MyFuncApp
```

This scaffolds:

```ini
MyFuncApp/
‚îú‚îÄ host.json
‚îú‚îÄ local.settings.json   # local-only settings (not deployed)
‚îú‚îÄ MyFuncApp.csproj
‚îî‚îÄ Program.cs
```

`Program.cs` is a minimal host; you don‚Äôt need to touch it for basic HTTP.

---

## 2) Add an HTTP-triggered function

```bash
func new --template "HTTP trigger" --name Hello
```

This adds:

```ini
MyFuncApp/
‚îî‚îÄ Hello.cs    # your function
```

The template includes an example that responds to `GET/POST`.

---

## 3) Build

```bash
dotnet restore
dotnet build -c Debug
```

---

## 4) Run locally

Start Azurite in another terminal (recommended):

```bash
azurite --silent &   # or run from the Azurite VS Code extension
```

Run Functions:

```bash
func start --verbose
```

You‚Äôll see something like:

```ini
http://localhost:7071/api/Hello
```

---

## 5) Test locally (curl / PowerShell)

```bash
# GET
curl "http://localhost:7071/api/Hello?name=World"

# POST
curl -X POST "http://localhost:7071/api/Hello" \
  -H "Content-Type: application/json" \
  -d '{"name":"World"}'
```

> You should get a friendly greeting back. Logs appear in the Functions console.

---

## 6) Open in VS Code (debugging)

```bash
code .
```

- VS Code detects the Functions app and offers to add **build & debug** assets.
- Press **F5** to run under the debugger (breakpoints in `Hello.cs` work).
- Update code ‚Üí hot-reload on rebuild.

_(If VS Code doesn‚Äôt scaffold, create `.vscode/launch.json` when prompted.)_

---

## 7) Create Azure resources (scriptable)

Set variables (bash; for PowerShell, adjust `$env:`/`$RANDOM`):

```bash
RG=rg-func-csharp-demo
LOC=westeurope
STG=stfunc$RANDOM     # must be globally unique
APP=func-csharp-demo  # must be globally unique per region
```

Create Resource Group + Storage + Function App (Linux, Consumption, v4, .NET isolated):

```bash
az login
az account show

az group create -n $RG -l $LOC

az storage account create \
  -n $STG -g $RG -l $LOC --sku Standard_LRS

az functionapp create \
  -g $RG -n $APP \
  --storage-account $STG \
  --consumption-plan-location $LOC \
  --functions-version 4 \
  --runtime dotnet-isolated \
  --os-type Linux
```

---

## 8) Publish (zip deploy) from CLI

From your project folder (`MyFuncApp`):

```bash
# Optional: clean publish output
rm -rf bin obj

# Build a Release output (faster cold start)
dotnet publish -c Release

# Publish with Core Tools (zip + run-from-package)
func azure functionapp publish $APP --dotnet-cli-params "--configuration Release"
```

This command:

- Packs your build output,
- Uploads it,
- Sets `WEBSITE_RUN_FROM_PACKAGE=1`,
- Syncs triggers.

---

## 9) Get your function URL (with key)

List functions:

```bash
az functionapp function list -g $RG -n $APP -o table
```

Get function keys:

```bash
az functionapp function keys list -g $RG -n $APP --function-name Hello
```

Use `default` key (value) as `code`:

```bash
URL="https://${APP}.azurewebsites.net/api/Hello?name=Cloud"
KEY=$(az functionapp function keys list -g $RG -n $APP --function-name Hello --query default -o tsv)

# Test deployed function:
curl "${URL}&code=${KEY}"
```

You should get the same greeting as local.

---

## (Optional) Change Authorization Level

The template uses `Function` by default. To switch to anonymous (no key) in C# isolated:

```csharp
[Function("Hello")]
public async Task<HttpResponseData> Run(
    [HttpTrigger(AuthorizationLevel.Anonymous, "get", "post")] HttpRequestData req)
{
    ...
}
```

Re-publish after changes:

```bash
dotnet publish -c Release
func azure functionapp publish $APP --dotnet-cli-params "--configuration Release"
```

---

## (Optional) Add another function quickly

```bash
func new --template "Timer trigger" --name EveryMinute
# Edit schedule in the generated attribute: "0 */1 * * * *" (every minute)
dotnet build
func start    # test locally
```

Publish again when ready:

```bash
func azure functionapp publish $APP --dotnet-cli-params "--configuration Release"
```

---

## (Optional) Set application settings from CLI

```bash
az functionapp config appsettings set -g $RG -n $APP \
  --settings "MySetting=HelloCloud"
```

Read them in code with `Environment.GetEnvironmentVariable("MySetting")`.

---

## Final Project Structure (after scaffold)

```ini
MyFuncApp/
‚îú‚îÄ host.json
‚îú‚îÄ local.settings.json          # local only
‚îú‚îÄ MyFuncApp.csproj
‚îú‚îÄ Program.cs
‚îú‚îÄ Hello.cs                     # HTTP trigger (your function)
‚îî‚îÄ bin/Release/net8.0/publish   # published output used for deploy
```

---

## Troubleshooting Quick Wins

- **401 Unauthorized** calling your deployed HTTP function
  ‚Üí You used `AuthorizationLevel.Function` but forgot the `code` query param (or header `x-functions-key`).

- **‚ÄúNo job functions found‚Äù / endpoint 404**
  ‚Üí Make sure you‚Äôre in the **project folder** (where `.csproj` lives) when running/publishing. Rebuild `dotnet publish -c Release`.

- **Local Storage errors**
  ‚Üí Start **Azurite** or set a real `AzureWebJobsStorage` in `local.settings.json`.
