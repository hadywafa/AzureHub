# ğŸ¤– MSAL â€” Client Credentials Flow

## ğŸ“– What it is

- An **OAuth 2.0 flow** where the **application authenticates itself** (no user involved).
- The app presents its **client ID + client secret** (or certificate).
- The Microsoft Identity Platform issues an **Access Token** with **application permissions** (app roles).
- The app can call **Microsoft Graph** or **custom APIs** directly.

---

## ğŸ§­ When to Use

âœ… Background jobs (cron, schedulers).  
âœ… Daemons / services with no user context.  
âœ… API-to-API calls (machine-to-machine).  
âœ… Admin tools that need org-wide data.

âŒ Not suitable for apps that require **delegated permissions** (user data).

---

## ğŸ”„ Flow Breakdown

<div align="center">

```mermaid
sequenceDiagram
    participant App
    participant MSAL
    participant Entra as Microsoft Identity Platform
    participant API as Graph/Custom API

    App->>MSAL: AcquireTokenForClient(scopes/.default)
    MSAL->>Entra: Client ID + Secret/Cert
    Entra-->>MSAL: Access Token (app roles)
    MSAL-->>App: AuthenticationResult
    App->>API: Call with Bearer Access Token
    API-->>App: Protected Data
```

</div>

---

## ğŸ“Œ Endpoints

- **Token endpoint**:
  `POST https://login.microsoftonline.com/{tenant}/oauth2/v2.0/token`

---

## ğŸ“Œ MSAL.NET Example â€” Daemon App

```csharp
using System;
using System.Threading.Tasks;
using Microsoft.Identity.Client;

class Program
{
    private static string tenantId = "<tenant_id>";
    private static string clientId = "<client_id>";
    private static string clientSecret = "<client_secret>";
    private static string[] scopes = { "https://graph.microsoft.com/.default" };

    static async Task Main(string[] args)
    {
        var app = ConfidentialClientApplicationBuilder.Create(clientId)
            .WithClientSecret(clientSecret)
            .WithAuthority(new Uri($"https://login.microsoftonline.com/{tenantId}"))
            .Build();

        try
        {
            var result = await app.AcquireTokenForClient(scopes).ExecuteAsync();
            Console.WriteLine("âœ… Access Token acquired:");
            Console.WriteLine(result.AccessToken);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"âŒ Error: {ex.Message}");
        }
    }
}
```

---

## ğŸ“Œ Important Details

- You must request the special scope:

  ```ini
  https://graph.microsoft.com/.default
  ```

  â¡ï¸ This means â€œgive me the **application roles** already granted via admin consentâ€.

- No `offline_access` or `refresh_token` â€” app just requests a new token when needed.

- Token contains `roles` claim (app roles), not `scp` (scopes).

---

## âš™ï¸ Creating Service Principal for App

Use **Azure CLI** to provision credentials:

```bash
az ad sp create-for-rbac --name "MyDaemonApp"
```

Output:

```json
{
  "appId": "11111111-2222-3333-4444-555555555555",
  "password": "super-secret-value",
  "tenant": "aaaa-bbbb-cccc-dddd"
}
```

- `appId` â†’ clientId
- `password` â†’ clientSecret
- `tenant` â†’ tenantId

---

## âœğŸ» Real-World Example

- A daemon that **syncs users** nightly:

  - App-only permission â†’ `User.Read.All` (application)
  - Admin must **grant consent** first
  - The app then calls Graph:

    ```http
    GET https://graph.microsoft.com/v1.0/users
    Authorization: Bearer <access_token>
    ```

---

## ğŸ“ Exam & Real-World Notes

- **Client Credentials Flow** = **no user** â†’ app identity only.
- Requires **Application permissions** in App Registration.
- Always needs **admin consent** (users canâ€™t consent app roles).
- Token claim: `roles` not `scp`.
- Best practice: Use **certificates instead of client secrets** in production.

---

## âœ… Quick Recap

- Public apps â†’ **delegated permissions** (users).
- Confidential apps + client credentials â†’ **app-only permissions** (services).
- Token request uses `.default` scope to grab admin-consented app roles.
- Daemons, APIs, machine-to-machine â†’ this is your go-to flow.
