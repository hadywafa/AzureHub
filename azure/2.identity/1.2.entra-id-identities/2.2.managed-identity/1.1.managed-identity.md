# 🧙‍♂️ Azure Managed Identities — Your Passwordless Sidekick

> “Why store secrets in code when Azure can manage them for you?” — A happy, secure developer somewhere.

---

<div align="center">
  <img src="image/managed-identity.png" alt="Managed Identity" style="width: 100%; border-radius: 10px;border: 2px solid">
</div>

---

## 🌟 What Are Managed Identities?

A **Managed Identity (MI)** is just a **special Service Principal** that Azure creates and manages **for you**.

- Used by **Azure resources** (VM, App Service, Functions, etc.)
- Removes the need for you to handle Client ID + Secret.
- Rotation, creation, deletion → handled by Azure.

---

## 🤹‍♀️ Types of Managed Identities

| Type                | Scope                              | Lifecycle        | Example Use Case                          |
| ------------------- | ---------------------------------- | ---------------- | ----------------------------------------- |
| **System-assigned** | Tied to _one_ Azure resource       | Same as resource | Azure VM reads from Key Vault             |
| **User-assigned**   | Created as a _standalone_ identity | Independent      | One identity shared across many Functions |

---

## 🎯 Use Cases

- Azure Function accessing Azure SQL, Blob, Key Vault
- Azure VM pulling config from App Configuration
- Azure Container Apps fetching secrets securely
- Azure Logic Apps calling protected APIs

---

## 🧪 Real-World Example

> Let's say your app hosted in **Azure App Service** needs to pull secrets from **Azure Key Vault**.

With managed identity:

- No client ID
- No client secret
- No password rotation
- No leaks in GitHub 😬

---

## 🧬 Flow Diagram (Mermaid Style)

```mermaid
sequenceDiagram
    participant App as Azure App Service
    participant MI as Managed Identity
    participant Entra as Microsoft Entra ID
    participant KV as Azure Key Vault

    App->>MI: Request token for Key Vault
    MI->>Entra: Authenticate
    Entra-->>MI: Issue access token (scoped to Key Vault)
    MI-->>App: Return token
    App->>KV: Call API with token
    KV-->>App: Returns secrets
```

---

## 🧑‍💻 Example Code (C# — Key Vault Access)

```csharp
var credential = new DefaultAzureCredential(); // Automatically uses Managed Identity
var client = new SecretClient(new Uri("https://my-keyvault.vault.azure.net/"), credential);
KeyVaultSecret secret = await client.GetSecretAsync("ConnectionString");
Console.WriteLine(secret.Value);
```

✅ No credentials
✅ Works on VMs, Functions, App Services, AKS, Logic Apps
✅ Secure-by-default

---

## 🏗️ How to Enable It?

### 🔹 For System-Assigned MI

1. Go to your Azure resource (e.g., VM or Function)
2. Navigate to **Identity → System Assigned**
3. Set status to **On**
4. Azure creates a managed identity behind the scenes

### 🔹 For User-Assigned MI

1. Go to **Microsoft Entra ID → Managed Identities**
2. Click **New user-assigned identity**
3. Assign it to **multiple resources**

---

## 🔑 Assigning Permissions

> Managed Identities work by getting **Microsoft Entra tokens**, so they need permissions!

You assign roles using **Azure RBAC** (not App RBAC):

```bash
# Give your MI access to Key Vault as Reader
az role assignment create \
  --assignee "<managed-identity-id>" \
  --role "Key Vault Secrets User" \
  --scope "/subscriptions/<sub>/resourceGroups/<rg>/providers/Microsoft.KeyVault/vaults/<kv>"
```

---

## 🛂 Token Under the Hood

When a resource with a managed identity requests a token:

- It hits the **Instance Metadata Service (IMDS)** endpoint:

  ```ini
  GET http://169.254.169.254/metadata/identity/oauth2/token
  ```

- Azure Entra issues a token for the **target resource**, like:

  - Key Vault → `https://vault.azure.net`
  - Azure Resource Manager → `https://management.azure.com`

---

## 🧠 Important Notes

| Feature                    | System-assigned          | User-assigned            |
| -------------------------- | ------------------------ | ------------------------ |
| Tied to a single resource  | ✅ Yes                   | ❌ No                    |
| Reusable across services   | ❌ No                    | ✅ Yes                   |
| Survives resource deletion | ❌ No                    | ✅ Yes                   |
| Works with Kubernetes      | ✅ AKS workload identity | ✅ AKS workload identity |
| Assign roles (RBAC)        | ✅ via Azure RBAC        | ✅ via Azure RBAC        |

---

## 🏠 Application Identities vs 🏪 Managed Identities

| Feature                  | **Application Identity (Service Principal)** | **Managed Identity**                            |
| ------------------------ | -------------------------------------------- | ----------------------------------------------- |
| **Hosted Where?**        | Anywhere (on-prem, other cloud, or Azure)    | Only for Azure-hosted services (VMs, Functions) |
| **Credential Type**      | Client ID + Secret/Certificate               | No secrets – uses platform-level identity       |
| **When to Use**          | Custom apps, scripts, integrations, CI/CD    | Azure-native automation                         |
| **Used in OAuth2 Grant** | Client Credentials, Authorization Code       | Works natively without OAuth2 flow              |
| **Security Management**  | You manage secrets or certs                  | Azure rotates credentials automatically         |
| **Provisioned From**     | App Registration                             | Enabled directly on resource (e.g., VM)         |

---

## 🧠 Final Takeaways

- Use **Managed Identity** whenever Azure resources need to access each other securely.
- Forget about storing secrets in code. Use **DefaultAzureCredential** and let Azure do the rest.
- Prefer **User-assigned** MI for reusable identities across resources.
- No more `client_id` / `client_secret` headaches.
- Use Azure RBAC to **grant fine-grained access** to each resource.
