# ğŸ§™â€â™‚ï¸ Azure Managed Identities â€” Your Passwordless Sidekick

> â€œWhy store secrets in code when Azure can manage them for you?â€ â€” A happy, secure developer somewhere.

---

<div align="center">
  <img src="image/1.1.managed-identity/managed-identity.png" alt="Managed Identity" style="width: 100%; border-radius: 10px;border: 2px solid">
</div>

---

## ğŸŒŸ What Are Managed Identities?

A **Managed Identity (MI)** is just a **special Service Principal** that Azure creates and manages **for you**.

- Used by **Azure resources** (VM, App Service, Functions, etc.)
- Removes the need for you to handle Client ID + Secret.
- Rotation, creation, deletion â†’ handled by Azure.

---

## ğŸ¤¹â€â™€ï¸ Types of Managed Identities

| Type                | Scope                              | Lifecycle        | Example Use Case                          |
| ------------------- | ---------------------------------- | ---------------- | ----------------------------------------- |
| **System-assigned** | Tied to _one_ Azure resource       | Same as resource | Azure VM reads from Key Vault             |
| **User-assigned**   | Created as a _standalone_ identity | Independent      | One identity shared across many Functions |

---

<div align="center">
  <img src="image/1.1.managed-identity/1758174633234.png" alt="Managed Identity" style="width: 100%; border-radius: 10px;border: 2px solid">
</div>

---

## ğŸ¯ Use Cases

Managed identities are particularly useful when you need Azure resourcesâ€”such as virtual machines, App Services, Container Instances, Container Apps, or Azure Kubernetes Serviceâ€”to access other Azure services securely and without manual credential management. Any service supporting Azure AD (or Microsoft Entra ID) authentication can benefit from this setup.

<div align="center">
  <img src="image/1.1.managed-identity/1758175183974.png" alt="Managed Identity" style="width: 100%; border-radius: 10px;border: 2px solid">
</div>

Example:

- Azure Function accessing Azure SQL, Blob, Key Vault
- Azure VM pulling config from App Configuration
- Azure Container Apps fetching secrets securely
- Azure Logic Apps calling protected APIs

---

## ğŸ§ª Real-World Example

> Let's say your app hosted in **Azure App Service** needs to pull secrets from **Azure Key Vault**.

With managed identity:

- No client ID
- No client secret
- No password rotation
- No leaks in GitHub ğŸ˜¬

---

## ğŸ§¬ Flow Diagram (Mermaid Style)

<div align="center">

```mermaid
sequenceDiagram
    participant App as Azure App Service
    participant MI as Managed Identity
    participant Entra as Microsoft Entra ID
    participant KV as Azure Key Vault

    App->>MI: Request token for Key Vault
    MI->>Entra: Authenticate
    Entra-->>MI: Issue access token (scoped to Key Vault)
    MI-->>App: Return token
    App->>KV: Call API with token
    KV-->>App: Returns secrets
```

</div>

---

## ğŸ§‘â€ğŸ’» Example Code (C# â€” Key Vault Access)

```csharp
var credential = new DefaultAzureCredential(); // Automatically uses Managed Identity
var client = new SecretClient(new Uri("https://my-keyvault.vault.azure.net/"), credential);
KeyVaultSecret secret = await client.GetSecretAsync("ConnectionString");
Console.WriteLine(secret.Value);
```

âœ… No credentials  
âœ… Works on VMs, Functions, App Services, AKS, Logic Apps  
âœ… Secure-by-default

---

## ğŸ—ï¸ How to Enable It?

### ğŸ”¹ For System-Assigned MI

1. Go to your Azure resource (e.g., VM or Function)
2. Navigate to **Identity â†’ System Assigned**
3. Set status to **On**
4. Azure creates a managed identity behind the scenes

### ğŸ”¹ For User-Assigned MI

1. Go to **Microsoft Entra ID â†’ Managed Identities**
2. Click **New user-assigned identity**
3. Assign it to **multiple resources**

---

## ğŸ”‘ Assigning Permissions

> Managed Identities work by getting **Microsoft Entra tokens**, so they need permissions!

You assign roles using **Azure RBAC** (not App RBAC):

```bash
# Give your MI access to Key Vault as Reader
az role assignment create \
  --assignee "<managed-identity-id>" \
  --role "Key Vault Secrets User" \
  --scope "/subscriptions/<sub>/resourceGroups/<rg>/providers/Microsoft.KeyVault/vaults/<kv>"
```

---

## ğŸ•³ï¸ Managed Identity are SP behind the scene

**Managed Identities in Azure are essentially _specialized service principals_ that Azure creates and manages for you.**

---

### ğŸ” How It Works

- **Service Principal Basics:**  
  A service principal is an identity in Microsoft Entra ID (Azure AD) that apps, scripts, or services use to authenticate. Normally, you create one manually and assign it credentials (client secret or certificate).

- **Managed Identity Relationship:**  
  When you enable a **Managed Identity** for an Azure resource (like a VM, Function, or App Service), Azure automatically provisions a **service principal in Entra ID** behind the scenes.

  - This service principal is tied to the lifecycle of the resource.
  - Azure rotates its credentials automatically.
  - You donâ€™t see or manage the secret/certificate â€” Azure handles it.

- **Credential Flow:**
  - The resource requests a token from the **Azure Instance Metadata Service (IMDS)**.
  - IMDS issues a short-lived OAuth 2.0 token using the hidden service principal.
  - The resource then uses this token to access Azure services (e.g., Key Vault, Storage).

---

### âš–ï¸ Comparison: Service Principal vs Managed Identity

| Feature                   | Service Principal                     | Managed Identity                                    |
| ------------------------- | ------------------------------------- | --------------------------------------------------- |
| **Creation**              | Manual (you register app in Entra ID) | Automatic (Azure creates it for the resource)       |
| **Credential Management** | You manage secrets/certs              | Azure auto-rotates credentials                      |
| **Lifecycle**             | Independent of resource               | Bound to resource lifecycle                         |
| **Use Case**              | Cross-platform apps, external scripts | Azure-native resources (VMs, Functions, Logic Apps) |

---

### ğŸ¯ Key Takeaway

- **Managed Identity = Service Principal + Automation.**
- Itâ€™s the same underlying identity type, but Azure abstracts away the credential management.
- If you delete the resource, its managed identity (service principal) is also deleted.

---

## ğŸ›‚ Token Under the Hood

The managed identity authentication flow involves several key steps:

### 1ï¸âƒ£ Enable Managed Identity

Azure Resource Manager (ARM) receives a request to enable a system-assigned managed identity on a virtual machine (or any resource that supports managed identities).

### 2ï¸âƒ£ Service Principal Creation

Once enabled, a service principal is automatically generated in Microsoft Entra ID (formerly Azure Active Directory) for the virtual machineâ€™s identity.

### 3ï¸âƒ£ VM Configuration Update

ARM configures the virtual machine by updating the Azure Instance Metadata Service with the newly created service principal's client ID and certificate.

### 4ï¸âƒ£ Resource Access Provisioning

With the virtual machine now equipped with an identity, the service principal can be used to grant access to additional Azure resources.

### 5ï¸âƒ£ Token Request

The code running on the virtual machine requests an access token from the Azure Instance Metadata Service endpoint, which is accessible only internally.

- It hits the **Instance Metadata Service (IMDS)** endpoint:

  ```ini
  GET http://169.254.169.254/metadata/identity/oauth2/token
  ```

### 6ï¸âƒ£ JWT Acquisition

The access token is then used to contact Microsoft Entra ID to retrieve a JSON Web Token (JWT) using the pre-configured client ID and certificate.

### 7ï¸âƒ£Resource Access

Finally, your application sends the JWT to services that support Microsoft Entra Authenticationâ€”such as Azure Key Vault or Azure Blob Storageâ€”to access the required resources.

---

> ğŸš¨ The header Metadata: true must be set to retrieve a token from the managed identity metadata service endpoint.
>
> <div align="left">
>   <img src="image/1.1.managed-identity/1758183176950.png" alt="Managed Identity Flow" style="width: 40%; border-radius: 10px; border: 2px solid">
> </div>

---

## ğŸ§  Important Notes

| Feature                    | System-assigned          | User-assigned            |
| -------------------------- | ------------------------ | ------------------------ |
| Tied to a single resource  | âœ… Yes                   | âŒ No                    |
| Reusable across services   | âŒ No                    | âœ… Yes                   |
| Survives resource deletion | âŒ No                    | âœ… Yes                   |
| Works with Kubernetes      | âœ… AKS workload identity | âœ… AKS workload identity |
| Assign roles (RBAC)        | âœ… via Azure RBAC        | âœ… via Azure RBAC        |

---

## ğŸ  Application Identities vs ğŸª Managed Identities

| Feature                  | **Application Identity (Service Principal)** | **Managed Identity**                            |
| ------------------------ | -------------------------------------------- | ----------------------------------------------- |
| **Hosted Where?**        | Anywhere (on-prem, other cloud, or Azure)    | Only for Azure-hosted services (VMs, Functions) |
| **Credential Type**      | Client ID + Secret/Certificate               | No secrets â€“ uses platform-level identity       |
| **When to Use**          | Custom apps, scripts, integrations, CI/CD    | Azure-native automation                         |
| **Used in OAuth2 Grant** | Client Credentials, Authorization Code       | Works natively without OAuth2 flow              |
| **Security Management**  | You manage secrets or certs                  | Azure rotates credentials automatically         |
| **Provisioned From**     | App Registration                             | Enabled directly on resource (e.g., VM)         |

---

## ğŸ§  Final Takeaways

- Use **Managed Identity** whenever Azure resources need to access each other securely.
- Forget about storing secrets in code. Use **DefaultAzureCredential** and let Azure do the rest.
- Prefer **User-assigned** MI for reusable identities across resources.
- No more `client_id` / `client_secret` headaches.
- Use Azure RBAC to **grant fine-grained access** to each resource.
