# ✍🏻 **Lab: Use Azure Artifacts Upstream Sources (NuGet + npm)**

## 🎯 **Goal**

- Configure a feed with **Upstream Sources** (e.g., **NuGet.org**, **npmjs**).
- Restore public packages **through your private feed** (first time: fetch & cache → next time: served from your feed).
- Lock down builds so they **don’t hit the public internet** directly.

---

## 🧰 **Prerequisites**

- Azure DevOps **organization + project**.
- **Azure Artifacts** enabled.
- A test repo with a simple .NET project that uses a **public NuGet dependency** (e.g., `Newtonsoft.Json`).

  - If you don’t have one, create it quickly:

    ```bash
    mkdir upstream-demo && cd upstream-demo \
    dotnet new console -n Demo.App \
    dotnet sln -n Demo add Demo.App/Demo.App.csproj \
    dotnet add Demo.App package Newtonsoft.Json --version 13.0.3
    ```

---

## 1. 🏗 **Create a Feed and Enable Upstream**

1. Azure DevOps → **Artifacts** → **+ Create Feed**

   - Name: `org-cache` (example)
   - Visibility: **Project** (or **Organization** if many projects will share)

2. Feed → **⚙ Settings** → **Upstream sources** → **Add upstream**

   - Choose **NuGet.org** (for .NET).
   - (Optional) add **npmjs**, **Maven Central**, **PyPI** if you’ll need them later.

3. **Save**.

> 💡 **What this does:**  
> when your build asks for `Newtonsoft.Json`, the feed fetches it **once** from NuGet.org and **caches** that exact version. Subsequent restores are **served by your feed**—faster, consistent, and resilient.

---

## 2. 🔐 **Force Restores Through Your Feed**

Create a `NuGet.config` at the **solution root** of your repo:

```xml
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <packageSources>
    <!-- IMPORTANT: Rely on Azure Artifacts feed; omit nuget.org here -->
    <add key="org-cache" value="https://pkgs.dev.azure.com/ORG/PROJECT/_packaging/org-cache/nuget/v3/index.json" />
  </packageSources>
  <packageSourceMapping>
    <!-- (Optional) Map sources to packages to guarantee routing -->
    <packageSource key="org-cache">
      <package pattern="*" />
    </packageSource>
  </packageSourceMapping>
</configuration>
```

> ✅ This ensures **all packages** resolve via your feed.  
> ❌ Do **not** include `https://api.nuget.org/v3/index.json` in this config for the lab.

Commit this file to your repo.

---

## 3. 🧪 **First Build (Priming the Cache)**

### Local (optional quick check)

If you’ve added the feed as a source locally:

```bash
dotnet nuget add source "https://pkgs.dev.azure.com/ORG/PROJECT/_packaging/org-cache/nuget/v3/index.json" --name org-cache \
dotnet restore
```

- Expected: restore succeeds, **feed fetches `Newtonsoft.Json` from NuGet.org** and **caches** it.

### CI (preferred)

Create **azure-pipelines.yml**:

```yaml
trigger:
  - main

pool:
  vmImage: "windows-latest"

steps:
  - task: UseDotNet@2
    inputs:
      packageType: "sdk"
      version: "8.x"

  # This injects credentials so the agent can read your private feed
  - task: NuGetAuthenticate@1
    displayName: Authenticate to Azure Artifacts

  - script: dotnet restore
    displayName: Restore (via feed)

  - script: dotnet build -c Release --no-restore
    displayName: Build
```

Run the pipeline.  
**Result:** The first run will **prime** the cache in your feed for all resolved packages (e.g., `Newtonsoft.Json`).

---

## 4. 🔁 **Second Build (Cache Hit)**

- Run the pipeline **again**.
- This time, the restore should be **faster**, and **no external NuGet.org calls** are needed:

  - The feed **serves from its cache**.

### Verify in the portal

- Go to Artifacts → your feed `org-cache` → **Packages**.
  You should see entries like `Newtonsoft.Json` (pulled via upstream).
- You can also check **Downloads**/**Versions** and see **Provenance** indicating an **upstream source**.

---

## 5. 🔒 **Prove Isolation (No Public Internet Directly)**

**Hard mode test** (optional but great for governance):

- In your `NuGet.config`, confirm there is **only your feed** as a source.
- In a controlled environment (self-hosted agent, corporate network, or a temporary firewall rule), **block access** to `api.nuget.org` but **allow** `pkgs.dev.azure.com`.
- Run the pipeline.

  - It should still succeed because packages are now served from **your feed** (cache).
  - If it tries to go public, it will fail—this is how you catch misconfigurations.

> 🛡 Bonus governance: In Azure DevOps, use **Service Connections/Firewall policies** or **private link** (advanced) to limit egress and ensure supply-chain control.

---

## 6. (Optional) Use **Views** with Upstream Packages

- Enable **Views** (Settings → Views).
- Consumers typically point to `@release` view.
- When an upstream package is cached, you can **promote** specific versions to `@release` to **control what’s consumable** by the org.
- Consumers reference:
  `https://pkgs.dev.azure.com/ORG/PROJECT/_packaging/org-cache@release/nuget/v3/index.json`

> This gives you **curation** over what public packages are allowed.

---

## 7. 🧹 **Retention & Cleanup**

- Feed Settings → **Retention**:

  - Keep only **N** versions.
  - Remove **unused upstream** versions after X days.

- This keeps the cache tight and storage costs down.

---

## 8. 🛠 **Troubleshooting**

- **401/403 during restore**

  - Make sure `NuGetAuthenticate@1` is before `dotnet restore` in CI.
  - Check feed **Permissions**: your build identity (Project Build Service) needs **Reader**.

- **It still hits nuget.org**

  - Ensure `NuGet.config` **does not include** nuget.org.
  - Use **packageSourceMapping** to force everything to `org-cache`.
  - Verify you’re restoring **from repo root** (where `NuGet.config` lives).

- **Package not visible**

  - You may be looking at a **view** (e.g., `@release`) that doesn’t have it promoted yet; check `@local` or promote it.

---

## 📦 **npm Variant (Quick)**

### Add npm upstream

- Feed → **Settings** → **Upstream sources** → **Add** → **npmjs**.

### Create Node demo

```bash
mkdir node-upstream && cd node-upstream \
npm init -y \
npm install dayjs
```

### Use pipeline with feed auth

```yaml
pool:
  vmImage: "ubuntu-latest"

steps:
  - task: NodeTool@0
    inputs:
      versionSpec: "18.x"

  # Writes an authenticated .npmrc for the job
  - task: npmAuthenticate@0
    inputs:
      workingFile: "$(Build.SourcesDirectory)/.npmrc"
      # If you want to force using your feed registry, you can echo registry line below

  - script: |
      echo "registry=https://pkgs.dev.azure.com/ORG/_packaging/org-cache/npm/registry/" >> .npmrc
      npm ci
    displayName: npm ci via feed
```

Run twice:

- First run: `dayjs` fetched from **npmjs** and cached in your feed.
- Second run: served **from your feed** (faster, isolated).

> For production: **do not** leave the public registry in `.npmrc`; use only your feed’s registry URL.

---

## ✅ **What You’ve Proved**

- **Upstream sources** let your org **cache and control** public dependencies.
- Builds **only need your feed**, not the public internet.
- **Second restores are faster** and **reliable** (supply-chain resilience).
- You can **curate** allowed versions via **Views** and manage cache via **Retention**.

---

## 🧪 **Nice Extensions (optional)**

- Add **SBOM + dependency scanning** (e.g., GitHub Advanced Security, Defender for DevOps).
- Add **policy**: consumers may only use `@release` view.
- Use **packageSourceMapping** to route only certain packages to certain feeds (multi-feed governance).
- For **Maven/Python**, repeat the same pattern using `MavenAuthenticate@0`, `PipAuthenticate@1` + `TwineAuthenticate@1`.
