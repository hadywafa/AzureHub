# ğŸ§ª **Project: Unit Testing in Azure Pipelines**

## ğŸ“Œ **1. Project Structure**

```plaintext
MySolution/
 â”œâ”€â”€ src/
 â”‚    â””â”€â”€ MyApi/
 â”‚         â”œâ”€â”€ MyApi.csproj
 â”‚         â””â”€â”€ Calculator.cs   # business logic
 â”œâ”€â”€ tests/
 â”‚    â””â”€â”€ MyApi.UnitTests/
 â”‚         â”œâ”€â”€ MyApi.UnitTests.csproj
 â”‚         â””â”€â”€ CalculatorTests.cs
 â””â”€â”€ azure-pipelines.yml       # CI pipeline
```

---

## ğŸ“Œ **2. The Application Code (Example)**

`src/MyApi/Calculator.cs`

```csharp
namespace MyApi
{
    public class Calculator
    {
        public int Add(int a, int b) => a + b;
        public int Divide(int a, int b)
        {
            if (b == 0) throw new DivideByZeroException();
            return a / b;
        }
    }
}
```

---

## ğŸ“Œ **3. Unit Test Project**

`tests/MyApi.UnitTests/CalculatorTests.cs`

```csharp
using Xunit;
using MyApi;

namespace MyApi.UnitTests
{
    public class CalculatorTests
    {
        private readonly Calculator _calc = new();

        [Fact]
        public void Add_ShouldReturnCorrectSum()
        {
            var result = _calc.Add(2, 3);
            Assert.Equal(5, result);
        }

        [Fact]
        public void Divide_ByZero_ShouldThrow()
        {
            Assert.Throws<DivideByZeroException>(() => _calc.Divide(10, 0));
        }
    }
}
```

âœ… If any `Assert` fails â†’ test fails â†’ pipeline fails.

---

## ğŸ“Œ **4. Azure Pipeline (CI)**

`azure-pipelines.yml`

```yaml
trigger:
  - main # Run on commits to main branch

pool:
  vmImage: "windows-latest"

stages:
  - stage: BuildAndTest
    jobs:
      - job: RunUnitTests
        steps:
          - task: UseDotNet@2
            inputs:
              packageType: "sdk"
              version: "8.0.x"

          - script: dotnet restore MySolution.sln
            displayName: "Restore"

          - script: dotnet build MySolution.sln --configuration Release --no-restore
            displayName: "Build"

          - script: >
              dotnet test tests/MyApi.UnitTests/MyApi.UnitTests.csproj
              --configuration Release
              --no-build
              --logger "trx;LogFileName=unit.trx"
              --results-directory $(Common.TestResultsDirectory)
            displayName: "Run unit tests"

          # (no need to set continueOnError: false â€” default is already fail on non-zero)
          - task: PublishTestResults@2
            displayName: "Publish test results"
            condition: always()
            inputs:
              testResultsFiles: "$(Common.TestResultsDirectory)/**/*.trx"
              testRunTitle: "Unit Tests"
```

---

## ğŸ“Œ **5. How it Works**

1. **Pipeline runs on commit** â†’ installs .NET SDK.
2. **dotnet restore & build** â†’ compile code.
3. **dotnet test** runs unit tests:

   - If any test fails â†’ exit code â‰  0 â†’ job fails â†’ pipeline **fails immediately** ğŸš¨.
   - No need for special config â€” `dotnet test` failure is enough.

4. **PublishTestResults** uploads test reports â†’ visible in **Azure DevOps â€œTestsâ€ tab**.

> ğŸ’¡ By default, every task runs under the condition `succeeded()`.  
> If the test step failed, the next task **wonâ€™t run** unless you override the condition.
>
> - `condition: always()` â†’ runs even if the previous step failed.

---

## ğŸ“Œ **6. Example Failing Pipeline**

- Code bug:

  ```csharp
  public int Add(int a, int b) => a - b;  // wrong
  ```

- Test `Add_ShouldReturnCorrectSum` fails.
- Pipeline output:

  ```ini
  X Add_ShouldReturnCorrectSum [123 ms]
    Expected: 5
    Actual: -1
  ```

- **Pipeline job = failed ğŸ”´**.

---

## ğŸ“Œ **7. Best Practices**

- âœ… Keep **unit tests fast & isolated** (no DB, no HTTP).
- âœ… Always run unit tests in **CI pipeline**.
- âœ… Block merges if tests fail (branch policies).
- âœ… Use **coverage tools** (e.g., `coverlet`) for metrics.
- âœ… Publish results so team can see failures in Azure DevOps UI.

---

## ğŸ **TL;DR**

- **Unit tests** = smallest building block, testing functions/classes in isolation.
- In **Azure Pipelines**, just add a `dotnet test` step.
- If **tests fail â†’ pipeline fails automatically**.
- Add **PublishTestResults\@2** for visibility in Azure DevOps.
