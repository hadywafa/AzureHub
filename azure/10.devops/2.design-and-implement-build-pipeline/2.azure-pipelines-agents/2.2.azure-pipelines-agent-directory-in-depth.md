# üìÇ **Azure Agent Working Directories**

## üìå **1. The agent‚Äôs folder layout (hosted & self-hosted)**

> - On a Microsoft-hosted Linux agent (Ubuntu), the agent root is typically `/home/vsts/` and the working root is `/home/vsts/work`.
> - On Windows hosted agents, think `C:\agent\` (self-hosted) or `C:\agent\_work` style paths (conceptually the same layout).

Inside the working root (`_work`) Azure Pipelines creates a **numeric pipeline directory** per run, e.g. `_work/1`, `_work/2`, etc. Under that number you get:

- `s/` ‚Äì **Sources** (your repo after `checkout`)
- `b/` ‚Äì **Binaries** you build
- `a/` ‚Äì **Artifacts** (staging/output)
- `TestResults/` ‚Äì Test output (e.g., trx, junit)
- (root of the number, e.g. `_work/1`) ‚Äì **Pipeline workspace** used as a base for jobs

Two special siblings under `_work`:

- `_temp/` ‚Äì Temp files for the current agent
- `_tool/` ‚Äì Tool cache (where tool installers place SDKs/CLIs)

Typical hosted Ubuntu example:

```ini
/home/vsts/work/
  ‚îú‚îÄ 1/                    # Pipeline.Workspace
  ‚îÇ   ‚îú‚îÄ s/                # Build.SourcesDirectory / System.DefaultWorkingDirectory
  ‚îÇ   ‚îú‚îÄ b/                # Build.BinariesDirectory
  ‚îÇ   ‚îú‚îÄ a/                # Build.ArtifactStagingDirectory / System.ArtifactsDirectory
  ‚îÇ   ‚îî‚îÄ TestResults/      # Common.TestResultsDirectory
  ‚îú‚îÄ _temp/                # Agent.TempDirectory
  ‚îî‚îÄ _tool/                # Agent.ToolsDirectory
```

---

## üìå **2. The default working directory for jobs & tasks**

- **Jobs** start with the **pipeline workspace** in scope:
  - `$(Pipeline.Workspace)` ‚Üí typically the numbered folder (e.g. `/home/vsts/work/1`).
- **Tasks / script steps** default to your **sources folder**:

  - `$(System.DefaultWorkingDirectory)` = `$(Build.SourcesDirectory)` = `‚Ä¶/work/1/s`

- Unless you override `workingDirectory:` on a task/step, your scripts run from `‚Ä¶/s`.

Useful mental model:

- **Workspace** = the run‚Äôs root (number folder)
- **Default working dir for steps** = the `s` folder in that workspace

---

## üìå **3. The important built-in variables (what they mean and where they point)**

| Variable                                         | What it means                                     | Typical hosted Windows path        | Typical hosted Ubuntu path          |
| ------------------------------------------------ | ------------------------------------------------- | ---------------------------------- | ----------------------------------- |
| `$(Agent.HomeDirectory)`                         | Agent install/home                                | `C:\agent`                         | `/home/vsts/`                       |
| `$(Agent.RootDirectory)` / `$(Agent.WorkFolder)` | Root for work folders                             | `C:\agent\_work`                   | `/home/vsts/work`                   |
| `$(Pipeline.Workspace)`                          | **Root for the current run**; base for jobs       | `C:\agent\_work\1`                 | `/home/vsts/work/1`                 |
| `$(System.DefaultWorkingDirectory)`              | **Default working dir for steps**; equals sources | `C:\agent\_work\1\s`               | `/home/vsts/work/1/s`               |
| `$(Build.SourcesDirectory)`                      | Primary repo checkout path                        | `C:\agent\_work\1\s` (single-repo) | `/home/vsts/work/1/s` (single-repo) |
| `$(Build.BinariesDirectory)`                     | Where you put compiled output                     | `C:\agent\_work\1\b`               | `/home/vsts/work/1/b`               |
| `$(Build.ArtifactStagingDirectory)`              | Where you stage artifacts                         | `C:\agent\_work\1\a`               | `/home/vsts/work/1/a`               |
| `$(System.ArtifactsDirectory)`                   | Same concept as above (multi-stage friendly)      | `C:\agent\_work\1\a`               | `/home/vsts/work/1/a`               |
| `$(Common.TestResultsDirectory)`                 | Default tests output folder                       | `C:\agent\_work\1\TestResults`     | `/home/vsts/work/1/TestResults`     |
| `$(Agent.TempDirectory)`                         | Temp files for the agent                          | `C:\agent\_work\_temp`             | `/home/vsts/work/_temp`             |
| `$(Agent.ToolsDirectory)`                        | Tool cache (used by tool installers)              | `C:\agent\_work\_tool`             | `/home/vsts/work/_tool`             |

Quick echo snippet you can drop into a job to ‚Äúsee‚Äù it live:

```yaml
- script: |
    echo Pipeline.Workspace = $(Pipeline.Workspace)
    echo System.DefaultWorkingDirectory = $(System.DefaultWorkingDirectory)
    echo Build.SourcesDirectory = $(Build.SourcesDirectory)
    echo Build.BinariesDirectory = $(Build.BinariesDirectory)
    echo Build.ArtifactStagingDirectory = $(Build.ArtifactStagingDirectory)
    echo Common.TestResultsDirectory = $(Common.TestResultsDirectory)
    echo Agent.TempDirectory = $(Agent.TempDirectory)
    echo Agent.ToolsDirectory = $(Agent.ToolsDirectory)
  displayName: Print key directories
```

---

## üìå **4. Multi-repo checkout layout (important gotcha)**

Normally, your pipeline pulls code from **one repo**. But sometimes you need code from **multiple repos** ‚Äî like shared tools, Terraform modules, or Helm charts.

Azure DevOps lets you **checkout multiple repos** into your pipeline.

---

### ‚öôÔ∏è How Does It Work?

When you checkout multiple repos:

- Your **main repo** goes into:  
  `$(Build.SourcesDirectory)` ‚Üí usually `.../s/`

- Each **extra repo** goes into:  
  `.../s/<RepoName>`  
  or a custom folder if you set `path:`.

### ‚úÖ Simple Example

```yaml
resources:
  repositories:
    - repository: sharedTools
      type: git
      name: DevOps/shared-tools

jobs:
  - job: BuildJob
    steps:
      - checkout: self # Your main repo
      - checkout: sharedTools # Extra repo

      - script: |
          echo "Main repo: $(Build.SourcesDirectory)"
          echo "Shared tools: $(Pipeline.Workspace)/s/sharedTools"
```

#### üóÇ Folder Layout

```ini
/home/vsts/work/1/s/
  ‚îú‚îÄ (your main repo files)
  ‚îî‚îÄ sharedTools/        ‚Üê extra repo
```

### üõ†Ô∏è Custom Folder Name

You can choose where the extra repo goes:

```yaml
- checkout: sharedTools
  path: tools/
```

Now it lands in:

```ini
/home/vsts/work/1/s/tools/
```

### ‚úçüèª Real-World Use Case: DevOps Modularization

Imagine you're building a CI/CD pipeline for a microservice, and you want to:

- Use a shared **Helm chart repo**
- Pull in **Terraform modules**
- Keep your app repo clean

```yaml
resources:
  repositories:
    - repository: helmRepo
      type: git
      name: DevOps/helm-charts
    - repository: tfModules
      type: git
      name: Infra/terraform-modules

jobs:
  - job: DeployJob
    steps:
      - checkout: self
      - checkout: helmRepo
        path: helm/
      - checkout: tfModules
        path: terraform/

      - script: |
          helm lint helm/mychart
          terraform init terraform/network
```

This structure keeps your pipeline clean, modular, and scalable ‚Äî perfect for your architectural mindset.

## üîë Key Tips

- Use `$(Pipeline.Workspace)/s/<folder>` to access extra repos.
- Your scripts run from the main repo folder by default.
- Always use variables ‚Äî never hardcode paths.

---

## üìå **5. Where should you put things?**

Azure gives you **special folders** for different types of files. You should use them instead of dumping everything into one place. Why? It keeps your pipeline clean, makes publishing artifacts easier, and helps tasks like test reporting work automatically.

### üì¶ What Goes Where?

Here‚Äôs a simple cheat sheet:

| Type of File        | Recommended Folder Variable                                                     | Why Use It?                                           |
| ------------------- | ------------------------------------------------------------------------------- | ----------------------------------------------------- |
| **Build output**    | `$(Build.BinariesDirectory)` ‚Üí `/b`                                             | Keeps compiled files separate from source code        |
| **Artifacts**       | `$(Build.ArtifactStagingDirectory)` ‚Üí `/a`<br>or `$(System.ArtifactsDirectory)` | Makes it easy to publish and share across stages      |
| **Test results**    | `$(Common.TestResultsDirectory)` ‚Üí `/TestResults`                               | Lets Azure automatically find and report test results |
| **Temporary files** | `$(Agent.TempDirectory)` ‚Üí `/_temp`                                             | Scratch space for logs, zips, or cleanup files        |

### üß™ Example: Organizing a Build

```yaml
- script: dotnet build MyApp.sln -o $(Build.BinariesDirectory)
  displayName: Build the app

- script: cp $(Build.BinariesDirectory)/*.dll $(Build.ArtifactStagingDirectory)
  displayName: Stage DLLs for publishing

- task: PublishBuildArtifacts@1
  inputs:
    pathToPublish: $(Build.ArtifactStagingDirectory)
    artifactName: drop
```

#### What‚Äôs happening here?

- You build into `/b` (binaries folder)
- You copy the output into `/a` (artifact staging)
- You publish from `/a` so it‚Äôs available in later stages or downloads

### üß™ Example: Running Tests

```yaml
- script: dotnet test MyApp.Tests.csproj --logger "trx;LogFileName=testresults.trx" --results-directory $(Common.TestResultsDirectory)
  displayName: Run tests

- task: PublishTestResults@2
  inputs:
    testResultsFiles: "**/*.trx"
    testResultsFormat: VSTest
```

This puts test results into `/TestResults`, and Azure DevOps picks them up automatically.

### üß† Pro Tips

- Always use the **built-in variables** ‚Äî they work across Windows, Linux, containers, and hosted agents.
- If you have **multiple jobs**, create subfolders inside `/b` or `/a` to avoid overwriting each other.
- Don‚Äôt mix source code with build output ‚Äî it slows down archiving and makes debugging harder.

---

## üìå **6. Container jobs: mounts and paths**

When you run a **container job** (`container:` at the job level), the agent **bind-mounts** its folders into the container so paths are slightly different inside the container:

- **Linux containers** (typical):

  - `/__w` ‚Üí host `_work` (so your workspace is `/__w/1`)
  - `/__t` ‚Üí host `_temp`
  - Tool cache may appear under `/__w/_tool` (and is exposed via `$(Agent.ToolsDirectory)`)

So inside the container you‚Äôll usually see:

```ini
/__w/
  ‚îú‚îÄ 1/
  ‚îÇ   ‚îú‚îÄ s
  ‚îÇ   ‚îú‚îÄ b
  ‚îÇ   ‚îú‚îÄ a
  ‚îÇ   ‚îî‚îÄ TestResults
  ‚îú‚îÄ _temp
  ‚îî‚îÄ _tool
```

On **Windows containers**, the same idea with `C:\__w`, `C:\__t`.

Practical tips:

- Keep using the **variables** (e.g., `$(System.DefaultWorkingDirectory)`, `$(Pipeline.Workspace)`) in scripts. They resolve correctly whether you‚Äôre on host or in a container.
- If you must hardcode (not recommended), use `/__w/1/s` inside Linux containers rather than `/home/vsts/work/1/s`.

## üìå **7. Defaults for common tasks**

Azure Pipelines includes **built-in tasks** like `PublishBuildArtifacts`, `PublishTestResults`, and `Checkout`, and it automatically fills in sensible defaults for their inputs. This means:

- You can **omit common parameters** unless you need to override them.
- Pipelines become **cleaner and easier to read**.
- You avoid mistakes like misconfigured paths or missing formats.

---

### üß∞ Examples of Default Behavior

Here‚Äôs how it plays out in practice:

#### ‚úÖ `PublishBuildArtifacts@1`

```yaml
- task: PublishBuildArtifacts@1
```

**Defaults used:**

- `pathToPublish`: `$(Build.ArtifactStagingDirectory)`
- `artifactName`: `drop`
- `publishLocation`: `Container`

So unless you need to change the folder or artifact name, you can skip those inputs.

---

#### ‚úÖ `PublishTestResults@2`

```yaml
- task: PublishTestResults@2
```

**Defaults used:**

- `testResultsFiles`: `**/TEST-*.xml`
- `testResultsFormat`: `JUnit`
- `searchFolder`: `$(System.DefaultWorkingDirectory)`

If you're using JUnit-style test results, this task will auto-discover and publish them without extra config.

---

#### ‚úÖ `Checkout` Step

```yaml
steps:
  - checkout: self
```

**Defaults used:**

- Checks out the repo defined in `self`
- Uses the default branch and fetch depth

You can override with `fetchDepth`, `clean`, or `persistCredentials` if needed, but for most cases, this works out of the box.

### Cheat

1. **`script`, `bash`, `powershell`**:

   - default `workingDirectory` = `$(System.DefaultWorkingDirectory)`
   - (Set `workingDirectory:` explicitly if you need `b` or `a`.)

2. **`PublishBuildArtifacts` / `PublishPipelineArtifact`**:

   - point `path:` to `$(Build.ArtifactStagingDirectory)` (or a subfolder).

3. **`PublishTestResults`**:

   - set `testResultsFiles:` and let it look under `$(Common.TestResultsDirectory)` by default.

### üß† Why It Matters for You

As someone building **modular, reusable pipelines**, these defaults let you:

- Focus on **logic and structure**, not boilerplate
- Keep YAML **minimal and readable**
- Avoid **hardcoding paths** that might break across agents or OS types

---

## üìå **8. Quick ‚Äúcheat sheet‚Äù mapping**

- **Source code** ‚Üí `$(Build.SourcesDirectory)` = `‚Ä¶/s`
- **Default script dir** ‚Üí `$(System.DefaultWorkingDirectory)` = `‚Ä¶/s`
- **Workspace root** ‚Üí `$(Pipeline.Workspace)` = `‚Ä¶/1`
- **Build output** ‚Üí `$(Build.BinariesDirectory)` = `‚Ä¶/b`
- **Artifacts staging** ‚Üí `$(Build.ArtifactStagingDirectory)` / `$(System.ArtifactsDirectory)` = `‚Ä¶/a`
- **Tests** ‚Üí `$(Common.TestResultsDirectory)` = `‚Ä¶/TestResults`
- **Temp** ‚Üí `$(Agent.TempDirectory)` = `‚Ä¶/_temp`
- **Tool cache** ‚Üí `$(Agent.ToolsDirectory)` = `‚Ä¶/_tool`

## üìå **9. Pro tips to ‚Äúmaster‚Äù directories**

- **Never hardcode absolute paths**.
  - Use variables so your pipeline works on Linux/Windows, hosted/self-hosted, and inside containers.
- **Use `workingDirectory:`**
  - in steps that operate outside `s` (e.g., packaging from `a` or running binaries from `b`).
- **Segment outputs** by job:
  - If multiple jobs build different components, create subfolders under `b/` and `a/` to avoid collisions.
- **Multi-repo**:
  - Reference secondary repos under `‚Ä¶/s/<RepoName>` (or use custom `path:` in `checkout`).
- **Containers**:
  - Remember `/__w` and keep using variables‚Äîyour scripts will be portable.
