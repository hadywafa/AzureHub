# 🐳 Self-Hosted Agent Pool + Container Jobs

## 🔹 1. Recap: Self-Hosted Agent

- Normally, Azure DevOps uses **Microsoft-hosted agents** (like `ubuntu-latest`, `windows-latest`).
- A **self-hosted agent** = you install the **Azure Pipelines Agent** on your own machine/VM/container.

  - Runs jobs from pipelines.
  - Useful when you need:

    - Custom tools (not installed on MS-hosted agents).
    - Access to private networks/on-prem systems.
    - Performance tuning.

👉 Example: You run a **self-hosted agent** on an **Azure VM** with special SDKs pre-installed.

---

## 🔹 2. What Are Container Jobs?

Normally, your pipeline job runs **directly on the agent machine**.
But with **container jobs**, Azure DevOps can run **each job inside a Docker container** on that agent.

👉 Think:

- Self-hosted agent = **host machine**.
- Container job = **isolated environment** spun up on that host.

---

## 🔹 3. Why Combine Them?

- ✅ Self-hosted agent → stable, powerful VM with Docker installed.
- ✅ Container jobs → reproducible, isolated build environments.
- 🔄 Together → you can **pool resources**, but still get **ephemeral containers** for builds.

---

## 🔹 4. Hands-On Setup

### Step 1 — Prepare Self-Hosted Agent Machine

- VM (Linux/Windows) or on-prem server.
- Install:

  - **Docker Engine** (must be installed & running).
  - **Azure Pipelines Agent** (download from DevOps → Agent Pools → New agent).

```bash
# Example (Linux)
sudo apt-get update
sudo apt-get install docker.io -y
sudo systemctl enable docker
sudo systemctl start docker
```

- Register agent to a pool (e.g., `self-hosted-pool`).

---

### Step 2 — Configure Pipeline with Container Job

```yaml
pool:
  name: "self-hosted-pool" # your pool with Docker installed

container: mcr.microsoft.com/dotnet/sdk:8.0 # job runs inside this container

steps:
  - script: dotnet --version
    displayName: "Check .NET SDK version"

  - script: |
      echo "Running inside container $(hostname)"
    displayName: "Show environment"
```

👉 What happens:

1. Agent VM pulls the `dotnet/sdk:8.0` container.
2. Starts container.
3. Runs all steps **inside container** (not on host).

---

### Step 3 — Mount Volumes (optional)

Sometimes you need host files accessible inside container (e.g., source code, cache).

```yaml
pool:
  name: "self-hosted-pool"

container:
  image: mcr.microsoft.com/dotnet/sdk:8.0
  options: "--mount type=bind,source=/data,target=/data"

steps:
  - script: ls /data
    displayName: "Check mounted host folder"
```

---

### Step 4 — Multiple Jobs with Different Containers

```yaml
stages:
  - stage: build
    jobs:
      - job: node_build
        container: node:20
        steps:
          - script: npm ci && npm run build
            displayName: "Build Node app"

      - job: dotnet_build
        container: mcr.microsoft.com/dotnet/sdk:8.0
        steps:
          - script: dotnet build MyApp.sln
            displayName: "Build .NET app"
```

👉 Both jobs run on the **same self-hosted agent pool**, but each in its **own container**.

---

## 🔹 5. Exam/Interview Angle

- **Self-hosted agent** = runs jobs on your VM.
- **Container job** = runs jobs inside Docker container, but requires the agent VM to have Docker installed.
- **Self-hosted agent + container job** = gives you **custom tools + reproducibility**.

👉 Key keywords:

- **Self-hosted = control environment**.
- **Container job = reproducible, isolated builds**.
- **Requires Docker on the agent machine**.

---

## ✅ TL;DR

- A **self-hosted agent** runs on your VM/host.
- A **container job** runs inside a Docker container on that agent.
- To use → install **Docker** + **Azure Pipelines Agent** on your host.
- In YAML → specify `container: <image>`.
- Benefits: reproducibility, isolation, multi-language builds on same pool.
