# Pipeline **Artifacts** 🆚 Pipeline **Caching**

## 📦 1. Pipeline **Artifacts**

Think of **artifacts** like 📤 _deliverables you publish and hand over to the next stage_.

### 🔹 What they are

- Files/folders you **explicitly publish** in a pipeline using `PublishPipelineArtifact` or `PublishBuildArtifacts`.
- They are stored on the **Azure DevOps server**, not on the agent.
- You can **download them later** in another job, stage, or even another pipeline (if retained).

### 🔹 Purpose

- Share build outputs (zips, binaries, docker manifests, test logs) across **jobs, stages, or pipelines**.
- Long-term handover — artifacts survive even after the job/agent is gone.

### 🔹 Example

```yaml
# Stage 1: Build
- task: PublishPipelineArtifact@1
  inputs:
    targetPath: "$(Build.BinariesDirectory)"
    artifact: "drop"

# Stage 2: Release
- task: DownloadPipelineArtifact@2
  inputs:
    artifact: "drop"
    path: "$(Pipeline.Workspace)/drop"
```

Here, the **build outputs** are shipped out of the agent’s temp folder, stored in Azure DevOps, and then **downloaded later** (even on a totally different agent machine).

👉 Analogy: **Artifacts = Shipping a package 📦 to a warehouse, so others can pick it up later.**

---

## ⚡ 2. Pipeline **Caching**

Now, caching is about **speeding things up in future runs** ⚡.

### 🔹 What it is

- Cache is stored in Azure DevOps service, but **indexed by a “cache key”** (like a hash of `package-lock.json`).
- Commonly used for dependencies that are expensive to restore each run (npm, NuGet, pip, Gradle, Maven).
- Cache lives **outside artifacts** and can expire/evict.

### 🔹 Purpose

- Speed up pipelines by reusing downloaded/restored dependencies instead of pulling them every time.
- Works across **pipeline runs**, not just jobs in the same run.

### 🔹 Example

```yaml
- task: Cache@2
  inputs:
    key: 'npm | "$(Agent.OS)" | package-lock.json'
    path: "$(Pipeline.Workspace)/.npm"
    restoreKeys: |
      npm | "$(Agent.OS)"
- script: npm install
```

Here:

- On first run → cache miss → downloads packages → saves to cache.
- On next run → cache hit → instantly restores from cache.

👉 Analogy: **Cache = Keeping your favorite snacks 🍪 in a drawer for quick reuse, instead of going to the store every time.**

---

## ⚖️ **Key Differences**

| Feature              | **Artifacts**                                    | **Cache**                                                                   |
| -------------------- | ------------------------------------------------ | --------------------------------------------------------------------------- |
| **Purpose**          | Share outputs between jobs/stages/pipelines      | Speed up jobs by reusing dependencies                                       |
| **Lifetime**         | Kept until retention policy expires (days/weeks) | Evicted automatically when unused/expired                                   |
| **Granularity**      | Explicit publish/download                        | Key-based auto-restore                                                      |
| **Scope**            | Current pipeline or other pipelines              | Future runs of the same pipeline (can also be multi-pipeline with same key) |
| **Best For**         | Binaries, installers, test results               | npm, pip, NuGet packages, Gradle caches                                     |
| **Storage Location** | Azure DevOps Artifacts store                     | Azure DevOps Cache service                                                  |
| **Flow**             | “Build → Publish → Release → Download”           | “Job Run 1 saves → Job Run 2 restores”                                      |

---

## 🚦**When to Use What**

✅ **Use Artifacts when**:

- You want to hand off build outputs (DLLs, JARs, executables) to another stage or deployment.
- You want the files to be downloadable by other pipelines or team members later.
- You need traceability (what was built and deployed).

✅ **Use Cache when**:

- You want to **accelerate** installs/restores of dependencies between runs.
- You don’t care about the files themselves, only that they save time.
- Example: `npm install`, `pip install`, `dotnet restore`.

---

## 🧠 **Mental Model**

- **Artifacts** → "Here’s the product we made today. Store it in the warehouse so QA/Release can use it." 🏭📦
- **Cache** → "Let’s keep the toolbox in the garage, so we don’t waste time buying new tools every time." 🔧

---

👉 Pro Tip: Sometimes you use **both** in the same pipeline.
Example:

- Cache your `npm` folder to speed up `npm install`.
- Then build → produce app bundle → publish it as an **artifact** for deployment.
