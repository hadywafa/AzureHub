# 🏗️ Pipeline Artifacts 🆚 Pipeline Caching 🆚 Azure Artifacts

- **Pipeline Artifacts**
- **Pipeline Caching**
- **Azure Artifacts**

They’re **different things**. Let’s clean it up in your style.

---

## 📦 1. Pipeline Artifacts

_(we covered earlier)!_

- Files you explicitly publish (binaries, zips, test results).
- Stored on Azure DevOps server.
- Used to pass **deliverables** between jobs/stages/pipelines.

👉 Analogy: **Shipping finished products to a warehouse.**

---

## ⚡ 2. Pipeline Caching

- Stores **reusable files** (dependencies, build caches).
- Key-based → reused in _future_ pipeline runs.
- Improves **performance**, not for sharing deliverables.

👉 Analogy: **Keeping your tools/snacks nearby for next time.**

---

## 📦 3. Azure Artifacts (different beast 🐉)

- **Service in Azure DevOps** for hosting and managing **packages**.
- Think of it as a **private package feed** for your org.
- Supports:

  - NuGet (.NET)
  - npm (Node.js)
  - Maven (Java)
  - Python (pip)
  - Universal Packages

### 🔹 What you do with Azure Artifacts

- Publish your own **libraries/packages** (e.g., a shared .NET Core library).
- Consume them in other projects with versioning.
- Apply retention & version policies (keep latest 5 versions, delete old).
- Add upstream sources (e.g., connect to public npm, cache internally).

👉 Analogy: **A package registry (like npmjs, NuGet.org) but private for your company.**

---

## ⚖️ Comparison Table

| Feature              | **Pipeline Artifacts**             | **Pipeline Caching**                       | **Azure Artifacts**                             |
| -------------------- | ---------------------------------- | ------------------------------------------ | ----------------------------------------------- |
| **Purpose**          | Share build outputs (deliverables) | Speed up runs by reusing deps/build caches | Host + manage packages (NuGet, npm, Maven, pip) |
| **Scope**            | Jobs, stages, pipelines            | Future runs (same pipeline, same key)      | Across projects & pipelines                     |
| **Lifetime**         | Retention policy (days/weeks)      | Evicted automatically                      | Controlled via retention/version policies       |
| **Example Use**      | Built DLL → hand to Release stage  | Cache `npm install` or `dotnet restore`    | Publish `MyLib.1.2.0.nupkg` for other teams     |
| **Storage Location** | DevOps artifact store              | DevOps caching service                     | DevOps Artifacts feeds (package registry)       |

---

## 🚦 When to Use

- **Pipeline Artifacts** → hand off build results (build → deploy).
- **Pipeline Caching** → speed up dependency installs (npm, NuGet, pip).
- **Azure Artifacts** → versioned package feeds for sharing libraries.

---

## ✅ TL;DR

- **Pipeline Artifacts = deliverables.**
- **Pipeline Caching = performance boost.**
- **Azure Artifacts = private package registry.**

👉 They are **complementary**, not the same.
Example flow:

1. Use **Pipeline Caching** to speed up `npm install`.
2. Build your app.
3. Publish build output as **Pipeline Artifact** for deployment.
4. Publish shared libraries as **Azure Artifacts** packages for reuse by other apps.

---

⚡ Exam Tip:
If you see a question →

- _“Which feature lets you host NuGet packages for your organization?”_ → **Azure Artifacts**.
- _“Which one speeds up npm install across pipeline runs?”_ → **Pipeline Caching**.
- _“Which one delivers build outputs to later stages?”_ → **Pipeline Artifacts**.

---

👉 Do you want me to also make you a **visual workflow diagram** showing how all three work together in a real pipeline (Cache → Artifact → Azure Artifact)?
