# 🌍 Real-World Example — Ring Deployment with YAML

## 📖 Scenario

You’re deploying a **web app** to production in **4 rings**:

- **Ring 0** → Internal testers (IT/Dev team only)
- **Ring 1** → Early adopter customers (pilot group, \~5%)
- **Ring 2** → Wider customer group (\~30%)
- **Ring 3** → Everyone (100% rollout)

Rules:

- Each ring must pass before the next starts.
- Ring 1 requires a **manager’s approval**.
- Ring 2 requires **gates** (Azure Monitor checks for error rate < 2%).
- Ring 3 requires **final release manager approval**.

---

## 🔹 YAML Pipeline Example

```yaml
trigger:
  - main

stages:
  # =====================
  # Ring 0 - Internal Testers
  # =====================
  - stage: Ring0
    displayName: "Deploy to Ring 0 - Internal"
    jobs:
      - deployment: DeployRing0
        displayName: "Ring 0 Deployment"
        environment: ring0
        strategy:
          runOnce:
            deploy:
              steps:
                - script: echo "Deploying to internal testers (Ring 0)..."
                - script: echo "Run smoke tests for Ring 0"
                - script: echo "Monitoring telemetry for Ring 0"

  # =====================
  # Ring 1 - Pilot Users
  # =====================
  - stage: Ring1
    displayName: "Deploy to Ring 1 - Pilot Users"
    dependsOn: Ring0
    jobs:
      - deployment: DeployRing1
        displayName: "Ring 1 Deployment"
        environment:
          name: ring1
          resourceType: VirtualMachine
          # Require manager approval before rollout
          checks:
            - approval:
                approvers:
                  - ring1-manager@contoso.com
        strategy:
          runOnce:
            deploy:
              steps:
                - script: echo "Deploying to pilot users (Ring 1)..."
                - script: echo "Collecting user feedback from Ring 1"

  # =====================
  # Ring 2 - Wider Audience
  # =====================
  - stage: Ring2
    displayName: "Deploy to Ring 2 - Wider Audience"
    dependsOn: Ring1
    jobs:
      - deployment: DeployRing2
        displayName: "Ring 2 Deployment"
        environment:
          name: ring2
          resourceType: VirtualMachine
          # Add automated gate check: Azure Monitor alerts
          checks:
            - task: InvokeRESTAPI@1
              inputs:
                connectionType: "connectedServiceName"
                method: "GET"
                urlSuffix: "/subscriptions/xxxx/resourceGroups/xxxx/providers/microsoft.insights/metrics"
                successCriteria: "eq(root['errorRate'] < 2, true)"
        strategy:
          runOnce:
            deploy:
              steps:
                - script: echo "Deploying to wider audience (Ring 2)..."
                - script: echo "Monitoring telemetry in Ring 2..."

  # =====================
  # Ring 3 - Full Rollout
  # =====================
  - stage: Ring3
    displayName: "Deploy to Ring 3 - General Availability"
    dependsOn: Ring2
    jobs:
      - deployment: DeployRing3
        displayName: "Ring 3 Deployment"
        environment:
          name: ring3
          # Final approval required before going to 100%
          checks:
            - approval:
                approvers:
                  - release-manager@contoso.com
        strategy:
          runOnce:
            deploy:
              steps:
                - script: echo "Deploying to ALL users (Ring 3 - General Availability)"
                - script: echo "Performing post-deployment health checks..."
```

---

## 🔍 What’s Happening Here

1. **Ring 0** → auto deploy (no approvals). Runs smoke tests, telemetry checks.
2. **Ring 1** → requires **manager approval** before deployment. Collects pilot feedback.
3. **Ring 2** → has **automated gate check** with Azure Monitor (blocks rollout if error rate > 2%).
4. **Ring 3** → requires **final approval** from release manager before 100% rollout.

---

## 🏆 Best Practices in This Setup

- **Use the same build artifact** across rings (avoid "works in test but not in prod").
- **Automate gates** using Azure Monitor, REST APIs, or work item queries.
- **Feature flags** can further fine-tune which users inside a ring see the feature.
- **Rollback quickly** if telemetry fails in Ring 0–2 → prevents bad code reaching everyone.

---

> ✅ In short: This YAML gives you a **safe, real-world, enterprise-style progressive rollout** across rings, with **approvals + automated gates**.
