# ğŸ§  **Azure Pipelines Evaluation Model**

> Azure Pipelines has **two different evaluation engines** running at **two different times**.
> Most pipeline bugs happen because engineers **mix these two worlds**.
> YAML is first **compiled by the Pipeline Service**, then **executed by Agents**.
> Understanding **when something exists** is more important than understanding **how to write it**.

---

![Image](https://i.sstatic.net/IQl4nsWk.png)

---

<div align="center" style="background-color: #2b3436ff; border-radius: 10px; border: 2px solid">

```mermaid
graph TD
    A@{ shape: hex, label: "ğŸ“„ YAML File" }
    B@{ shape: hex, label: "ğŸ§  Compile Time\n(Pipeline Service)" }
    C@{ shape: hex, label: "ğŸ“‹ Execution Plan" }
    D@{ shape: processes, label: "ğŸ¤– Runtime\n(Agent)" }

    A --> B
    B --> C
    C --> D

    classDef animate stroke-dasharray: 9,5,stroke-dashoffset: 700,animation: dash 22s linear infinite;
    class A,B,C,D animate
```

</div>

---

## ğŸ”´ **Problem: â€œWhy Is My Variable Empty?â€**

This is the **#1 Azure Pipelines question**.

Root cause is almost always:

> Using a value **before it exists**.

To fix this forever, you must internalize:

- **Compile-time**
- **Runtime**

---

## ğŸ§  **Two Worlds, Two Engines**

| Phase            | Who evaluates    | What exists                 |
| ---------------- | ---------------- | --------------------------- |
| **Compile-time** | Pipeline Service | YAML, parameters, templates |
| **Runtime**      | Agent            | Variables, scripts, outputs |

---

## ğŸŸ¦ **Compile-Time (Pipeline Service)**

### What Happens Here

- YAML is parsed
- Templates are expanded
- Parameters are resolved
- Stages, jobs, and steps are generated
- Static execution graph is created

### What Exists

- Parameters
- Template expressions
- `${{ }}` expressions
- YAML structure

### What Does NOT Exist

- Script output
- Runtime variables
- `##vso` variables
- Files created by scripts

---

### Compile-Time Syntax: `${{ }}`

```yaml
${{ if eq(parameters.env, 'prod') }}:
```

Use it to:

- Add/remove stages
- Add/remove jobs
- Add/remove steps
- Select variable groups

â— Once compile-time ends, it is **too late** to change structure.

---

## ğŸŸ© **Runtime (Agent Execution)**

### What Happens Here

- Agent starts
- Steps execute sequentially
- Scripts run
- Variables are created
- Artifacts are published

### What Exists

- `$(variable)` values
- Environment variables
- Files on disk
- `##vso` output variables

### What Does NOT Exist

- Parameters (already resolved)
- YAML structure changes
- Template logic

---

### Runtime Syntax: `$( )`

```yaml
- script: echo $(Build.BuildId)
```

This is resolved **by the agent at execution time**.

---

## ğŸ”º **The Third Syntax: `$[ ]` (Runtime Expressions)**

> `$[ ]` is evaluated **at runtime** but **before a job starts**.

Used for:

- Output variables
- Conditions
- Dependencies

Example:

```yaml
variables:
  version: $[ dependencies.Build.outputs['setStep.version'] ]
```

Think of `$[ ]` as:

> Runtime but **outside step execution**

---

## ğŸ”¥ **All Three Syntaxes Compared**

| Syntax   | Phase             | Purpose     |
| -------- | ----------------- | ----------- |
| `${{ }}` | Compile-time      | Structure   |
| `$[ ]`   | Runtime (pre-job) | Data flow   |
| `$( )`   | Runtime (step)    | Value usage |

---

## âŒ **Broken Example (Classic Mistake)**

```yaml
variables:
  version: $(Build.BuildId)

stages:
  - ${{ if eq(variables.version, '123') }}:
      - stage: Deploy
```

âŒ Why it fails:

- `variables.version` does not exist at compile-time
- `$()` is runtime
- Compile-time cannot see runtime values

---

## âœ… **Correct Version**

```yaml
parameters:
  - name: deploy
    type: boolean
    default: true

stages:
  - ${{ if eq(parameters.deploy, true) }}:
      - stage: Deploy
```

Structure uses **parameters**, not variables.

---

## ğŸ§© **Variable Lifecycle Timeline**

```
YAML Read
 â”œâ”€ Parameters resolved
 â”œâ”€ Templates expanded
 â”œâ”€ ${ { } } evaluated
 â””â”€ Execution plan created
      â†“
 Agent starts
 â”œâ”€ $[ ] evaluated
 â”œâ”€ Job begins
 â”œâ”€ Steps execute
 â”œâ”€ $( ) resolved
 â”œâ”€ ##vso variables set
 â””â”€ Job ends (state lost)
```

---

## ğŸ§  **When to Use Each One (Golden Rule)**

| You want toâ€¦              | Use                      |
| ------------------------- | ------------------------ |
| Change pipeline structure | `${{ }}`                 |
| Control job execution     | `$[ ]`                   |
| Read variable in script   | `$( )`                   |
| Pass data between jobs    | `$[ ]` + `isOutput=true` |
| Use user input            | Parameters               |

---

## ğŸ” **End-to-End Flow Example**

<div align="center" style="background-color: #232b2dff; border-radius: 10px; border: 2px solid">

```mermaid
sequenceDiagram
    title Evaluation Timeline ğŸ§­

    participant YAML as ğŸ“„ YAML
    participant Service as ğŸ§  Pipeline Service
    participant Agent as ğŸ¤– Agent
    participant Script as ğŸ§¾ Script

    YAML->>Service: Parse YAML
    Service->>Service: Resolve parameters
    Service->>Service: Evaluate ${{ }}
    Service->>Agent: Assign job
    Agent->>Agent: Evaluate $[ ]
    Agent->>Script: Run script
    Script->>Agent: Create variables (##vso)
    Agent-->>Service: Results
```

</div>

---

## ğŸ§  **Memorization Tips**

### ğŸ”‘ Mnemonic: **"C-R-S"**

| Letter | Meaning                  |
| ------ | ------------------------ |
| **C**  | Compile-time (`${{ }}`)  |
| **R**  | Runtime pre-job (`$[ ]`) |
| **S**  | Step runtime (`$( )`)    |

---

## âŒ **Top Evaluation Model Mistakes**

| Mistake                           | Why           |
| --------------------------------- | ------------- |
| Using `$(var)` in `${{ }}`        | Too late      |
| Using runtime output in structure | Impossible    |
| Using parameters in scripts       | Already gone  |
| Expecting `##vso` at compile-time | Doesnâ€™t exist |

---

## âœ… Why This Topic Is the Root of Mastery

If you truly understand this:

- Variables stop being mysterious
- Output variables feel logical
- Conditions behave predictably
- Templates become easy
- Debugging becomes trivial

This is the **core mental model of Azure Pipelines**.

---

### â–¶ï¸ Next Topic (Core Foundations)

**1.4 Variables Deep Dive (Scopes, Precedence, Internals)**
This will:

- Connect evaluation model to real variables
- Explain why overrides work
- Show why variable groups behave differently
- Prepare you for `##vso` mastery

When ready, say:

> **â€œContinue with 1.4 Variables Deep Dive in the same styleâ€**

You are now officially past the **junior DevOps barrier**.
