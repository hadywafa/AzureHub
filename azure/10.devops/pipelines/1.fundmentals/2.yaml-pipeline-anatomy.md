# ğŸ§  **Azure Pipelines YAML Anatomy**

> Azure Pipelines YAML is **not a script**.
> It is a **declarative execution graph** that the Pipeline Service **compiles into stages, jobs, and steps**.
> YAML defines **structure and intent**, while **agents execute only the final, expanded plan**.
> Understanding the **hierarchy and lifecycle** of YAML elements is mandatory for mastering variables, conditions, templates, and deployments.

---

![Image](https://stacksimplify.com/course-images/azure-devops-pipelines-key-concepts-1.png)

---

<div align="center" style="background-color: #2b3436ff; border-radius: 10px; border: 2px solid">

```mermaid
graph TD
    A@{ shape: hex, label: "ğŸ“„ pipeline.yml" }
    B@{ shape: hex, label: "ğŸ—ï¸ Stage" }
    C@{ shape: hex, label: "ğŸ§© Job" }
    D@{ shape: rect, label: "ğŸ”¹ Step" }

    A --> B
    B --> C
    C --> D

    classDef animate stroke-dasharray: 9,5,stroke-dashoffset: 600,animation: dash 20s linear infinite;
    class A,B,C,D animate
```

</div>

---

## ğŸ”´ **Problem: Treating YAML Like a Script**

Many people read YAML as if it executes **top-down like Bash**.

This leads to mistakes:

- Expecting variables to â€œupdateâ€ instantly
- Assuming later jobs see earlier files
- Confusing `steps` with `jobs`
- Misusing conditions

âŒ YAML does **not** execute  
âœ… YAML **describes** what should execute

---

## ğŸ§© **The YAML Hierarchy (Non-Negotiable)**

### The only valid containment model

```ini
Pipeline
 â””â”€ Stage
     â””â”€ Job
         â””â”€ Step
```

You **cannot**:

- Put a step outside a job
- Put a job outside a stage (unless single-stage implicit)
- Skip levels arbitrarily

---

## ğŸ—ï¸ **Pipeline (Root Level)**

This is the **entry point**.

Defines:

- Triggers
- Parameters
- Global variables
- Stages
- Resources

Example:

```yaml
trigger:
  - main

variables:
  buildConfig: Release

stages:
  - stage: Build
```

ğŸ“Œ The pipeline itself **never runs on an agent**.

---

## ğŸ—ï¸ **Stage (Logical Boundary)**

> A **Stage** is a **logical grouping of jobs**.

Used for:

- CI vs CD separation
- Environment boundaries (Dev / Test / Prod)
- Approvals & checks
- Deployment visibility

Example:

```yaml
- stage: Build
  displayName: Build Stage
```

### Key Properties

- Can run sequentially or in parallel
- Can depend on other stages
- Has its own variables and conditions

---

## ğŸ§© **Job (Execution Boundary)**

> A **Job is the unit of execution**.

This is where **agents are assigned**.

Key rules:

- One job â†’ one agent
- Jobs are isolated
- Jobs may run in parallel
- Jobs define OS, pool, demands

Example:

```yaml
- job: BuildJob
  pool:
    vmImage: ubuntu-latest
```

âš ï¸ **If you remember only one thing**:

> **Agents are assigned at the job level**

---

## ğŸ”¹ **Steps (Action Units)**

> Steps are **instructions executed sequentially inside a job**.

Types of steps:

- Script steps
- Built-in tasks
- Checkout steps

Example:

```yaml
steps:
  - script: echo "Hello"
  - task: DotNetCoreCLI@2
```

âœ” Steps share filesystem  
âœ” Steps share environment variables  
âœ• Steps do not survive job boundaries

---

## ğŸ§  **Why `checkout: self` Is a Step**

This confuses many people.

```yaml
steps:
  - checkout: self
```

Why?

- Code checkout happens **on the agent**
- The agent must execute it
- Therefore it is a **step**, not a pipeline feature

You can:

- Disable checkout
- Checkout multiple repos
- Control depth and submodules

---

## âš™ï¸ **Script Step vs Task Step**

### ğŸ§¾ Script Step

```yaml
- script: |
    echo "Build started"
```

Characteristics:

- Raw shell execution
- OS-dependent
- No built-in validation
- Full control

Best for:

- Custom logic
- Quick commands
- Tool chaining

---

### ğŸ§° Task Step

```yaml
- task: DotNetCoreCLI@2
  inputs:
    command: build
```

Characteristics:

- Prebuilt
- Validated inputs
- Opinionated behavior
- Better logging

Best for:

- Standard operations
- Consistency
- Team readability

---

## ğŸ” **Execution Order (Very Important)**

Within a job:

```ini
Step 1 â†’ Step 2 â†’ Step 3 â†’ ...
```

Across jobs:

- Parallel by default
- Controlled by `dependsOn`

Across stages:

- Sequential by default
- Controlled by `dependsOn`

---

## ğŸŒ **End-to-End YAML Execution Flow**

<div align="center" style="background-color: #232b2dff; border-radius: 10px; border: 2px solid">

```mermaid
sequenceDiagram
    title YAML Lifecycle from File to Execution ğŸ§­

    participant YAML as ğŸ“„ pipeline.yml
    participant Service as ğŸ§  Pipeline Service
    participant Agent as ğŸ¤– Agent
    participant Steps as ğŸ”¹ Steps

    YAML->>Service: Parse YAML
    Service->>Service: Expand templates & parameters
    Service->>Service: Build execution graph
    Service->>Agent: Assign job
    Agent->>Steps: Execute steps sequentially
    Steps-->>Agent: Results
    Agent-->>Service: Logs & status
```

</div>

---

## ğŸ§  **Mental Model (Lock This In)**

```ini
Pipeline = Blueprint
Stage = Phase
Job = Execution Unit
Step = Instruction
```

or even simpler:

```ini
Stages organize
Jobs execute
Steps act
```

---

## âŒ **Common YAML Anatomy Mistakes**

| Mistake                           | Why Itâ€™s Wrong       |
| --------------------------------- | -------------------- |
| Putting logic in YAML order       | YAML is declarative  |
| Expecting jobs to share files     | Isolation            |
| Overusing stages                  | Stages are heavy     |
| Forgetting agent scope            | Causes variable bugs |
| Mixing script & task expectations | Different lifecycles |

---

## ğŸ§  **Memorization Tips**

### ğŸ”‘ Mnemonic: **"PSJS"**

| Letter | Meaning               |
| ------ | --------------------- |
| **P**  | Pipeline (definition) |
| **S**  | Stage (logical phase) |
| **J**  | Job (agent boundary)  |
| **S**  | Step (execution unit) |
