# ğŸ§  **Conditions, Expressions & Control Flow**

## **Conditions â€“ How Pipelines Decide What Runs**

> A **condition** answers one question:
> **â€œShould this thing run or be skipped?â€**
> Conditions are evaluated **at runtime**, **before execution**, and **per stage / job / step**.
> If you understand conditions deeply, you control **flow**, **gates**, and **safety** in production.

---

![Image](https://i.sstatic.net/mlXAx.png)

![Image](https://praveenkumarsreeram.com/wp-content/uploads/2022/04/4.azure-devops-e28093-tips-and-tricks-e28093-3-e28093-how-to-execute-a-pipeline-task-based-on-a-condition-custom-condition-skipped.png?w=1020)

---

<div align="center" style="background-color: #2b3436ff; border-radius: 10px; border: 2px solid">

```mermaid
graph TD
    A@{ shape: hex, label: "ğŸ“‹ Pipeline Execution" }
    B@{ shape: hex, label: "â“ Condition Evaluated" }
    C@{ shape: processes, label: "â–¶ï¸ Runs" }
    D@{ shape: processes, label: "â­ï¸ Skipped" }

    A --> B
    B -->|true| C
    B -->|false| D

    classDef animate stroke-dasharray: 9,5,stroke-dashoffset: 600,animation: dash 20s linear infinite;
    class A,B,C,D animate
```

</div>

---

## ğŸ”´ **Problem: â€œWhy Did This Run / Skip?â€**

Most failures come from:

- Not knowing the **default condition**
- Mixing runtime vs compile-time logic
- Using wrong variable syntax
- Assuming conditions behave like `if` in code

Letâ€™s fix that permanently.

---

## 1ï¸âƒ£ Default Conditions (What Runs If You Do Nothing)

### ğŸ§  Default Rule (Memorize This)

> **Every stage, job, and step runs only if all previous dependencies succeeded.**

Equivalent to:

```yaml
condition: succeeded()
```

---

### ğŸ§ª Example: Implicit Default

```yaml
steps:
  - script: echo Build
  - script: exit 1
  - script: echo Deploy
```

âŒ Output:

- Build â†’ runs
- exit 1 â†’ fails
- Deploy â†’ **skipped**

Why?  
Because `Deploy` has an **implicit `succeeded()` condition**.

---

## 2ï¸âƒ£ Overriding Default Conditions (Very Common)

### âœ… Run Even If Previous Step Failed

```yaml
- script: echo Always runs
  condition: always()
```

---

### âœ… Run Only If Previous Failed

```yaml
- script: echo Runs on failure
  condition: failed()
```

---

### âœ… Run If Previous Was Skipped or Failed

```yaml
condition: succeededOrFailed()
```

---

### ğŸ”¥ Production Example: Cleanup Step

```yaml
- script: rm -rf temp
  condition: always()
```

âœ” Cleanup must **always** run  
âœ” Even on failure

---

## 3ï¸âƒ£ Custom Runtime Conditions (Core Skill)

Conditions are written using **runtime expressions**.

### Basic Syntax

```yaml
condition: <expression>
```

---

### ğŸ§ª Example: Environment-Based Condition

```yaml
variables:
  env: prod

steps:
  - script: echo Deploying to PROD
    condition: eq(variables['env'], 'prod')
```

âœ” Step runs only in prod

---

## 4ï¸âƒ£ Expression Functions (With Real Examples)

These are **not YAML functions** â€” they are **Azure Pipelines expressions**.

---

### ğŸ”¹ `eq(a, b)` â€“ Equals

```yaml
condition: eq(variables['env'], 'prod')
```

Runs when `env == prod`

---

### ğŸ”¹ `and(a, b)` â€“ Logical AND

```yaml
condition: and(
  eq(variables['env'], 'prod'),
  succeeded()
)
```

âœ” Must be prod
âœ” And pipeline must be healthy

---

### ğŸ”¹ `or(a, b)` â€“ Logical OR

```yaml
condition: or(
  eq(variables['env'], 'test'),
  eq(variables['env'], 'prod')
)
```

âœ” Runs in test **or** prod

---

### ğŸ”¹ `startsWith(a, b)` â€“ Branch Logic (Very Common)

```yaml
condition: startsWith(variables['Build.SourceBranch'], 'refs/heads/release/')
```

âœ” Only release branches

---

### ğŸ”¹ Real CI Example: Main or Release Branch

```yaml
condition: or(
  eq(variables['Build.SourceBranch'], 'refs/heads/main'),
  startsWith(variables['Build.SourceBranch'], 'refs/heads/release/')
)
```

---

## 5ï¸âƒ£ Conditions at Different Levels (Critical Distinction)

### ğŸ§± Step-Level Condition

```yaml
- script: echo Step
  condition: eq(variables['env'], 'prod')
```

âœ” Only step is skipped/run

---

### ğŸ§© Job-Level Condition

```yaml
jobs:
  - job: Deploy
    condition: eq(variables['env'], 'prod')
```

âœ” Entire job skipped/run

---

### ğŸ—ï¸ Stage-Level Condition

```yaml
stages:
  - stage: Deploy
    condition: eq(variables['env'], 'prod')
```

âœ” Entire stage skipped/run
âœ” Still **exists** in pipeline graph

---

## 6ï¸âƒ£ Short-Circuit Behavior (Very Important)

> Azure Pipelines expressions are **short-circuited**.

Meaning:

- `and(a, b)` â†’ if `a` is false, `b` is **not evaluated**
- `or(a, b)` â†’ if `a` is true, `b` is **not evaluated**

---

### ğŸ§ª Safe Example (Avoids Null Errors)

```yaml
condition: and(
  ne(variables['tag'], ''),
  startsWith(variables['tag'], 'v')
)
```

âœ” If `tag` is empty â†’ second check skipped  
âœ” No runtime error

---

### âŒ Dangerous Example (Wrong Order)

```yaml
condition: and(
  startsWith(variables['tag'], 'v'),
  ne(variables['tag'], '')
)
```

âŒ `startsWith` evaluated first  
âŒ May fail if tag is empty

---

## 7ï¸âƒ£ Broken vs Fixed Condition Examples (Very Important)

### âŒ Broken: Using `$()` in Condition

```yaml
condition: eq($(env), 'prod')
```

âŒ `$()` resolves in scripts, not conditions

---

### âœ… Fixed

```yaml
condition: eq(variables['env'], 'prod')
```

---

### âŒ Broken: Using Parameters at Runtime

```yaml
condition: eq(parameters.env, 'prod')
```

âŒ Parameters donâ€™t exist at runtime

---

### âœ… Fixed Pattern

```yaml
variables:
  envVar: ${{ parameters.env }}

condition: eq(variables['envVar'], 'prod')
```

---

## 8ï¸âƒ£ Real-World Production Pattern

### ğŸ›‘ Safe Production Deployment Gate

```yaml
condition: and(
  succeeded(),
  eq(variables['env'], 'prod'),
  eq(variables['Build.SourceBranch'], 'refs/heads/main')
)
```

âœ” Only deploys:

- If build succeeded
- If environment is prod
- If branch is main

This single condition prevents **90% of accidents**.

---

## ğŸ§  Mental Model (Lock This In)

```ini
Default = succeeded()
Condition = runtime decision
Variables = variables['x']
No $()
No parameters
```

---

## ğŸ§  Memorization Tips

### ğŸ”‘ Mnemonic: **"S-L-E-A-S"**

| Letter | Meaning              |
| ------ | -------------------- |
| **S**  | succeeded() default  |
| **L**  | Logical operators    |
| **E**  | Expression functions |
| **A**  | and/or short-circuit |
| **S**  | Scope matters        |
