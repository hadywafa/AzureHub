# 🔐 **Git Authentication**

## 📌 **Git is Just Transport + Identity**

- Git itself doesn’t “authenticate.”
- When you `git push` or `git pull`, Git relies on the **transport protocol** (HTTPS, SSH, or local file system).
- Authentication depends on the transport.

👉 So: **Git Auth = Transport Auth.**

---

### ✍🏻 Example GitHub repo

```bash
https://github.com/myorg/myrepo.git
```

- This URL just says:

  - **Protocol** → HTTPS
  - **Host** → github.com
  - **Path** → myorg/myrepo.git

👉 It doesn’t say _how_ you authenticate.

---

## 📌 **The Main Authentication Methods**

### 🔹 1.1 **HTTPS + Username/Password (deprecated 🚫)**

- Old way: you typed your GitHub/GitLab/Azure DevOps username + password.
- Disabled everywhere because of **security risks** (no MFA, easy leaks).

**Example (no longer works):**

```bash
git clone https://github.com/org/repo.git
# Username: alice
# Password: <account password>
```

👉 Today replaced with **Tokens** or **OAuth**.

---

### 🔹 1.2 **HTTPS + Personal Access Tokens (PATs)**

- A **token string** replaces your password.
- You generate it in GitHub/GitLab/Azure DevOps settings.
- Scoped: only access repos, or also issues, workflows, etc.
- Stored in keychain (via GCM) or typed manually.

**Example:**

```bash
git clone https://github.com/org/repo.git
# Username: alice
# Password: ghp_xxxxxxxx (PAT token)
```

👉 Still very common in **CI/CD pipelines** and for **service accounts**.

---

### 🔹 1.3 **HTTPS + OAuth (Device Flow or Browser Login)**

- Modern & secure → integrates with SSO/MFA.
- You login via browser/device code.
- Token is issued → cached in OS keychain.
- GCM automates this flow.

**Example (GitHub with GCM):**

```bash
git clone https://github.com/org/repo.git
# Opens browser → login with GitHub account → MFA → token stored
```

👉 Best for **human developers**.

---

### 🔹 2. **SSH Keys 🔑**

- Public/private keypair stored locally (`~/.ssh/id_rsa`).
- Public key uploaded to GitHub/GitLab/Azure DevOps.
- No password each time; authentication handled by cryptography.

**Example:**

```bash
ssh-keygen -t ed25519 -C "alice@example.com"
# upload ~/.ssh/id_ed25519.pub to GitHub
git clone git@github.com:org/repo.git
```

👉 Very common in **CI/CD runners** and **advanced users**.

---

### 🔹 3. **Kerberos / NTLM / LDAP (Enterprise On-Prem Git)**

- Used in **corporate Git servers** (e.g., Bitbucket Server, GitLab EE with LDAP).
- Auth integrated with enterprise directory.
- Rare in public GitHub/Azure/GitLab Cloud.

---

## 💡 **Credential Helpers (Manager, Cache, Store)**

Git lets you **store/retrieve credentials** via helpers:

- `cache` → memory only (for a few minutes).
- `store` → plaintext on disk (❌ insecure).
- `manager` (GCM) → secure in OS keychain.

**Example:**

```bash
git config --global credential.helper manager
# next time you login → stored securely in Windows Credential Manager/macOS Keychain
```

---

## 📌 **Real-Life Provider Examples**

### 🐙 GitHub

- HTTPS: OAuth (preferred), PATs (fallback).
- SSH: supported.

### 🦊 GitLab

- HTTPS: PATs or OAuth (depends on org).
- SSH: supported.

### 🟦 Azure DevOps

- HTTPS: Entra ID OAuth (preferred), PATs (fallback).
- SSH: supported but less common.

---

## 💳 **Authentication Challenge**

When you run:

```bash
git clone https://github.com/myorg/myrepo.git
```

1. Git contacts `https://github.com`.
2. Server replies:

   - "Who are you? Send credentials (401 Unauthorized)."

3. Git asks your **credential helper** (like GCM) or the user for credentials.
4. Depending on config, you provide:

   - 🛑 **(Old) Password** → rejected now
   - 🔑 **PAT** → accepted as password
   - 🌍 **OAuth Device Flow (GCM)** → redirect to login, fetch token
   - 🔒 **Stored token in Keychain** → silently sent

---

## 📌 **How They Differ Internally**

| Method                  | What Git Sends in HTTPS request                                                                |
| ----------------------- | ---------------------------------------------------------------------------------------------- |
| **Old Password**        | `Authorization: Basic <base64(user:password)>`                                                 |
| **PAT**                 | `Authorization: Basic <base64(user:PAT)>` (user can be anything, often `username` or `oauth2`) |
| **OAuth / Device Flow** | `Authorization: Bearer <OAuth token>` (retrieved by GCM after login)                           |
| **GCM cached token**    | Same as above, but pulled from secure keychain silently                                        |

So the **repo URL stays the same** → but the **HTTP Authorization header changes**.

---

## 📌 **Example with GitHub**

🔹 Using a PAT:

```bash
git clone https://github.com/myorg/myrepo.git
# Username: alice
# Password: ghp_xxxxxxxx   <-- this is the PAT
```

Internally Git sends:

```ini
Authorization: Basic YWxpY2U6Z2hwX3h4eHh4eHh4
```

🔹 Using OAuth (via GCM):

```bash
git clone https://github.com/myorg/myrepo.git
# Browser opens → login with MFA
```

Internally Git sends:

```ini
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6...
```

---

## 📌 **Why Same URL is Fine**

- The **server (GitHub/GitLab/Azure DevOps)** decides what kind of credential it will accept.
- Your **credential helper (GCM, SSH agent, PAT prompt)** decides what to provide.
- As long as the credential is valid → access is granted.

👉 That’s why **URL doesn’t change for HTTPS**, only **auth header changes**.

---

## 📌 **SSH is Different**

For SSH, the URL changes because the **protocol** changes:

```bash
git@github.com:myorg/myrepo.git
```

This tells Git to use SSH, not HTTPS.
Auth here = **public/private keypair**, not tokens.

---

## 📌 **CI/CD Authentication**

In pipelines (no humans):

- **PATs** → easiest (store as secret in GitHub Actions/Azure DevOps).
- **Service Principals** → in Azure DevOps when accessing Azure.
- **Deploy keys (SSH)** → repo-scoped, safe for bots.

Example (Azure DevOps pipeline pulling repo via PAT):

```yaml
variables:
  GIT_TOKEN: $(System.AccessToken)

steps:
  - script: |
      git clone https://$(GIT_TOKEN)@dev.azure.com/org/project/_git/repo
```

---

## 📌 **Diagram of Auth Options**

```mermaid
flowchart TD
    A[Developer/CI] -->|HTTPS Password| X[Deprecated ❌]
    A -->|HTTPS PAT| B[Token-based Auth]
    A -->|HTTPS OAuth| C[SSO + MFA]
    A -->|SSH Key| D[Cryptographic Auth]
    A -->|Kerberos/LDAP| E[Enterprise On-Prem]
```

---

## 📌 **Best Practices**

- ✅ Use **OAuth device flow** (with GCM) for humans → seamless + MFA.
- ✅ Use **PATs or SSH keys** for CI/CD pipelines → stable and scriptable.
- ✅ Store secrets in **secure vaults** (Azure Key Vault, GitHub Secrets).
- ❌ Never use passwords or plaintext `credential.store`.
- **HTTPS + PAT** → easiest, most common for humans.
- **SSH** → great for developers, no password prompts.
- **OAuth (via GCM)** → best for enterprises with SSO + MFA.
- **Deploy Keys/Machine Users** → best for automation.
- `.gitconfig` decides _which helper_ stores/fetches credentials (store, manager, cache).

---

## 🏁 **TL;DR**

- Git itself doesn’t do auth → it delegates to transport (HTTPS, SSH, etc.).
- Modern auth = **Tokens (PATs)**, **OAuth (device flow)**, or **SSH keys**.
- Humans → OAuth/GCM (best UX).
- Machines → PATs or SSH keys.
- Old password auth is dead.
