# 🐳 Project: Build → Push to ACR → Deploy to AKS / App Service (Linux)

## ✅ What you’ll build

- A tiny **.NET 8 minimal API** (hello world)
- A **Docker image**
- An **ACR** (Azure Container Registry)
- Deploy **either**:

  - **Option A:** Azure **App Service (Linux container)**
  - **Option B:** **AKS** (Kubernetes) with `Deployment` + `Service`

We’ll use **RBAC** and **managed integrations** (no hardcoded passwords).

---

## 🧰 Prereqs

- **Azure CLI** logged in: `az login`
- **Docker** running locally
- **.NET 8 SDK**

> All commands are bash-friendly. On Windows, use PowerShell equivalents.

---

## 🔧 1) Scaffold the app and Dockerfile

```bash
# Create folder & app
mkdir acr-demo && cd acr-demo
dotnet new web -n DemoApi
cd DemoApi

# Minimal API returns "Hello ACR!"
cat > Program.cs << 'CS'
var app = WebApplication.CreateBuilder(args).Build();
app.MapGet("/", () => Results.Ok(new { message = "Hello ACR!" }));
app.Run();
CS

# Add Dockerfile
cat > Dockerfile << 'DOCKER'
# Build stage
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src
COPY . .
RUN dotnet publish -c Release -o /out

# Runtime stage
FROM mcr.microsoft.com/dotnet/aspnet:8.0
WORKDIR /app
COPY --from=build /out .
# App Service / containers commonly expect port 8080 or 80—use 8080 to be explicit
ENV ASPNETCORE_URLS=http://+:8080
EXPOSE 8080
ENTRYPOINT ["dotnet", "DemoApi.dll"]
DOCKER
```

Local test (optional):

```bash
docker build -t demoapi:local .
docker run -p 8080:8080 demoapi:local
# In another terminal:
curl http://localhost:8080
```

---

## 🗃️ 2) Create Azure resources (RG + ACR)

```bash
# Variables (edit as you like)
RG=rg-acr-demo
LOC=eastus
ACR_NAME=acrdemo$RANDOM     # must be globally unique

# Resource group
az group create -n $RG -l $LOC

# Container Registry (Standard is a good default)
az acr create -g $RG -n $ACR_NAME --sku Standard
```

Login & get the ACR login server:

```bash
az acr login -n $ACR_NAME
ACR_LOGIN_SERVER=$(az acr show -n $ACR_NAME --query loginServer -o tsv)
echo "ACR login server: $ACR_LOGIN_SERVER"
```

Tag & push your image:

```bash
IMAGE=$ACR_LOGIN_SERVER/demoapi:v1
docker build -t $IMAGE .
docker push $IMAGE
```

You now have `acrdemoXXXX.azurecr.io/demoapi:v1` available in ACR.

---

## 🚀 Option A — Deploy to **Azure App Service (Linux container)**

### 3A. Create App Service Plan + Web App

```bash
PLAN=asp-acr-demo
APP=webapp-acr-$RANDOM

# Linux plan (B1 is fine for demo; use P1v3 for prod features)
az appservice plan create -g $RG -n $PLAN --is-linux --sku B1

# Create the web app (Linux container)
az webapp create -g $RG -p $PLAN -n $APP --container-image-name $IMAGE
```

If your container listens on **8080**, set WEBSITES_PORT:

```bash
az webapp config appsettings set -g $RG -n $APP --settings WEBSITES_PORT=8080
```

**Grant App Service permission to pull from ACR**:
(Uses the web app’s **managed identity** + ACR **AcrPull** RBAC)

```bash
# Enable system-assigned identity on web app
az webapp identity assign -g $RG -n $APP
PRINCIPAL_ID=$(az webapp identity show -g $RG -n $APP --query principalId -o tsv)

# Assign AcrPull at ACR scope
az role assignment create \
  --assignee $PRINCIPAL_ID \
  --role "AcrPull" \
  --scope $(az acr show -n $ACR_NAME --query id -o tsv)
```

Restart and browse:

```bash
az webapp restart -g $RG -n $APP
echo "Open: https://$APP.azurewebsites.net/"
```

Test:

```bash
curl https://$APP.azurewebsites.net/
# {"message":"Hello ACR!"}
```

> Troubleshooting: Check **Deployment Center → Logs** and **Container Settings** in the portal. Ensure `WEBSITES_PORT=8080` matches your Dockerfile.

---

## ⚡ Option B — Deploy to **AKS (Kubernetes)**

### 3B. Create AKS and attach ACR

```bash
AKS=aks-acr-demo

# Create AKS (node size is a demo-friendly default; adjust for prod)
az aks create -g $RG -n $AKS --node-count 1 --node-vm-size Standard_B2s

# Attach ACR so AKS can pull images without secrets
az aks update -g $RG -n $AKS --attach-acr $ACR_NAME

# Get kubeconfig
az aks get-credentials -g $RG -n $AKS
```

### 4B. Create K8s manifests

`k8s.yaml`:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: demoapi
  labels:
    app: demoapi
spec:
  replicas: 2
  selector:
    matchLabels:
      app: demoapi
  template:
    metadata:
      labels:
        app: demoapi
    spec:
      containers:
        - name: demoapi
          image: REPLACE_LOGIN_SERVER/demoapi:v1
          ports:
            - containerPort: 8080
          env:
            - name: ASPNETCORE_URLS
              value: http://+:8080
          readinessProbe:
            httpGet:
              path: /
              port: 8080
            initialDelaySeconds: 5
            periodSeconds: 5
          livenessProbe:
            httpGet:
              path: /
              port: 8080
            initialDelaySeconds: 10
            periodSeconds: 10
          resources:
            requests:
              cpu: "100m"
              memory: "128Mi"
            limits:
              cpu: "500m"
              memory: "512Mi"
---
apiVersion: v1
kind: Service
metadata:
  name: demoapi-svc
spec:
  type: LoadBalancer
  selector:
    app: demoapi
  ports:
    - name: http
      port: 80
      targetPort: 8080
```

Replace the image value:

```bash
sed -i.bak "s|REPLACE_LOGIN_SERVER|$ACR_LOGIN_SERVER|g" k8s.yaml
```

Apply:

```bash
kubectl apply -f k8s.yaml
kubectl rollout status deploy/demoapi
kubectl get svc demoapi-svc -w
```

When `EXTERNAL-IP` appears:

```bash
EXTERNAL_IP=$(kubectl get svc demoapi-svc -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
echo "Test: http://$EXTERNAL_IP/"
curl "http://$EXTERNAL_IP/"
# {"message":"Hello ACR!"}
```

---

## 🧪 Bonus: ACR Task (Build in the Cloud)

Build images **inside ACR** (no local Docker needed):

```bash
# From inside the DemoApi folder (with Dockerfile)
az acr build -r $ACR_NAME -t demoapi:v2 .
# Push is automatic on success
```

Deploy the new tag by updating:

- App Service: `az webapp config container set --docker-custom-image-name $ACR_LOGIN_SERVER/demoapi:v2 -g $RG -n $APP`
- AKS: `kubectl set image deploy/demoapi demoapi=$ACR_LOGIN_SERVER/demoapi:v2`

---

## 🔒 Security & Ops Notes

- **RBAC**: Prefer `AcrPull` for runtimes, `AcrPush` only for CI.
- **No admin-enabled** unless you must; stick to **managed identities**.
- **Geo-replication (ACR Premium)** to pull locally in multi-region setups.
- **Content Trust & Scanning**: consider Microsoft Defender for Cloud image scanning.
- **Helm / OCI**: Store Helm charts in ACR (`helm push oci://$ACR_LOGIN_SERVER/...`).

---

## 🧹 Clean up

```bash
az group delete -n $RG -y
```

---

## ✅ What you achieved

- Built a **containerized .NET API**
- Pushed it to **Azure Container Registry**
- Deployed to:

  - **App Service (Linux container)** using **managed identity** to pull
  - **AKS** with **ACR attached** (no secrets)
