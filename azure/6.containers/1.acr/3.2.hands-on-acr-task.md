# 🐳 ACR Tasks CI/CD — Git → Build in ACR → Deploy

## 🧰 Prereqs

- Azure CLI logged in: `az login`
- A GitHub repo with your `Dockerfile` and app code
- Resource Group created (or let commands create it)

> Replace variables with your values as you go.

```bash
RG=rg-acr-pipeline
LOC=eastus
ACR=myacr$RANDOM            # must be globally unique
REPO_URL=https://github.com/<org>/<repo>.git
BRANCH=main
IMAGE_NAME=demoapi
```

---

## 1) Create ACR & enable build

```bash
az group create -n $RG -l $LOC

# Standard is a good default; use Premium for geo-replication/content trust
az acr create -g $RG -n $ACR --sku Standard

# (Optional) See your login server (e.g., myacr123.azurecr.io)
ACR_LOGIN_SERVER=$(az acr show -n $ACR --query loginServer -o tsv)
echo $ACR_LOGIN_SERVER
```

---

## 2) Option A — **Auto-Deploy to App Service** (webhook, simplest)

This uses ACR for builds + an **App Service “Continuous Deployment” webhook** to redeploy on each new image push.

### A2.1 Create App Service (Linux container)

```bash
PLAN=asp-acrtask
APP=webapp-acrtask-$RANDOM

az appservice plan create -g $RG -n $PLAN --is-linux --sku B1

# Start with :latest (ACR will push latest + version tags)
az webapp create -g $RG -p $PLAN -n $APP \
  --container-image-name $ACR_LOGIN_SERVER/$IMAGE_NAME:latest

# Containers often listen on 8080 (as in earlier demos)
az webapp config appsettings set -g $RG -n $APP --settings WEBSITES_PORT=8080
```

### A2.2 Grant App Service permission to pull from ACR

```bash
az webapp identity assign -g $RG -n $APP
APP_MI=$(az webapp identity show -g $RG -n $APP --query principalId -o tsv)

az role assignment create \
  --assignee $APP_MI \
  --role "AcrPull" \
  --scope $(az acr show -n $ACR --query id -o tsv)
```

### A2.3 Enable **Continuous Deployment** on the Web App (get webhook URL)

```bash
WEBHOOK_URL=$(az webapp deployment container config --enable-cd true \
  -g $RG -n $APP --query CI_CD_URL -o tsv)

echo "App Service CD webhook: $WEBHOOK_URL"
```

### A2.4 Create an **ACR Task** (build on Git push + base image change)

> You’ll need a GitHub token with repo read rights (fine to use classic PAT with `repo` scope or a fine-grained token).

```bash
GITHUB_TOKEN=<YOUR_GH_TOKEN>

az acr task create \
  --registry $ACR \
  --name buildOnGit \
  --context $REPO_URL \
  --branch $BRANCH \
  --file Dockerfile \
  --git-access-token $GITHUB_TOKEN \
  --image $IMAGE_NAME:{{.Run.ID}} \
  --image $IMAGE_NAME:latest \
  --base-image-trigger-enabled true
```

### A2.5 Create an **ACR Webhook** → calls App Service on new push

```bash
az acr webhook create \
  --registry $ACR \
  --name appsvc-webhook \
  --actions push \
  --scope $IMAGE_NAME:latest \
  --uri $WEBHOOK_URL
```

**Flow:** push code → ACR Task builds → pushes `:latest` → **ACR webhook** hits App Service → App re-pulls and restarts.
That’s it ✅

---

## 3) Option B — **Auto-Deploy to AKS** (ACR Task with Managed Identity)

Here we keep everything inside **ACR Task**: build → then a **multi-step task** runs `az` + `kubectl` to update AKS.

### B3.1 Create AKS and attach ACR

```bash
AKS=aks-acrtask
NS=default
DEPLOY=demoapi
SVC=demoapi-svc

az aks create -g $RG -n $AKS --node-count 1 --node-vm-size Standard_B2s

# Allow AKS to pull images from your ACR
az aks update -g $RG -n $AKS --attach-acr $ACR
```

Create a basic Deployment/Service once (so later we only “set image”):

```bash
cat > k8s.bootstrap.yaml <<'YAML'
apiVersion: apps/v1
kind: Deployment
metadata:
  name: demoapi
spec:
  replicas: 2
  selector:
    matchLabels:
      app: demoapi
  template:
    metadata:
      labels:
        app: demoapi
    spec:
      containers:
        - name: demoapi
          image: REPLACEME/demoapi:initial
          ports:
            - containerPort: 8080
          env:
            - name: ASPNETCORE_URLS
              value: http://+:8080
---
apiVersion: v1
kind: Service
metadata:
  name: demoapi-svc
spec:
  type: LoadBalancer
  selector:
    app: demoapi
  ports:
    - port: 80
      targetPort: 8080
YAML

# Apply with any working image for the initial deploy
sed -i.bak "s|REPLACEME|$ACR_LOGIN_SERVER|g" k8s.bootstrap.yaml

# Use your local kubeconfig just for this initial apply:
az aks get-credentials -g $RG -n $AKS --overwrite-existing
kubectl apply -f k8s.bootstrap.yaml -n $NS
```

### B3.2 Create a **multi-step task** with Managed Identity

This task builds & pushes images, then runs `az`/`kubectl` to update the deployment to the **new tag**.

Create `task.yaml`:

```yaml
version: v1.1.0
stepTimeout: 1200
steps:
  # 1) Build & tag
  - build:
      context: {{.Context}}
      dockerfile: Dockerfile
      image: {{.Run.Registry}}/{{.Values.imageName}}:{{.Run.ID}}

  # 2) Also tag 'latest'
  - cmd: >
      sh -c "docker tag {{.Run.Registry}}/{{.Values.imageName}}:{{.Run.ID}}
      {{.Run.Registry}}/{{.Values.imageName}}:latest"

  # 3) Push both
  - push:
      image: {{.Run.Registry}}/{{.Values.imageName}}:{{.Run.ID}}
  - push:
      image: {{.Run.Registry}}/{{.Values.imageName}}:latest

  # 4) Deploy to AKS using Azure CLI container (managed identity)
  - cmd: >
      sh -c "
      az login --identity &&
      az aks get-credentials -g {{.Values.resourceGroup}} -n {{.Values.aksName}} --overwrite-existing --admin &&
      kubectl set image deploy/{{.Values.deployment}} {{.Values.deployment}}={{.Run.Registry}}/{{.Values.imageName}}:{{.Run.ID}} -n {{.Values.namespace}} &&
      kubectl rollout status deploy/{{.Values.deployment}} -n {{.Values.namespace}}
      "
    image: mcr.microsoft.com/azure-cli
    env:
      - name: AZURE_HTTP_USER_AGENT
        value: acr-task
values:
  imageName: demoapi
  resourceGroup: rg-acr-pipeline
  aksName: aks-acrtask
  namespace: default
  deployment: demoapi
```

> Notes
> • `{{.Run.Registry}}` resolves to your ACR login server.
> • We use `--admin` for a simple demo; for production use **Azure AD-integrated AKS RBAC** and give the task MI the proper AKS role.
> • You can add a **test step** (e.g., run container tests) before pushing.

Create the task (with Git trigger & **Managed Identity**):

```bash
# Create a system-assigned identity on the task; or use a user-assigned identity
az acr task create \
  --registry $ACR \
  --name aksCdTask \
  --file task.yaml \
  --context $REPO_URL \
  --branch $BRANCH \
  --git-access-token $GITHUB_TOKEN \
  --assign-identity
```

Get the task’s principal and grant it **AKS access**:

```bash
TASK_MI=$(az acr task show -r $ACR -n aksCdTask --query identity.principalId -o tsv)

# Allow the task to read AKS & fetch credentials
az role assignment create \
  --assignee $TASK_MI \
  --role "Azure Kubernetes Service Cluster User Role" \
  --scope $(az aks show -g $RG -n $AKS --query id -o tsv)
```

> If your AKS uses AAD/RBAC, also grant appropriate **Kubernetes RBAC** (clusterrole/rolebindings) for deployments in your namespace.

**Done.** Now, every **git push** to `$BRANCH` triggers:
**build → push → kubectl set image → rollout status** ✅

---

## 4) Verify & Monitor

### List task runs

```bash
az acr task list-runs -r $ACR -o table
```

### Tail logs of a specific run

```bash
RUN_ID=<paste from list-runs>
az acr task logs -r $ACR --run-id $RUN_ID
```

### Check AKS service public IP (option B)

```bash
kubectl get svc demoapi-svc -n $NS
```

### Hit App Service URL (option A)

```bash
echo "https://$APP.azurewebsites.net/"
```

---

## 🔒 Security & Best Practices

- Prefer **Managed Identity** over secrets (as shown).
- Lock roles tight:

  - App Service / AKS nodes: **AcrPull**
  - CI (Task): only what it needs (AKS cluster user, etc.)

- Keep **base-image triggers enabled** to auto-patch against CVEs.
- Add **test steps** in the task (e.g., run unit/integration tests in a separate container step).
- For multiple environments (dev/stage/prod), create **per-env tasks** and **namespaces** (and optionally pin tags or digests).

---

## 🧹 Clean up

```bash
az group delete -n $RG -y
```

---

## ✅ What you’ve got

- **Option A:** ACR Task builds on Git push → ACR webhook redeploys App Service.
- **Option B:** ACR Task (with Managed Identity) builds → then runs `az+kubectl` to update **AKS** automatically.
