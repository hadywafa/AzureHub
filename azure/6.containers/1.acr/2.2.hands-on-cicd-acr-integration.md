# **CI/CD pipelines** Integration for **both GitHub Actions** and **Azure DevOps**

They build your Docker image, push to **ACR**, and deploy to **either App Service (Linux container)** or **AKS**.
Pick one or keep both.

---

## âœ… GitHub Actions (2 workflows)

> Repo layout assumed: your **Dockerfile** sits at the repo root (or adjust `context`).

### 1) `.github/workflows/appservice-container.yml`

**Build â†’ Push to ACR â†’ Deploy to App Service (Linux container):**

```yaml
name: Build & Deploy to App Service (Container)

on:
  push:
    branches: ["main"]
  workflow_dispatch:

env:
  ACR_NAME: ${{ secrets.ACR_NAME }} # e.g., acrdemo123
  ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }} # e.g., acrdemo123.azurecr.io
  IMAGE_NAME: demoapi # repo name inside ACR
  WEBAPP_NAME: ${{ secrets.WEBAPP_NAME }} # e.g., webapp-acr-1234
  RESOURCE_GROUP: ${{ secrets.RESOURCE_GROUP }} # e.g., rg-acr-demo
  DOCKERFILE: Dockerfile
  CONTEXT: .
  TAG: v${{ github.run_number }}

jobs:
  build-push-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: â¬‡ï¸ Checkout
        uses: actions/checkout@v4

      - name: ðŸ” Azure login (OIDC or Service Principal)
        uses: azure/login@v2
        with:
          # Recommended: use OIDC with federated credentials OR fallback to SP JSON in AZURE_CREDENTIALS
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ðŸ³ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ðŸ”‘ Login to ACR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.ACR_LOGIN_SERVER }}
          username: ${{ secrets.ACR_USERNAME }} # Optional if using 'az acr login' below
          password: ${{ secrets.ACR_PASSWORD }} # Optional
        if: ${{ secrets.ACR_USERNAME != '' }}

      - name: (Alternative) az acr login
        run: az acr login -n $ACR_NAME
        if: ${{ secrets.ACR_USERNAME == '' }}

      - name: ðŸ—ï¸ Build & Push
        uses: docker/build-push-action@v6
        with:
          context: ${{ env.CONTEXT }}
          file: ${{ env.DOCKERFILE }}
          push: true
          tags: |
            ${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.TAG }}
            ${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:latest

      - name: ðŸ”§ Set container image on App Service
        run: |
          az webapp config container set \
            --resource-group $RESOURCE_GROUP \
            --name $WEBAPP_NAME \
            --docker-custom-image-name $ACR_LOGIN_SERVER/$IMAGE_NAME:$TAG \
            --docker-registry-server-url https://$ACR_LOGIN_SERVER
          # App listens on 8080 per our Dockerfile:
          az webapp config appsettings set \
            --resource-group $RESOURCE_GROUP \
            --name $WEBAPP_NAME \
            --settings WEBSITES_PORT=8080

      - name: ðŸ” Restart App
        run: az webapp restart -g $RESOURCE_GROUP -n $WEBAPP_NAME

      - name: âœ… Output URL
        run: echo "https://$WEBAPP_NAME.azurewebsites.net/"
```

### Required GitHub secrets

- `AZURE_CREDENTIALS` â†’ JSON of a Service Principal or configure **OIDC federated credentials**.
- `ACR_NAME`, `ACR_LOGIN_SERVER` (e.g., `myreg.azurecr.io`)
- `WEBAPP_NAME`, `RESOURCE_GROUP`
- _(Optional)_ `ACR_USERNAME`, `ACR_PASSWORD` (if you donâ€™t use `az acr login`)

> Give the **App Service** managed identity **AcrPull** role on your ACR (as shown earlier), or set `ACR_USERNAME/PASSWORD`.

---

### 2) `.github/workflows/aks-deploy.yml`

**Build â†’ Push to ACR â†’ Deploy to AKS (k8s):**

```yaml
name: Build & Deploy to AKS

on:
  push:
    branches: ["main"]
  workflow_dispatch:

env:
  ACR_NAME: ${{ secrets.ACR_NAME }}
  ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }} # e.g., acrdemo123.azurecr.io
  IMAGE_NAME: demoapi
  TAG: v${{ github.run_number }}
  DOCKERFILE: Dockerfile
  CONTEXT: .
  RESOURCE_GROUP: ${{ secrets.RESOURCE_GROUP }}
  AKS_NAME: ${{ secrets.AKS_NAME }}
  K8S_NAMESPACE: default
  K8S_DEPLOYMENT: demoapi
  K8S_SERVICE: demoapi-svc

jobs:
  build-push:
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.meta.outputs.image }}
    steps:
      - uses: actions/checkout@v4

      - uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - uses: docker/setup-buildx-action@v3

      - name: ACR login (either docker login or az acr login)
        run: az acr login -n $ACR_NAME

      - name: ðŸ—ï¸ Build & Push
        uses: docker/build-push-action@v6
        with:
          context: ${{ env.CONTEXT }}
          file: ${{ env.DOCKERFILE }}
          push: true
          tags: |
            ${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.TAG }}
            ${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:latest

  deploy:
    runs-on: ubuntu-latest
    needs: build-push
    steps:
      - uses: actions/checkout@v4

      - name: ðŸ” Azure login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ðŸ”— Set AKS context
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ env.RESOURCE_GROUP }}
          cluster-name: ${{ env.AKS_NAME }}

      - name: ðŸ§© Render manifest
        run: |
          cat > k8s.yaml <<'YAML'
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ${K8S_DEPLOYMENT}
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: ${K8S_DEPLOYMENT}
            template:
              metadata:
                labels:
                  app: ${K8S_DEPLOYMENT}
              spec:
                containers:
                  - name: ${K8S_DEPLOYMENT}
                    image: ${ACR_LOGIN_SERVER}/${IMAGE_NAME}:${TAG}
                    ports:
                      - containerPort: 8080
                    env:
                      - name: ASPNETCORE_URLS
                        value: http://+:8080
                    readinessProbe:
                      httpGet: { path: "/", port: 8080 }
                      initialDelaySeconds: 5
                      periodSeconds: 5
                    livenessProbe:
                      httpGet: { path: "/", port: 8080 }
                      initialDelaySeconds: 10
                      periodSeconds: 10
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: ${K8S_SERVICE}
          spec:
            type: LoadBalancer
            selector:
              app: ${K8S_DEPLOYMENT}
            ports:
              - name: http
                port: 80
                targetPort: 8080
          YAML

          envsubst < k8s.yaml > k8s.out.yaml
          cat k8s.out.yaml

      - name: ðŸš€ Apply to AKS
        run: |
          kubectl apply -f k8s.out.yaml -n $K8S_NAMESPACE
          kubectl rollout status deploy/$K8S_DEPLOYMENT -n $K8S_NAMESPACE
          kubectl get svc $K8S_SERVICE -n $K8S_NAMESPACE
```

### Required GitHub secrets

- `AZURE_CREDENTIALS` (OIDC/SP JSON)
- `ACR_NAME`, `ACR_LOGIN_SERVER`
- `RESOURCE_GROUP`, `AKS_NAME`

> Ensure your AKS is **attached to ACR** (`az aks update --attach-acr`) so it can pull images.

---

## âœ… Azure DevOps (2 pipelines)

Create a file at the repo root: **`azure-pipelines.yml`**.
Use **Service Connections**:

- **Azure Resource Manager** connection (for `AzureCLI@2`, `AzureWebApp@1` tasks)
- (Optional) **Kubernetes** service connection or use `AzureCLI@2` to fetch kubeconfig

### A) App Service (Linux container)

```yaml
trigger:
  - main

variables:
  imageName: demoapi
  dockerfile: Dockerfile
  tag: "$(Build.BuildId)"

stages:
  - stage: BuildPush
    displayName: Build & Push to ACR
    jobs:
      - job: build
        pool:
          vmImage: "ubuntu-latest"
        steps:
          - checkout: self

          - task: AzureCLI@2
            displayName: "az login (SC) & ACR login"
            inputs:
              azureSubscription: "Your-ARM-Service-Connection"
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                az acr login -n $(ACR_NAME)
                docker build -t $(ACR_LOGIN_SERVER)/$(imageName):$(tag) -f $(dockerfile) .
                docker push $(ACR_LOGIN_SERVER)/$(imageName):$(tag)
                docker tag $(ACR_LOGIN_SERVER)/$(imageName):$(tag) $(ACR_LOGIN_SERVER)/$(imageName):latest
                docker push $(ACR_LOGIN_SERVER)/$(imageName):latest

  - stage: DeployAppService
    displayName: Deploy to App Service
    dependsOn: BuildPush
    jobs:
      - job: deploy
        pool:
          vmImage: "ubuntu-latest"
        steps:
          - task: AzureCLI@2
            displayName: "Set container image & app settings"
            inputs:
              azureSubscription: "Your-ARM-Service-Connection"
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                az webapp config container set \
                  --resource-group $(RESOURCE_GROUP) \
                  --name $(WEBAPP_NAME) \
                  --docker-custom-image-name $(ACR_LOGIN_SERVER)/$(imageName):$(tag) \
                  --docker-registry-server-url https://$(ACR_LOGIN_SERVER)
                az webapp config appsettings set \
                  --resource-group $(RESOURCE_GROUP) \
                  --name $(WEBAPP_NAME) \
                  --settings WEBSITES_PORT=8080
                az webapp restart -g $(RESOURCE_GROUP) -n $(WEBAPP_NAME)
```

### Define these **Pipeline Variables** (Pipeline â†’ Variables):

- `ACR_NAME`, `ACR_LOGIN_SERVER` (e.g., `myreg.azurecr.io`)
- `RESOURCE_GROUP`, `WEBAPP_NAME`

> Ensure your App Serviceâ€™s managed identity has **AcrPull** on ACR.

---

### B) AKS (Kubernetes)

```yaml
trigger:
  - main

variables:
  imageName: demoapi
  dockerfile: Dockerfile
  tag: "$(Build.BuildId)"
  k8sNamespace: default
  k8sDeployment: demoapi
  k8sService: demoapi-svc

stages:
  - stage: BuildPush
    displayName: Build & Push to ACR
    jobs:
      - job: build
        pool:
          vmImage: "ubuntu-latest"
        steps:
          - checkout: self

          - task: AzureCLI@2
            displayName: "Build & Push image to ACR"
            inputs:
              azureSubscription: "Your-ARM-Service-Connection"
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                az acr login -n $(ACR_NAME)
                docker build -t $(ACR_LOGIN_SERVER)/$(imageName):$(tag) -f $(dockerfile) .
                docker push $(ACR_LOGIN_SERVER)/$(imageName):$(tag)

  - stage: DeployAKS
    displayName: Deploy to AKS
    dependsOn: BuildPush
    jobs:
      - job: deploy
        pool:
          vmImage: "ubuntu-latest"
        steps:
          - task: AzureCLI@2
            displayName: "Get AKS context & kubectl apply"
            inputs:
              azureSubscription: "Your-ARM-Service-Connection"
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                az aks get-credentials -g $(RESOURCE_GROUP) -n $(AKS_NAME) --overwrite-existing

                cat > k8s.yaml <<'YAML'
                apiVersion: apps/v1
                kind: Deployment
                metadata:
                  name: $(k8sDeployment)
                spec:
                  replicas: 2
                  selector:
                    matchLabels:
                      app: $(k8sDeployment)
                  template:
                    metadata:
                      labels:
                        app: $(k8sDeployment)
                    spec:
                      containers:
                        - name: $(k8sDeployment)
                          image: $(ACR_LOGIN_SERVER)/$(imageName):$(tag)
                          ports:
                            - containerPort: 8080
                          env:
                            - name: ASPNETCORE_URLS
                              value: http://+:8080
                          readinessProbe:
                            httpGet: { path: "/", port: 8080 }
                            initialDelaySeconds: 5
                            periodSeconds: 5
                          livenessProbe:
                            httpGet: { path: "/", port: 8080 }
                            initialDelaySeconds: 10
                            periodSeconds: 10
                ---
                apiVersion: v1
                kind: Service
                metadata:
                  name: $(k8sService)
                spec:
                  type: LoadBalancer
                  selector:
                    app: $(k8sDeployment)
                  ports:
                    - name: http
                      port: 80
                      targetPort: 8080
                YAML

                kubectl apply -f k8s.yaml -n $(k8sNamespace)
                kubectl rollout status deploy/$(k8sDeployment) -n $(k8sNamespace)
                kubectl get svc $(k8sService) -n $(k8sNamespace)
```

### Define these **Pipeline Variables**:

- `ACR_NAME`, `ACR_LOGIN_SERVER`
- `RESOURCE_GROUP`, `AKS_NAME`
- _(optional)_ change `k8sNamespace`, `k8sDeployment`, `k8sService`

> Ensure AKS is **attached to ACR**:
>
> ```bash
> az aks update -g <RG> -n <AKS> --attach-acr <ACR_NAME>
> ```

---

## ðŸ”’ Security notes (both CI/CDs)

- Prefer **OIDC/federated credentials** for GitHub; avoid storing SP secrets.
- Lock down roles:

  - CI: **AcrPush**
  - Runtimes: **AcrPull** only

- Use pinned versions for actions/tasks where possible.
- Consider **image scanning** (Defender for Cloud or GitHub Advanced Security).

---

Want me to add **Helm-based** AKS deployment (values.yaml + `helm upgrade --install`) as an alternative to raw manifests? Or a **multi-environment** setup (dev/stage/prod) with per-env tags and approvals?
