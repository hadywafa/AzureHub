# üîë Authentication Methods for ACR

> üëâ ACR is a **private container registry** built on top of **Azure Storage**. By default, **anonymous pulls are not allowed** (except if you explicitly enable them for public scenarios). To push/pull images, you need authentication.

---

## 1Ô∏è‚É£ **Entra ID Authentication** ‚úÖ (Recommended)

- **How it works**: You log in with your Azure AD identity (`user`, `service principal`, or `managed identity`).
- **Tool**: `az acr login` automatically uses your Azure AD token instead of a password.
- **Roles needed**:

  - **AcrPull** ‚Üí only pull images
  - **AcrPush** ‚Üí push and pull
  - **AcrDelete** ‚Üí delete images
  - **Owner/Contributor** ‚Üí full registry management

**Example with Azure CLI:**

```bash
az login
az acr login --name myregistry
docker pull myregistry.azurecr.io/hello-world:v1
```

**When to use**:

- CI/CD pipelines (with Managed Identity or Service Principal)
- Developer machines (via `az login`)
- Secure production (no static passwords)

---

### ‚úçüèª **Demo on Managed Identity (MI)**

- **Best practice** for Azure resources like VMs, Web Apps, Functions, AKS, Logic Apps.
- Azure automatically injects a token into the resource ‚Üí the resource exchanges it for an **ACR access token**.
- **No secrets needed!**

**Steps:**

1. Assign a system/user-managed identity to your resource.
2. Grant it `AcrPull` or `AcrPush` role on your ACR.
3. The resource (e.g., AKS node pool or App Service) can now pull images automatically.

**Example ‚Äì Assign AcrPull role to AKS nodes:**

```bash
az aks update -n myaks -g myrg --attach-acr myregistry
```

**When to use**:

- AKS pulling container images
- Azure App Service / Functions running containerized apps
- VMSS / VM pulling images during provisioning

---

### ‚úçüèª **Demo on Service Principals (SPN)**

- Used for automation outside Azure (e.g., GitHub Actions, Jenkins, GitLab runners).
- You create a service principal in Azure AD and give it `AcrPush`/`AcrPull` role.
- Then log in with `docker login` using `appId` as username and `password` (secret) as password.

**Example:**

```bash
# Create a service principal
az ad sp create-for-rbac --name acr-sp --role acrpush \
  --scopes $(az acr show --name myregistry --query id --output tsv)

# Login with docker
docker login myregistry.azurecr.io \
  -u <APP_ID> -p <PASSWORD>
```

**When to use**:

- External CI/CD pipelines (GitHub, Jenkins, GitLab, etc.)
- Automation scripts outside Azure

---

## 2Ô∏è‚É£ **Admin User** ‚ö†Ô∏è (Legacy, Not Recommended)

- ACR can be configured with a single **admin username/password**.
- Works like DockerHub username/password.
- **Security risk** because it‚Äôs a static password with full rights (pull + push).

**Enable & get credentials:**

```bash
az acr update -n myregistry --admin-enabled true
az acr credential show -n myregistry
docker login myregistry.azurecr.io -u <USERNAME> -p <PASSWORD>
```

**When to use**:

- Quick testing / local dev (NOT production)
- Proof of concept

---

Perfect üëç let‚Äôs add **Repository-scoped tokens** in the same structured style you like.

---

## 3Ô∏è‚É£ **Repository-Scoped Access Tokens** (ACR Tokens + Scope Maps)

- **How it works**:

  - You define a **scope map** (repo-level permissions).
  - You create a **token** bound to that scope map.
  - The token has **two passwords** (rotate safely, zero downtime).
  - Use it with `docker login` like a normal username/password pair.

- **Permissions available** per repo:

  - `content/read` ‚Üí pull images
  - `content/write` ‚Üí push images
  - `content/delete` ‚Üí delete images
  - `metadata/read` / `metadata/write` ‚Üí tag/list images

**Example with Azure CLI:**

```bash
# Create a pull-only scope map
az acr scope-map create \
  -r myregistry \
  -n pullOnlyScope \
  --repository myrepo content/read metadata/read \
  --description "Read-only access to myrepo"

# Create a token linked to that scope
az acr token create \
  -r myregistry \
  -n myrepo-reader \
  --scope-map pullOnlyScope

# Generate credentials (two passwords)
az acr token credential generate \
  -r myregistry \
  -n myrepo-reader
```

Then log in with Docker:

```bash
docker login myregistry.azurecr.io \
  -u myrepo-reader \
  -p <TOKEN_PASSWORD>
docker pull myregistry.azurecr.io/myrepo:tag
```

---

**When to use**:

- ‚úÖ Partner access to **specific repos** (no Azure AD required)
- ‚úÖ External systems that **cannot use Azure AD**
- ‚úÖ CI/CD environments where you want **fine-grained pull-only or push-only rights**
- üîí Best for scenarios where you don‚Äôt want to share registry-wide access

---

## 4Ô∏è‚É£ **Anonymous** üåç (Public Registry Scenario)

- You can enable **anonymous pull access** for public images.
- Use case: If you want to distribute images publicly without login.
- Warning: Everyone can pull, but nobody can push without credentials.

```bash
az acr update -n myregistry --anonymous-pull-enabled true
```

---

## üìä Comparison Table

| Method                 | Push | Pull | Secretless?                       | Best for                            |
| ---------------------- | ---- | ---- | --------------------------------- | ----------------------------------- |
| **Entra ID User**      | ‚úÖ   | ‚úÖ   | ‚ùå (needs login)                  | Dev machines                        |
| **Admin User**         | ‚úÖ   | ‚úÖ   | ‚ùå                                | Testing only                        |
| **Repo-Scoped Tokens** | ‚úÖ   | ‚úÖ   | ‚ùå Repo-level (read/write/delete) | Pull-only or push-only CI/CD access |
| **Anonymous**          | ‚ùå   | ‚úÖ   | ‚úÖ                                | Public image hosting                |

---

## üèÜ Best Practices

- **Always prefer Managed Identity** for Azure-hosted services.
- **Use Service Principals** for CI/CD outside Azure.
- **Avoid Admin User** in production.
- **Enable anonymous pulls** only for _public_ scenarios.
- Scope roles minimally (`AcrPull` for consumers, `AcrPush` only for build agents).
