# üß™ Project: Web App + Redis Sidecar in ACI

**üéØ Goal:**

- Container group with **two containers**:

  1. `webapp` (Node.js API)
  2. `redis` (official Redis image)

- **Communication:** containers in an ACI group **share the same IP/port namespace**, so the webapp can reach Redis at **`localhost:6379`**.
- **Env Vars:** `REDIS_HOST`, `REDIS_PORT`, `APP_MODE` (and anything else you want).
- **Restart Policy:** `Always` (for long-running service).
- **Public endpoint:** expose port **8080** on the group.

---

## üìå Prereqs

**Azure Login:**

```bash
az login --use-device-code
```

**Pick names:**

```bash
export LOC=eastus
export ACR_NAME=acrredis1997        # must be globally unique
export IMAGE_NAME=webapp-redis-demo:v1
export DNS_LABEL=aci-redis-1997     # public DNS label (optional)
```

**Create resource group:**

```bash
# If you using kodekloud playground
export RG=$(az group list --query "[0].name" --output tsv)

# If you are not using kodekloud playground
export RG=rg-aci-redis-demo
az group create -n $RG -l $LOC
```

**Create ACR:**

```bash
az acr create -g $RG -n $ACR_NAME --sku Basic
```

---

## 1Ô∏è‚É£ Build the Web API (Node.js) and push to ACR

### **app.js:**

```js
const express = require("express");
const Redis = require("ioredis");
const app = express();

const PORT = process.env.PORT || 8080;
const REDIS_HOST = process.env.REDIS_HOST || "localhost";
const REDIS_PORT = parseInt(process.env.REDIS_PORT || "6379", 10);
const APP_MODE = process.env.APP_MODE || "dev";

const redis = new Redis({ host: REDIS_HOST, port: REDIS_PORT });

app.get("/", async (_req, res) => {
  try {
    const visits = (await redis.incr("visits")) || 0;
    res.send(`
      <h1>ACI Multi-Container Demo</h1>
      <p>APP_MODE = ${APP_MODE}</p>
      <p>Redis at ${REDIS_HOST}:${REDIS_PORT}</p>
      <p>Visits = ${visits}</p>
    `);
  } catch (err) {
    res.status(500).send("Redis error: " + err.message);
  }
});

app.get("/set/:key/:value", async (req, res) => {
  await redis.set(req.params.key, req.params.value);
  res.send("OK");
});

app.get("/get/:key", async (req, res) => {
  const v = await redis.get(req.params.key);
  res.send(v ?? "(null)");
});

app.listen(PORT, () => console.log(`Web listening on ${PORT}`));
```

### **package.json:**

```json
{
  "name": "aci-web-redis",
  "version": "1.0.0",
  "dependencies": {
    "express": "^4.19.2",
    "ioredis": "^5.4.1"
  },
  "main": "app.js",
  "scripts": { "start": "node app.js" }
}
```

### **Dockerfile:**

```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
EXPOSE 8080
CMD ["npm", "start"]
```

### **Build & push with ACR Tasks (no local Docker needed):**

```bash
az acr build -r $ACR_NAME -t $IMAGE_NAME .
```

### **Build & push without ACR Tasks (if you have not build task permission):**

#### üîπ Create **Repo-Scoped Token** (Pull-Only)

```bash
export SCOPE_NAME=_repositories_admin
export TOKEN_NAME=webapp1997
export ACR_SERVER="$ACR_NAME.azurecr.io"
```

#### üîπ Create a **scope map** (read-only on your repo)

```bash
az acr scope-map create \
  -r $ACR_NAME \
  -n $SCOPE_NAME \
  --repository webapp-redis-demo content/read metadata/read \
  --description "Pull-only access to webapp-redis-demo"
```

#### üîπ Create a **token** bound to that scope map

```bash
az acr token create \
  -n $TOKEN_NAME \
  -r $ACR_NAME \
  --scope-map $SCOPE_NAME
```

#### üîπ Generate one of the two **passwords**

```bash
export TOKEN_PASS=$(az acr token credential generate \
  -r $ACR_NAME \
  -n $TOKEN_NAME \
  --query "passwords[0].value" -o tsv)

echo "Token user: tok_webapp_reader"
echo "Token pass: $TOKEN_PASS"
```

> üîÅ **Rotation tip:** You have 2 passwords. Regenerate `--password1` or `--password2` individually for zero-downtime rotation.

---

```bash
docker login $ACR_SERVER -u $TOKEN_NAME -p $TOKEN_PASS

# üë∑üèª‚Äç‚ôÄÔ∏è build image locally
docker build -t $IMAGE_NAME .

# üè∑Ô∏è Tag the image for ACR
docker tag $IMAGE_NAME $ACR_SERVER/$IMAGE_NAME

# üöÄ Push the image to ACR
docker push $ACR_SERVER/$IMAGE_NAME
```

Your image:
`$ACR_SERVER/webapp-redis-demo:v1`

---

## 2Ô∏è‚É£ Deploy with CLI (token based repository)

> This declares both `webapp` and `redis`, exposes their ports inside the group, and uses your **repo token** to pull the private webapp image.

```yml
apiVersion: 2021-10-01
location: ${LOC}
name: aci-redis-demo
type: Microsoft.ContainerInstance/containerGroups
properties:
  osType: Linux
  sku: Standard
  restartPolicy: Always
  ipAddress:
    type: Public
    dnsNameLabel: ${DNS_LABEL}
    ports:
      - protocol: TCP
        port: 8080
  containers:
    - name: webapp
      # dependsOn:
      # - redis
      properties:
        image: ${ACR_SERVER}/${IMAGE_NAME}
        resources:
          requests:
            cpu: 1.0
            memoryInGB: 1.0
        ports:
          - port: 8080
        environmentVariables:
          - name: APP_MODE
            value: production
          - name: REDIS_HOST
            value: 127.0.0.1
          - name: REDIS_PORT
            value: "6379"
    - name: redis
      properties:
        image: redis:7-alpine
        resources:
          requests:
            cpu: 0.5
            memoryInGB: 0.5
        ports:
          - port: 6379
  imageRegistryCredentials:
    - server: ${ACR_SERVER}
      username: ${TOKEN_NAME}
      password: ${TOKEN_PASS}
```

> Notes:
>
> - `dependsOn: redis` makes the webapp start **after** Redis (helps avoid initial connection races).
> - We expose port **6379** on the `redis` container (internal to the group).
> - Using `127.0.0.1` (or `localhost`) is correct in ACI container groups because containers share the **same network namespace**.

```bash
envsubst < ./aci-group-app.yml > aci-final.yaml

az container create -g $RG --name aci-redis-demo --file ./aci-final.yaml --only-show-errors
```

> `envsubst` replaces all `${VAR}` with their actual values

---

## 3Ô∏è‚É£ Test it

Get FQDN:

```bash
FQDN=$(az container show -g $RG -n aci-redis-demo --query ipAddress.fqdn -o tsv)
echo "http://$FQDN:8080/"
```

- Hit homepage ‚Üí increments `visits` key in Redis.
- Try the simple key routes:

  - `curl "http://$FQDN:8080/set/greeting/hello"`
  - `curl "http://$FQDN:8080/get/greeting"`

You should see `OK` and then `hello`.

---

## üìå (Optional) Add persistence for Redis

If you want Redis persistence, mount an **Azure File Share** and point Redis to it:

Add under `containerGroups.properties`:

```yaml
volumes:
  - name: redisdata
    azureFile:
      shareName: myshare
      storageAccountName: mystorageacct
      storageAccountKey: REPLACE_STORAGE_KEY
```

Then mount in the `redis` container:

```yaml
- name: redis
  properties:
    image: redis:7-alpine
    resources:
      requests: { cpu: 0.5, memoryInGB: 0.5 }
    volumeMounts:
      - name: redisdata
        mountPath: /data
```

And run Redis with persistence flags (add `command` to the `redis` container), e.g.:

```yaml
command: ["redis-server", "--appendonly", "yes", "--dir", "/data"]
```

---

## üìå Troubleshooting & Logs

```bash
# See container status
az container show -g $RG -n aci-redis-demo -o table

# Fetch logs for a specific container
az container logs -g $RG -n aci-redis-demo --container-name webapp
az container logs -g $RG -n aci-redis-demo --container-name redis

# Attach interactive stream
az container attach -g $RG -n aci-redis-demo
```

Common fixes:

- **401 pulling image** ‚Üí check `imageRegistryCredentials` (server/user/pass).
- **Web not reachable** ‚Üí ensure `ipAddress.ports` includes `8080`, and webapp listens on `0.0.0.0:8080`.
- **Redis connect error** ‚Üí ensure `REDIS_HOST=localhost`, both containers in same group, and no port mismatch.

---

## üìå Clean up

```bash
az group delete -n $RG -y
```

---

## üîÑ What you practiced

- **Multi-container groups** (sidecar pattern) in ACI
- **Env vars** to steer app config at runtime
- **RestartPolicy = Always** for a long-running front-end
- (Optional) **Azure Files** for persistence
- Private image from **ACR** + public image from Docker Hub in one group
