# üß™ Project: Single-Container ACI pulling Private ACR Image

Here‚Äôs a **single-container ACI** hands-on that shows **every common way** to pull a **private image from ACR**:

- üîë **Admin User** (fastest, least safe)
- üéØ **Repository Token** (fine-grained)
- üë§ **Service Principal** (AAD/RBAC friendly)
- üÜî **Managed Identity** (passwordless, best practice)

We‚Äôll keep it simple: one **Node.js ‚Äúhello‚Äù web** image you push to ACR, then deploy 4 variants of the **same ACI** using different auth methods.

---

## üìå Pre-requests

```bash
az login --use-device-code

# Vars
export LOC=eastus
export RG=rg-aci-single
export ACR_NAME=acrsingle$RANDOM     # must be globally unique
export ACR_SERVER="$ACR_NAME.azurecr.io"
export IMAGE_NAME=hello-web:v1
export ACI_DNS=aci-single-$RANDOM
export ACI_NAME=aci-single-demo
```

Create RG + ACR:

```bash
az group create -n $RG -l $LOC -o table
az acr create -g $RG -n $ACR_NAME --sku Basic -o table
```

## 1Ô∏è‚É£ Build & Push a tiny web app to ACR

- **app.js**

  ```js
  const http = require("http");
  const PORT = process.env.PORT || 8080;
  http.createServer((_, res) => {
      res.writeHead(200, { "Content-Type": "text/html" });
      res.end(`<h1>Hello from ACI + ACR!</h1><p>${new Date().toISOString()}</p>`);
    })
    .listen(PORT, () => console.log("Listening on", PORT));
  ```

- **package.json**

  ```json
  {
    "name": "hello-web",
    "version": "1.0.0",
    "main": "app.js",
    "scripts": { "start": "node app.js" },
    "dependencies": {}
  }
  ```

- **Dockerfile**

  ```dockerfile
  FROM node:18-alpine
  WORKDIR /app
  COPY package.json ./
  RUN npm ci --omit=dev || npm i --omit=dev
  COPY app.js ./
  EXPOSE 8080
  CMD ["npm", "start"]
  ```

Build & push (no local Docker needed):

```bash
az acr build -r $ACR_NAME -t $IMAGE_NAME .
# Your image => $ACR_SERVER/$IMAGE_NAME
```

---

## 2Ô∏è‚É£ Deploy Variant A ‚Äî **Admin User** (quick & dirty)

> Enable ACR admin, fetch username/password, pass to ACI. Easiest, but **avoid in prod**.

```bash
# Enable admin user (if not already)
az acr update -n $ACR_NAME --admin-enabled true

# Fetch creds
export ADMIN_USER=$(az acr credential show -n $ACR_NAME --query username -o tsv)
export ADMIN_PASS=$(az acr credential show -n $ACR_NAME --query passwords[0].value -o tsv)

# Create ACI (single container) with registry creds
az container create \
  -g $RG -n ${ACI_NAME}-admin \
  --image $ACR_SERVER/$IMAGE_NAME \
  --registry-login-server $ACR_SERVER \
  --registry-username $ADMIN_USER \
  --registry-password "$ADMIN_PASS" \
  --dns-name-label ${ACI_DNS}-admin \
  --ip-address Public --ports 8080 \
  --restart-policy Always --os-type Linux --sku Standard
```

Test:

```bash
ADMIN_FQDN=$(az container show -g $RG -n ${ACI_NAME}-admin --query ipAddress.fqdn -o tsv)
curl "http://$ADMIN_FQDN:8080/"
```

---

## 3Ô∏è‚É£ Deploy Variant B ‚Äî **Repository-Scoped Token** (least privilege)

> üí° Fine-grained, repo-only pull rights. No AAD needed for the caller.

Create **read-only** scope map + token:

```bash
export SCOPE_NAME=sm_pull_hello
export TOKEN_NAME=tok_hello_reader

az acr scope-map create -r $ACR_NAME -n $SCOPE_NAME \
  --repository hello-web content/read metadata/read \
  --description "Pull-only for hello-web" 2>/dev/null || true

az acr token create -r $ACR_NAME -n $TOKEN_NAME --scope-map $SCOPE_NAME 2>/dev/null || true

export TOKEN_PASS=$(az acr token credential generate \
  -r $ACR_NAME -n $TOKEN_NAME --query passwords[0].value -o tsv)
```

Deploy using token as username/password:

```bash
az container create \
  -g $RG -n ${ACI_NAME}-token \
  --image $ACR_SERVER/$IMAGE_NAME \
  --registry-login-server $ACR_SERVER \
  --registry-username $TOKEN_NAME \
  --registry-password "$TOKEN_PASS" \
  --dns-name-label ${ACI_DNS}-token \
  --ip-address Public --ports 8080 \
  --restart-policy Always --os-type Linux --sku Standard
```

Test:

```bash
TOKEN_FQDN=$(az container show -g $RG -n ${ACI_NAME}-token --query ipAddress.fqdn -o tsv)
curl "http://$TOKEN_FQDN:8080/"
```

> üîÅ **Rotation**: `az acr token credential generate -r $ACR_NAME -n $TOKEN_NAME --password1` (or `--password2`) to rotate gracefully.

---

## 4Ô∏è‚É£ Deploy Variant C ‚Äî **Service Principal** (AAD/RBAC)

> Good for external CI/CD that already uses AAD. Grant `AcrPull` on ACR scope.

Create SP + role assignment:

```bash
SP=$(az ad sp create-for-rbac \
  --name sp-acr-pull-$RANDOM \
  --role AcrPull \
  --scopes $(az acr show -n $ACR_NAME --query id -o tsv) \
  -o json)

export SP_APPID=$(echo "$SP" | jq -r .appId)
export SP_SECRET=$(echo "$SP" | jq -r .password)
```

Deploy with SP creds:

```bash
az container create \
  -g $RG -n ${ACI_NAME}-sp \
  --image $ACR_SERVER/$IMAGE_NAME \
  --registry-login-server $ACR_SERVER \
  --registry-username $SP_APPID \
  --registry-password "$SP_SECRET" \
  --dns-name-label ${ACI_DNS}-sp \
  --ip-address Public --ports 8080 \
  --restart-policy Always --os-type Linux --sku Standard
```

Test:

```bash
SP_FQDN=$(az container show -g $RG -n ${ACI_NAME}-sp --query ipAddress.fqdn -o tsv)
curl "http://$SP_FQDN:8080/"
```

---

## 5Ô∏è‚É£ Deploy Variant D ‚Äî **Managed Identity** (passwordless ‚úÖ Best)

> **No secrets** anywhere. Use a **User-Assigned Managed Identity (UAMI)** with `AcrPull`, attach to ACI. ACI pulls image using that identity silently.

Create UAMI & grant `AcrPull` **before** creating ACI:

```bash
export UAMI_NAME=aci-pull-mi
az identity create -g $RG -n $UAMI_NAME

export UAMI_ID=$(az identity show -g $RG -n $UAMI_NAME --query id -o tsv)
export UAMI_PRINCIPAL=$(az identity show -g $RG -n $UAMI_NAME --query principalId -o tsv)
az role assignment create --assignee $UAMI_PRINCIPAL --role AcrPull \
  --scope $(az acr show -n $ACR_NAME --query id -o tsv)
```

Deploy ACI **with identity** (no registry creds flags):

```bash
cat <<EOF | az container create -g $RG --name ${ACI_NAME}-mi --file - --only-show-errors
apiVersion: 2021-10-01
location: $LOC
name: ${ACI_NAME}-mi
type: Microsoft.ContainerInstance/containerGroups
sku: Standard
identity:
  type: UserAssigned
  userAssignedIdentities:
    $UAMI_ID: {}
properties:
  osType: Linux
  restartPolicy: Always
  ipAddress:
    type: Public
    dnsNameLabel: ${ACI_DNS}-mi
    ports:
      - protocol: TCP
        port: 8080
  containers:
    - name: web
      properties:
        image: $ACR_SERVER/$IMAGE_NAME
        resources:
          requests: { cpu: 1.0, memoryInGB: 1.0 }
        ports:
          - port: 8080
EOF
```

Test:

```bash
MI_FQDN=$(az container show -g $RG -n ${ACI_NAME}-mi --query ipAddress.fqdn -o tsv)
curl "http://$MI_FQDN:8080/"
```

> If the pull fails with 401, double-check the **role assignment** and that your ACR isn‚Äôt restricted by a private endpoint/firewall that blocks ACI.

---

## üîç Diagnostics (any variant)

```bash
# status
az container show -g $RG -n <aci-name> -o table

# logs
az container logs -g $RG -n <aci-name> --container-name web

# re-create (some props require delete/create)
az container delete -g $RG -n <aci-name> -y
```

---

## üßπ Cleanup

```bash
az group delete -n $RG -y
```

---

## ü§î Which auth should I choose?

| Method                | Secrets? | Least Privilege | Best For                                  |
| --------------------- | -------- | --------------- | ----------------------------------------- |
| **Managed Identity**  | ‚ùå       | ‚úÖ via RBAC     | Azure-hosted workloads (passwordless)     |
| **Repo Token**        | ‚úÖ       | ‚úÖ repo-scoped  | Non-AAD callers needing narrow data plane |
| **Service Principal** | ‚úÖ       | ‚úÖ via RBAC     | AAD-centric CI/CD, enterprise governance  |
| **Admin User**        | ‚úÖ       | ‚ùå (broad)      | Quick tests only (avoid in production)    |
