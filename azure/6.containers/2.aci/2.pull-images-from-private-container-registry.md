# üö¢ Pulling Private Images to Azure Container Instances

> [üìö references](https://learn.microsoft.com/en-us/azure/container-registry/container-registry-auth-aci)

## ü§î How ACI authenticates to registries

ACI supports two auth mechanisms:

1. **Passwordless identity (Azure-only)**

   - **Managed Identity** (best for ACR): ACI uses a User-Assigned or System-Assigned Managed Identity that has `AcrPull` RBAC on the target ACR.
   - üí° No secrets. Best practice.

2. **Username/Password pair** (generic for any registry)

   - Presented in ACI as `imageRegistryCredentials` (YAML) or `--registry-username/--registry-password` (CLI).
   - Examples: ACR admin user, ACR repo-scoped tokens, Service Principals, Docker Hub tokens, GHCR/GitLab PATs, Quay tokens, AWS ECR temporary password.

---

## üîê Azure Container Registry (ACR)

### ‚úÖ Best: Managed Identity (passwordless)

- Grant MI `AcrPull` on the ACR.
- Attach MI to ACI. No registry creds block is needed.

```bash
# Create UAMI and grant pull
UAMI_NAME=aci-pull-mi
az identity create -g $RG -n $UAMI_NAME
UAMI_ID=$(az identity show -g $RG -n $UAMI_NAME --query id -o tsv)
UAMI_PRINCIPAL=$(az identity show -g $RG -n $UAMI_NAME --query principalId -o tsv)
ACR_ID=$(az acr show -n $ACR_NAME --query id -o tsv)
az role assignment create --assignee $UAMI_PRINCIPAL --role AcrPull --scope $ACR_ID
```

**Deploy (YAML via stdin):**

```bash
ACR_SERVER="$ACR_NAME.azurecr.io"
cat <<EOF | az container create -g $RG --name app-mi --file - --only-show-errors
apiVersion: 2021-10-01
location: $LOC
name: app-mi
type: Microsoft.ContainerInstance/containerGroups
sku: Standard
identity:
  type: UserAssigned
  userAssignedIdentities:
    $UAMI_ID: {}
properties:
  osType: Linux
  restartPolicy: Always
  ipAddress: { type: Public, dnsNameLabel: app-mi-$RANDOM, ports: [{protocol: TCP, port: 8080}] }
  containers:
    - name: web
      properties:
        image: $ACR_SERVER/myimage:v1
        ports: [{ port: 8080 }]
        resources: { requests: { cpu: 1.0, memoryInGB: 1.0 } }
EOF
```

### üéØ Repo-scoped token (fine-grained, per-repo)

```bash
# Create read-only scope + token
az acr scope-map create -r $ACR_NAME -n sm_pull --repository myimage content/read metadata/read
az acr token create -r $ACR_NAME -n tok_pull --scope-map sm_pull
TOKEN_PASS=$(az acr token credential generate -r $ACR_NAME -n tok_pull --query passwords[0].value -o tsv)
```

**Deploy:**

```bash
az container create -g $RG -n app-token \
  --image $ACR_SERVER/myimage:v1 \
  --registry-login-server $ACR_SERVER \
  --registry-username tok_pull \
  --registry-password "$TOKEN_PASS" \
  --ip-address Public --ports 8080 --os-type Linux --sku Standard
```

### üë§ Service Principal (AAD/RBAC)

```bash
SP=$(az ad sp create-for-rbac \
  --name sp-acr-pull \
  --role AcrPull \
  --scopes $ACR_ID -o json)
SP_APPID=$(echo "$SP" | jq -r .appId)
SP_SECRET=$(echo "$SP" | jq -r .password)

az container create -g $RG -n app-sp \
  --image $ACR_SERVER/myimage:v1 \
  --registry-login-server $ACR_SERVER \
  --registry-username $SP_APPID \
  --registry-password "$SP_SECRET" \
  --ip-address Public --ports 8080 --os-type Linux --sku Standard
```

### ‚ö†Ô∏è Admin user (quick test only; avoid in prod)

```bash
az acr update -n $ACR_NAME --admin-enabled true
ADMIN_USER=$(az acr credential show -n $ACR_NAME --query username -o tsv)
ADMIN_PASS=$(az acr credential show -n $ACR_NAME --query passwords[0].value -o tsv)

az container create -g $RG -n app-admin \
  --image $ACR_SERVER/myimage:v1 \
  --registry-login-server $ACR_SERVER \
  --registry-username $ADMIN_USER \
  --registry-password "$ADMIN_PASS" \
  --ip-address Public --ports 8080 --os-type Linux --sku Standard
```

---

## üê≥ Docker Hub (private repos)

- **Username:** your Docker ID
- **Password:** a **Docker Access Token** (recommended) or your password

```bash
DOCKER_USER="yourname"
DOCKER_TOKEN="your-access-token"
az container create -g $RG -n app-dhub \
  --image docker.io/yourname/private-repo:tag \
  --registry-login-server docker.io \
  --registry-username "$DOCKER_USER" \
  --registry-password "$DOCKER_TOKEN" \
  --ip-address Public --ports 8080 --os-type Linux --sku Standard
```

> If you use an org/repo, ensure the token has **Read** on that repo.

---

## üêô GitHub Container Registry (GHCR)

- **Server:** `ghcr.io`
- **Username:** your GitHub username
- **Password:** **PAT** with `read:packages` scope

```bash
GH_USER="your-gh-username"
GH_PAT="ghp_xxx_with_read_packages"
az container create -g $RG -n app-ghcr \
  --image ghcr.io/your-org/your-image:tag \
  --registry-login-server ghcr.io \
  --registry-username "$GH_USER" \
  --registry-password "$GH_PAT" \
  --ip-address Public --ports 8080 --os-type Linux --sku Standard
```

---

## ü¶ä GitLab Container Registry

- **Server:** `registry.gitlab.com` (or your self-managed domain)
- **Username:** GitLab username (or `gitlab+deploy-token-<id>` for a deploy token)
- **Password:** Personal Access Token with `read_registry`, or **Deploy Token**

```bash
GL_USER="your-gitlab-user-or-deploy-token-name"
GL_TOKEN="your-pat-or-deploy-token"
az container create -g $RG -n app-gitlab \
  --image registry.gitlab.com/namespace/project/image:tag \
  --registry-login-server registry.gitlab.com \
  --registry-username "$GL_USER" \
  --registry-password "$GL_TOKEN" \
  --ip-address Public --ports 8080 --os-type Linux --sku Standard
```

---

## üÖÄ Quay.io

- **Server:** `quay.io`
- **Username:** Quay username
- **Password:** Quay Robot Account token or encrypted password

```bash
Q_USER="your-quay-user-or-robot"
Q_PASS="your-quay-token"
az container create -g $RG -n app-quay \
  --image quay.io/org/repo:tag \
  --registry-login-server quay.io \
  --registry-username "$Q_USER" \
  --registry-password "$Q_PASS" \
  --ip-address Public --ports 8080 --os-type Linux --sku Standard
```

---

## üüß AWS Elastic Container Registry (ECR)

- **Server:** `<aws_account_id>.dkr.ecr.<region>.amazonaws.com`
- **Username:** `AWS`
- **Password:** output of `aws ecr get-login-password` (temporary)

```bash
AWS_REGION=eu-west-1
AWS_ACCOUNT_ID=123456789012
ECR_SERVER="$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com"

# Make sure the image is in ECR already, e.g., repo: myapp
# Get a temporary password from AWS CLI (must be logged in with a role/user allowed to access that ECR)
ECR_PASS=$(aws ecr get-login-password --region $AWS_REGION)

az container create -g $RG -n app-ecr \
  --image $ECR_SERVER/myapp:tag \
  --registry-login-server $ECR_SERVER \
  --registry-username AWS \
  --registry-password "$ECR_PASS" \
  --ip-address Public --ports 8080 --os-type Linux --sku Standard
```

> üîÅ ECR passwords expire; for long-lived infra, refresh before (re)deployment and avoid checking passwords into files.

---

## üß± Private networking & firewalls (Important)

- If your registry is **ACR with Private Endpoint**:

  - Deploy ACI **into the same VNet** and set up **private DNS** so `*.azurecr.io` resolves to the PEIP.
  - Managed Identity still works; ensure ACI‚Äôs subnet has outbound to ACR private endpoint.

- For **self-hosted/other cloud** registries behind firewalls:

  - Ensure ACI has **network path** (Public IP allowed, or deploy ACI with **VNet** and proper routing to reach the registry).
  - ACI currently can‚Äôt mount customer private endpoints for non-ACR registries; you typically allow ACI‚Äôs public egress or route via your network.

---

## üß™ One generic CLI pattern (username/password registries)

```bash
az container create \
  -g $RG -n app-generic \
  --image <REGISTRY_SERVER>/<PATH>:<TAG> \
  --registry-login-server <REGISTRY_SERVER> \
  --registry-username "<USERNAME>" \
  --registry-password "<PASSWORD_OR_TOKEN>" \
  --ip-address Public --ports 8080 --os-type Linux --sku Standard
```

## üß™ One generic YAML pattern (username/password registries)

```yaml
apiVersion: 2021-10-01
location: eastus
name: app-generic
type: Microsoft.ContainerInstance/containerGroups
sku: Standard
properties:
  osType: Linux
  restartPolicy: Always
  ipAddress:
    type: Public
    dnsNameLabel: app-generic-demo
    ports:
      - protocol: TCP
        port: 8080
  containers:
    - name: web
      properties:
        image: <REGISTRY_SERVER>/<PATH>:<TAG>
        resources:
          requests: { cpu: 1.0, memoryInGB: 1.0 }
        ports:
          - port: 8080
  imageRegistryCredentials:
    - server: <REGISTRY_SERVER>
      username: <USERNAME>
      password: <PASSWORD_OR_TOKEN>
```

Apply:

```bash
az container create -g $RG --name app-generic --file app-generic.yaml
```

---

## ‚úÖ Recommendations (what to pick)

| Registry                              | Preferred Method               | Why                                          |
| ------------------------------------- | ------------------------------ | -------------------------------------------- |
| **ACR**                               | **Managed Identity (AcrPull)** | Passwordless, RBAC, rotate nothing           |
| **ACR**                               | Repo Token (read-only)         | Fine-grained, easy rotation                  |
| **ACR**                               | Service Principal              | AAD-native CI/CD, RBAC control               |
| **Docker Hub / GHCR / GitLab / Quay** | Username + **PAT/Token**       | Standard approach for third-party registries |
| **AWS ECR**                           | `AWS` + temp password          | Only supported method; refresh each deploy   |

**Security tips!**

- Prefer **Managed Identity** for ACR.
- Avoid ACR **Admin User** in production.
- Never commit secrets; pass via **Key Vault**, **GitHub Actions Secrets**, or CI secret stores.
- Stream specs via **stdin** (no files), or scrub local files afterward.
- Rotate tokens regularly (repo tokens, PATs, ECR passwords).
