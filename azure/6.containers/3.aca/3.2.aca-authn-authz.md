# 🔐 ACA AuthN/AuthZ — Full Hands-On

## 0) Prereqs

```bash
# Login
az login --use-device-code

# Vars
export RG=rg-aca-auth
export LOC=eastus
export ENV_NAME=aca-env-auth
export APP_NAME=aca-web-auth
export LAW=logw-$RANDOM
```

Create RG + Log Analytics + ACA Environment:

```bash
az group create -n $RG -l $LOC -o table

az monitor log-analytics workspace create -g $RG -n $LAW -l $LOC
LAW_ID=$(az monitor log-analytics workspace show -g $RG -n $LAW --query customerId -o tsv)
LAW_KEY=$(az monitor log-analytics workspace get-shared-keys -g $RG -n $LAW --query primarySharedKey -o tsv)

az containerapp env create \
  -g $RG -n $ENV_NAME -l $LOC \
  --logs-workspace-id $LAW_ID \
  --logs-workspace-key $LAW_KEY
```

---

## 1) Minimal Web App (Node.js)

This app trusts ACA to do the login. It reads **headers** ACA injects after validation:

- `x-ms-client-principal` (base64 JSON with claims)
- `x-ms-client-principal-name` (UPN/email)

### **app.js**

```js
const express = require("express");
const app = express();

function getUser(req) {
  const name = req.headers["x-ms-client-principal-name"] || null;
  const principalB64 = req.headers["x-ms-client-principal"];
  let roles = [];
  if (principalB64) {
    const decoded = Buffer.from(principalB64, "base64").toString("utf8");
    const principal = JSON.parse(decoded);
    roles = (principal.claims || []).filter((c) => c.typ === "roles" || c.typ?.endsWith("/role")).map((c) => c.val);
  }
  return { name, roles };
}

app.get("/", (req, res) => {
  const user = getUser(req);
  res.send(`
    <h1>ACA Auth Demo</h1>
    <p>User: ${user.name ?? "(anonymous)"}</p>
    <p>Roles: ${user.roles.join(", ") || "(none)"}</p>
    <p>
      <a href="/admin">/admin</a> (requires "Admin" role)
    </p>
  `);
});

app.get("/admin", (req, res) => {
  const user = getUser(req);
  if (!user.name) return res.status(401).send("Not authenticated");
  if (!user.roles.includes("Admin")) return res.status(403).send("Forbidden");
  res.send(`<h2>Welcome Admin ${user.name} 🎉</h2>`);
});

const PORT = process.env.PORT || 8080;
app.listen(PORT, () => console.log("Listening on", PORT));
```

### **package.json**

```json
{
  "name": "aca-auth-demo",
  "version": "1.0.0",
  "dependencies": { "express": "^4.19.2" },
  "scripts": { "start": "node app.js" }
}
```

### **Dockerfile**

```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package.json ./
RUN npm ci --omit=dev || npm i --omit=dev
COPY app.js ./
EXPOSE 8080
CMD ["npm", "start"]
```

Build image **locally** and push to a public registry **or** use ACR.
To keep Auth the focus, we’ll use **Microsoft sample image** first (no build needed), then we’ll swap to your image if you want.

---

## 2) Deploy the app (no auth yet)

We’ll deploy the stock hello-world first so we have a URL for Entra ID redirect URIs.

```bash
az containerapp create \
  -g $RG -n $APP_NAME \
  --environment $ENV_NAME \
  --image mcr.microsoft.com/azuredocs/containerapps-helloworld:latest \
  --target-port 80 \
  --ingress external \
  --min-replicas 0 --max-replicas 5
```

Get public FQDN:

```bash
APP_FQDN=$(az containerapp show -g $RG -n $APP_NAME --query properties.configuration.ingress.fqdn -o tsv)
echo "https://$APP_FQDN"
```

Open it in the browser to confirm the app is reachable.

---

## 3) Create an **App Registration** in Entra ID (OIDC)

You need an **App Registration** to represent your ACA app in Entra ID.
We’ll create it and set the **redirect URI** to your ACA URL.

```bash
# Create app registration
APP_DISPLAY="ACA Auth Demo"
APP_ID=$(az ad app create --display-name "$APP_DISPLAY" --query appId -o tsv)

# Add a redirect URI (Web type) = ACA FQDN
TENANT_ID=$(az account show --query tenantId -o tsv)
REDIRECT_URI="https://$APP_FQDN/.auth/login/aad/callback"
az ad app update --id $APP_ID --web-redirect-uris $REDIRECT_URI

echo "AppId: $APP_ID"
echo "Tenant: $TENANT_ID"
echo "Redirect: $REDIRECT_URI"
```

> If you want **roles**, add an `Admin` app role. You can do this in the portal (App → App roles) or via manifest. Portal is easiest:
> **Entra ID → App registrations → (your app) → App roles → Create**
>
> - Display name: `Admin`
> - Value: `Admin`
> - Allowed member type: `Users/Groups`
>   Then **assign** that app role to users/groups (Enterprise Applications → (your app) → Users and groups → Add user/group → select role).

---

## 4) Turn on **Auth** at the ACA Ingress

Now we wire ACA to that app registration and **require login**.

```bash
az containerapp auth microsoft update \
  --resource-group $RG \
  --name $APP_NAME \
  --client-id $APP_ID \
  --issuer "https://login.microsoftonline.com/$TENANT_ID/v2.0" \
  --allowed-token-audiences $APP_ID \
  --enable-auth true \
  --require-auth true
```

- `--require-auth true` means unauthenticated requests are **redirected to login**.
- After successful login, ACA validates the token and forwards **claims** via headers.

Test: browse `https://$APP_FQDN`.
You should be redirected to the Entra ID login page. After login, you return to the app.

---

## 5) (Optional) Swap to your **Node app** with role-check

If you built/pushed your own image (e.g., to ACR or Docker Hub), update the app:

```bash
# Example: using your public image
MY_IMAGE="ghcr.io/you/aca-auth-demo:v1"   # or ACR_SERVER/repo:tag
az containerapp update -g $RG -n $APP_NAME --image $MY_IMAGE --target-port 8080
```

Now hit:

- `/` → should show your UPN and any `roles` claim
- `/admin` → requires `Admin` role

> If you don’t see roles, ensure you **created and assigned the app role** to your user in Entra ID and re-login.

---

## 6) Understanding what ACA adds for you

- **OIDC dance** (redirects, token validation) is handled by ACA’s ingress.
- Your container only reads headers (`x-ms-client-principal*`) to **know who** and **what roles**.
- You can combine:

  - **Coarse-grained**: `--require-auth true` (block anonymous).
  - **Fine-grained**: in-app checks (roles, groups, email domain, etc.).

---

## 7) Troubleshooting

- **Redirect loops / 401**

  - Check `--issuer` and `--allowed-token-audiences` (AUD must match your `APP_ID`).
  - Ensure the **redirect URI** in App Registration is `https://<FQDN>/.auth/login/aad/callback`.

- **No roles in app**

  - Add an **App role** (value `Admin`) in App Registration.
  - Assign the role to your user/group via **Enterprise Applications** → (your app) → **Users and groups**.
  - Re-login (tokens are cached).

- **Group vs role claims**

  - If you prefer **groups**: configure the app to emit **group claims** (Token configuration → Add groups).
  - Then parse `groups` claim from `x-ms-client-principal` instead of `roles`.

- **Mixing providers**

  - You can also enable Google/GitHub/etc. Use:

    - `az containerapp auth google update ...`
    - `az containerapp auth github update ...`

  - Keep `--require-auth true` so **any** valid provider is required.

---

## 8) Clean up

```bash
az group delete -n $RG -y
```

---

## 🧠 Recap

- ACA acts as an **identity-aware proxy** (IAP): you configure providers; ACA enforces sign-in.
- Your app receives **validated identity and claims via headers**, so you can keep your code simple.
- For **AuthZ**, use Entra **app roles** (simplest) or **group claims**, and enforce in your app.
- Mix and match providers, require auth, split traffic by revision — all **without** running your own ingress/controller.

If you want, I can extend this with:

- **Key Vault token forwarding** (your app calls downstream APIs using user’s token)
- **Multiple providers** in one app (AAD + GitHub)
- **Internal-only** app with VNET ingress + AAD (zero public exposure)
