# 🚀 Project: Azure Container Apps — Web API + Redis

## 🧰 What you’ll build

- **Container Apps Environment** (the “cluster”)
- **Redis app** (internal only, port 6379)

  - Password enforced via `requirepass`
  - Password read from **Key Vault** through ACA **secret reference**
  - Min/Max replicas: `1/1` (stateful-ish)

- **Web API app** (public, port 8080)

  - Scales **0 → 10** based on HTTP concurrency
  - Reads `REDIS_HOST`, `REDIS_PORT`, `REDIS_PASSWORD` from config/KV

> We’ll use **ACA YAML** with Key Vault secret references (clean & repeatable).

---

## 0) Prereqs

```bash
# Login
az login --use-device-code

# Vars
export LOC=eastus
export RG=rg-aca-redis
export ACR_NAME=acaredis$RANDOM
export ACR_SERVER="$ACR_NAME.azurecr.io"
export ENV_NAME=aca-env-redis
export KV_NAME=kvacaredis$RANDOM
export REDIS_SECRET_NAME=RedisPassword
export REDIS_PASSWORD='S3cure!Redis#2025'   # for demo only; rotate/change in real usage

# Names for apps
export APP_REDIS=redis-internal
export APP_WEB=webapi-redis
```

Create resource group, ACR, Key Vault, Log Analytics (ACA requires it), ACA environment:

```bash
az group create -n $RG -l $LOC -o table
az acr create -g $RG -n $ACR_NAME --sku Basic -o table

# Log Analytics workspace for ACA diagnostics
LAW=logw-$RANDOM
az monitor log-analytics workspace create -g $RG -n $LAW -l $LOC
LAW_ID=$(az monitor log-analytics workspace show -g $RG -n $LAW --query customerId -o tsv)
LAW_KEY=$(az monitor log-analytics workspace get-shared-keys -g $RG -n $LAW --query primarySharedKey -o tsv)

# Container Apps Environment
az containerapp env create -g $RG -n $ENV_NAME -l $LOC \
  --logs-workspace-id $LAW_ID --logs-workspace-key $LAW_KEY
```

---

## 1) Build & push Web API image to ACR

- **Web API** (Node.js) → connects to Redis using env vars & password.

- **app.js**

  ```js
  const express = require("express");
  const Redis = require("ioredis");
  const app = express();

  const PORT = process.env.PORT || 8080;
  const REDIS_HOST = process.env.REDIS_HOST || "localhost";
  const REDIS_PORT = parseInt(process.env.REDIS_PORT || "6379", 10);
  const REDIS_PASSWORD = process.env.REDIS_PASSWORD || "";

  const redis = new Redis({
    host: REDIS_HOST,
    port: REDIS_PORT,
    password: REDIS_PASSWORD,
    maxRetriesPerRequest: 3, // fast-fail if redis not ready
  });

  app.get("/", async (_req, res) => {
    try {
      const visits = await redis.incr("visits");
      res.send(`
      <h1>ACA Web + Redis</h1>
      <p>REDIS: ${REDIS_HOST}:${REDIS_PORT}</p>
      <p>Visits = ${visits}</p>
      `);
    } catch (err) {
      res.status(500).send("Redis error: " + err.message);
    }
  });

  app.listen(PORT, () => console.log(`Web listening on ${PORT}`));
  ```

- **package.json**

  ```json
  {
    "name": "aca-web-redis",
    "version": "1.0.0",
    "dependencies": { "express": "^4.19.2", "ioredis": "^5.4.1" },
    "scripts": { "start": "node app.js" }
  }
  ```

- **Dockerfile**

  ```dockerfile
  FROM node:18-alpine
  WORKDIR /app
  COPY package.json ./
  RUN npm ci --omit=dev || npm i --omit=dev
  COPY app.js ./
  EXPOSE 8080
  CMD ["npm", "start"]
  ```

- **Build & push** (no local Docker needed):

  ```bash
  az acr build -r $ACR_NAME -t webapi-redis:v1 .
  ```

---

## 2) Key Vault secret + permissions

Create a secret and let ACA read it (no app secrets in YAML):

```bash
az keyvault create -g $RG -n $KV_NAME -l $LOC
az keyvault secret set -n $REDIS_SECRET_NAME --vault-name $KV_NAME --value "$REDIS_PASSWORD"
```

> ACA references Key Vault **by URL**. For this quickstart, we’ll use the built-in ACA identity feature that allows KV secret references in the app definition (no extra plumbing needed in the client code).

---

## 3) Deploy **Redis** (internal-only), with KV secret → env

Create `redis.yaml`:

```yaml
# redis.yaml
apiVersion: 2023-05-01
location: ${LOC}
name: ${APP_REDIS}
type: Microsoft.App/containerApps
properties:
  environmentId: ${ENV_ID}
  configuration:
    ingress:
      external: false
      targetPort: 6379
      transport: tcp
    secrets:
      - name: redis-password
        keyVaultSecretRef: https://${KV_NAME}.vault.azure.net/secrets/${REDIS_SECRET_NAME}
  template:
    revisionSuffix: v1
    containers:
      - name: redis
        image: redis:7-alpine
        env:
          - name: REDIS_PASSWORD
            secretRef: redis-password
        command:
          - "redis-server"
          - "--requirepass"
          - "$(REDIS_PASSWORD)"
          - "--appendonly"
          - "yes"
        resources:
          cpu: 0.5
          memory: 1Gi
    scale:
      minReplicas: 1
      maxReplicas: 1
```

Render & deploy:

```bash
# Get env resource ID for substitution
ENV_ID=$(az containerapp env show -g $RG -n $ENV_NAME --query id -o tsv)

envsubst < redis.yaml > redis.final.yaml
az containerapp create --resource-group $RG --name $APP_REDIS --yaml redis.final.yaml
```

Get the **internal FQDN** of Redis (we’ll inject it into the web app):

```bash
REDIS_FQDN=$(az containerapp show -g $RG -n $APP_REDIS --query properties.configuration.ingress.fqdn -o tsv)
echo "Redis internal FQDN: $REDIS_FQDN"
# Example: redis-internal.gray-hill-12345678.internal.azurecontainerapps.io
```

---

## 4) Deploy **Web API** (public), autoscaled, with KV secret

Create `web.yaml`:

```yaml
# web.yaml
apiVersion: 2023-05-01
location: ${LOC}
name: ${APP_WEB}
type: Microsoft.App/containerApps
properties:
  environmentId: ${ENV_ID}
  configuration:
    ingress:
      external: true
      targetPort: 8080
      transport: auto
    secrets:
      - name: redis-password
        keyVaultSecretRef: https://${KV_NAME}.vault.azure.net/secrets/${REDIS_SECRET_NAME}
  template:
    revisionSuffix: v1
    containers:
      - name: web
        image: ${ACR_SERVER}/webapi-redis:v1
        env:
          - name: PORT
            value: "8080"
          - name: REDIS_HOST
            value: ${REDIS_FQDN}
          - name: REDIS_PORT
            value: "6379"
          - name: REDIS_PASSWORD
            secretRef: redis-password
        resources:
          cpu: 0.5
          memory: 1Gi
    scale:
      minReplicas: 0
      maxReplicas: 10
      rules:
        - name: http-scale
          http:
            concurrentRequests: 50
  registryCredentials:
    - server: ${ACR_SERVER}
```

Grant the ACA environment permission to pull from ACR (easy button):

```bash
# This attaches ACR pull rights to the ACA environment's managed identity
az containerapp env set-flex-consumption-acr \
  --name $ENV_NAME --resource-group $RG \
  --acr $ACR_SERVER
```

> If the above command isn’t available in your CLI, you can instead:
>
> - Enable ACR admin and set `registryCredentials` with admin user/pass, OR
> - Create a user-assigned identity with **AcrPull** and attach it in `registryCredentials`.

Render & deploy:

```bash
envsubst < web.yaml > web.final.yaml
az containerapp create --resource-group $RG --name $APP_WEB --yaml web.final.yaml
```

Get public URL:

```bash
WEB_URL=$(az containerapp show -g $RG -n $APP_WEB \
  --query properties.configuration.ingress.fqdn -o tsv)
echo "https://$WEB_URL"
```

Open it in a browser. Refresh a few times—you should see **Visits** increment.
(ACA will **scale to zero** on idle; first hit after idle might take a short “cold start”.)

---

## 5) Prove autoscaling

Hammer it a bit:

```bash
# 200 concurrent curls to drive up concurrency
for i in {1..200}; do curl -s "https://$WEB_URL" >/dev/null & done; wait
```

Watch replicas grow:

```bash
az containerapp show -g $RG -n $APP_WEB --query properties.template.scale -o jsonc
az containerapp replica list -g $RG -n $APP_WEB -o table
```

---

## 6) Blue/Green (revision split) — optional

Push `v2`:

```bash
az acr build -r $ACR_NAME -t webapi-redis:v2 .
az containerapp update -g $RG -n $APP_WEB --image $ACR_SERVER/webapi-redis:v2
```

Split traffic (e.g., 80/20):

```bash
az containerapp ingress traffic set -g $RG -n $APP_WEB \
  --revision-weight latest=20 --revision-weight previous=80
```

Rollback instantly by flipping weights back to 100/0.

---

## 7) Clean up

```bash
az group delete -n $RG -y
```

---

## 🧠 Why this shows ACA’s strengths

- **KEDA autoscaling** on HTTP (scale 0→N) without HPA plumbing
- **Private internal services** (Redis) + **public APIs** (Web) in one environment
- **Key Vault secret references** → no secrets in code or YAML
- **Blue/green** with per-revision traffic routing
- **Minimal YAML**, no cluster, no ingress controller, no service mesh to run

---

### Variations you can try

- Swap Redis container for **Azure Cache for Redis** (managed), inject its hostname/SSL port as env vars.
- Turn on **Dapr** on the Web app and use Redis as a **Dapr state store**.
- Use **VNET-integrated** environment and private DNS if calling private services.
- Replace ACR with Docker Hub and supply `registryCredentials` for private repos.
