# ðŸ”„ ACA Revisions â€” Hands-On Canary & Rollback

hereâ€™s a **end-to-end hands-on** to master **ACA Revisions** with canary, blue/green, and instant rollback. Youâ€™ll:

- Create an **ACA environment**
- Deploy **v1** (Revision A)
- Switch to **Multiple revision mode**
- Split traffic (90/10 â†’ 50/50 â†’ 100/0)
- Deploy **v2** (Revision B) with a **suffix**
- Test per-revision URLs
- **Rollback** in one command
- Inspect logs/replicas per revision

> Uses the public `containerapps-helloworld` image so you can focus on **revisions**, not builds. You can swap in your image anytime.

---

## 0) Prereqs & Variables

```bash
az login --use-device-code

export RG=rg-aca-revisions
export LOC=eastus
export ENV_NAME=aca-env-rev
export APP_NAME=hello-rev
export LAW=logw-$RANDOM
```

Create resource group + Log Analytics + ACA environment:

```bash
az group create -n $RG -l $LOC -o table

az monitor log-analytics workspace create -g $RG -n $LAW -l $LOC
LAW_ID=$(az monitor log-analytics workspace show -g $RG -n $LAW --query customerId -o tsv)
LAW_KEY=$(az monitor log-analytics workspace get-shared-keys -g $RG -n $LAW --query primarySharedKey -o tsv)

az containerapp env create \
  -g $RG -n $ENV_NAME -l $LOC \
  --logs-workspace-id $LAW_ID \
  --logs-workspace-key $LAW_KEY
```

---

## 1) Deploy v1 (single revision mode by default)

```bash
az containerapp create \
  -g $RG -n $APP_NAME \
  --environment $ENV_NAME \
  --image mcr.microsoft.com/azuredocs/containerapps-helloworld:latest \
  --target-port 80 \
  --ingress external \
  --min-replicas 0 --max-replicas 5
```

Fetch public FQDN and test:

```bash
APP_FQDN=$(az containerapp show -g $RG -n $APP_NAME --query properties.configuration.ingress.fqdn -o tsv)
echo "https://$APP_FQDN"
curl -s "https://$APP_FQDN" | head
```

---

## 2) Enable **Multiple** revision mode

```bash
az containerapp update -g $RG -n $APP_NAME --revision-mode Multiple
```

List revisions (you should see one active):

```bash
az containerapp revision list -g $RG -n $APP_NAME -o table
```

Note the revision name (e.g., `hello-rev--abcde`). Weâ€™ll call it **revA**.

---

## 3) Create **Revision B (v2)** with a suffix

Weâ€™ll update the image (or just add an env var) to create a **new revision** with a friendly label.

```bash
# Create new revision by tweaking config (add an env var + suffix)
az containerapp update \
  -g $RG -n $APP_NAME \
  --set-env-vars APP_VERSION=v2 \
  --revision-suffix v2
```

List revisions again:

```bash
az containerapp revision list -g $RG -n $APP_NAME -o table
```

You should now see **two active revisions**. Identify:

- `revA` (older one, no suffix or a prior suffix)
- `revB` (the one with suffix `v2`)

> Each revision also has its **own FQDN** you can hit directly (great for smoke tests).

Get revision-specific URLs:

```bash
az containerapp revision list -g $RG -n $APP_NAME \
  --query "[].{name:name,fqdn:properties.fqdn,traffic:properties.trafficWeight,active:properties.active}" \
  -o table
```

Try the **direct revision** FQDNs (zero traffic is fineâ€”youâ€™re bypassing the router):

```bash
REV_B_FQDN=$(az containerapp revision show -g $RG -n $APP_NAME --revision $(az containerapp revision list -g $RG -n $APP_NAME --query "[?contains(name, 'v2')].name" -o tsv) --query properties.fqdn -o tsv)
echo "https://$REV_B_FQDN"
curl -s "https://$REV_B_FQDN" | head
```

---

## 4) Canary: split traffic 90/10 â†’ 50/50 â†’ 100/0

First, get both revision names:

```bash
REV_A=$(az containerapp revision list -g $RG -n $APP_NAME --query "[?properties.trafficWeight>0 && !contains(name, 'v2')].name" -o tsv | head -n1)
REV_B=$(az containerapp revision list -g $RG -n $APP_NAME --query "[?contains(name, 'v2')].name" -o tsv | head -n1)

echo "REV_A=$REV_A"
echo "REV_B=$REV_B"
```

### 90% to A, 10% to B

```bash
az containerapp ingress traffic set -g $RG -n $APP_NAME \
  --revision-weight $REV_A=90 $REV_B=10
```

### 50/50 split

```bash
az containerapp ingress traffic set -g $RG -n $APP_NAME \
  --revision-weight $REV_A=50 $REV_B=50
```

### 100% to B (promote canary)

```bash
az containerapp ingress traffic set -g $RG -n $APP_NAME \
  --revision-weight $REV_B=100
```

Check the split:

```bash
az containerapp ingress traffic show -g $RG -n $APP_NAME -o table
```

Drive traffic to see both revisions serve requests:

```bash
for i in {1..50}; do curl -s "https://$APP_FQDN" >/dev/null & done; wait
```

---

## 5) Rollback (instant)

If v2 misbehaves, **flip traffic back** in one command:

```bash
az containerapp ingress traffic set -g $RG -n $APP_NAME \
  --revision-weight $REV_A=100
```

You can also **deactivate** a revision (scales it to zero, keeps the config):

```bash
az containerapp revision deactivate -g $RG -n $APP_NAME --revision $REV_B
```

Reactivate later:

```bash
az containerapp revision activate -g $RG -n $APP_NAME --revision $REV_B
```

---

## 6) Logs & Replicas per revision

```bash
# Follow logs for a specific revision
az containerapp logs show -g $RG -n $APP_NAME --revision $REV_B --follow

# List replicas of a revision
az containerapp replica list -g $RG -n $APP_NAME --revision $REV_B -o table

# Describe a specific replica
REPLICA=$(az containerapp replica list -g $RG -n $APP_NAME --revision $REV_B --query "[0].name" -o tsv)
az containerapp replica show -g $RG -n $APP_NAME --revision $REV_B --replica $REPLICA -o jsonc
```

---

## 7) Clean up

```bash
az group delete -n $RG -y
```

---

## ðŸ§  Mental Model (for K8s folks)

- **Revision = immutable template snapshot** (think `ReplicaSet` w/ routing metadata).
- **Multiple mode** = Istio/NGINX-like traffic split, first-class in ACA (no mesh to manage).
- **Direct revision FQDN** = hit a specific ReplicaSet directly.
- **Deactivate** = scale revision to 0, keep for rollback.
- **Rollback** = traffic flip; no rebuild, no redeploy.
