# âš–ï¸ Azure Load Balancer â€” Advanced Configuration Considerations

> This section is about **fine-tuning your Azure Load Balancer** so it doesnâ€™t just _work_, but works **optimally, securely, and with the right feature set**.

---

## 1ï¸âƒ£ **Sticky Sessions** (Session Persistence) ğŸª

### ğŸ“Œ What It Is

A **sticky session** (also called _session affinity_) ensures that once a client connects to a backend VM, **all future requests from that same client go to the same VM** for the lifetime of the session.

---

### ğŸ” How It Works in Azure LB

- **Session persistence** is configured **per Load Balancing Rule**.
- Azure LB uses **Source IP Affinity** (a.k.a. _2-tuple_ or _3-tuple_ hashing) to make sure the same client IP hits the same backend.

| Mode                     | Description                                          | Example                                  |
| ------------------------ | ---------------------------------------------------- | ---------------------------------------- |
| **None**                 | No persistence, each request is routed independently | Good for stateless APIs                  |
| **Client IP**            | Maps based on clientâ€™s IP address                    | All requests from 203.0.113.25 â†’ same VM |
| **Client IP + Protocol** | Maps based on client IP + protocol (TCP/UDP)         | HTTP vs HTTPS connections separated      |

---

### ğŸ’¡ Use Case

- âœ… When backend VMs store **local session state** (e.g., ASP.NET in-process session state) rather than using Redis/AppFabric/SQL Session State.
- âš ï¸ Not recommended for truly stateless apps â€” it can create uneven load distribution.

---

## 2ï¸âƒ£ **Matching SKUs** (Public IP & Load Balancer) ğŸ­

### ğŸ“Œ What It Is

Your **Public IP Address SKU** must match your **Load Balancer SKU** â€” otherwise, they wonâ€™t work together.

---

### ğŸ” Why It Matters

- **Basic Public IP** â†” **Basic Load Balancer**
- **Standard Public IP** â†” **Standard Load Balancer**
- A mismatch = failed frontend binding.

---

### ğŸ“Š Feature Differences

| Feature            | Basic SKU            | Standard SKU               |
| ------------------ | -------------------- | -------------------------- |
| Availability Zones | âŒ                   | âœ…                         |
| Cross-region LB    | âŒ                   | âœ…                         |
| Secure by default  | âŒ (Open by default) | âœ… (Closed unless allowed) |
| SLA                | None                 | 99.99%                     |

---

### ğŸ’¡ Best Practice

- Always check SKU match **before** associating IP with LB.
- For production â€” **always** use Standard SKU (better security + HA + SLA).

---

## 3ï¸âƒ£ **Floating IPs** (Direct Server Return) ğŸŒŠ

### ğŸ“Œ What It Is

Enables **Direct Server Return (DSR)** â€” where the **frontend IP port + backend port are the same** for multiple backends, and backend VMs can reply directly to the client without going back through the LB.

---

### ğŸš§ The Problem Without Floating IP

Imagine you have **two services** (e.g., two SQL Always On replicas, or two websites) that both want to use **the same frontend port** â€” say **TCP 1433** for SQL or **Port 80** for HTTP.

**In a normal Load Balancer setup:**

- You must map **frontend port** â†’ **backend port** in a **1:1 mapping**.
- If two services use the same port, you **canâ€™t** send both through the LB to the same backend port because Azure says:

  > â€œSorry, that port is already taken by another rule.â€

ğŸ’¡ **Example:**

- LB Frontend 1433 â†’ Backend VM1:1433 âœ…
- LB Frontend 1433 â†’ Backend VM2:1433 âŒ (conflict â€” same mapping)

---

### ğŸ’¡ The Solution: Floating IP (Direct Server Return)

**Floating IP Mode** (enabled in the LB rule):

- Removes the requirement to translate ports.
- Allows the **same frontend IP + same frontend port** to be mapped to **multiple backend instances**, each listening on the **same backend port**.
- Used for **HA clustering** scenarios, where each backend VM has a **secondary private IP** that represents the service.

ğŸ“Œ **How it works:**

1. LB **forwards traffic** directly to the backend VM **without changing the destination IP or port**.
2. The backend VM **already owns** that IP (secondary IP config on its NIC), so it responds directly to the client (bypassing LB on the return path â€” called Direct Server Return).
3. This makes it possible for **multiple VMs** to handle requests on the same IP\:Port combo.

---

### ğŸ¯ Why itâ€™s Called â€œFloatingâ€

Because the **secondary IP** â€œfloatsâ€ between VMs in a cluster â€”

- If **VM1** goes down, **VM2** takes over the IP instantly.
- The LB doesnâ€™t need to change the rule â€” the IP just â€œmovesâ€ to another VM.

---

### ğŸ“ Real Example â€“ SQL Always On

**Without Floating IP:**

- Youâ€™d need SQL replicas listening on **different ports** (ugly and breaks client connection strings).

    <div align="left">
    <img src="image/az-lb-floating-ip-before.png" alt="Azure Load Balancer Floating IP Before" style="width: 80%; border-radius: 10px; border: 2px solid white;">
    </div>

**With Floating IP:**

- Both replicas have the **same secondary private IP** and **same port 1433**.
- LB sends traffic to whichever node currently owns that IP.

    <div align="left">
    <img src="image/az-lb-floating-ip-after.png" alt="Azure Load Balancer Floating IP After" style="width: 80%; border-radius: 10px; border: 2px solid white;">
    </div>

---

### âœ… When to Use Floating IP

- SQL Always On Availability Groups
- NLB-style clustering
- Any service requiring **same IP + same port** across multiple backend nodes

---

### âŒ When NOT to Use Floating IP

- Simple web apps without clustering
- When you donâ€™t control backend OS network config (Floating IP requires OS-level IP binding)
- For NAT scenarios (Floating IP disables port translation)

---

### ğŸ’¡ Use Case

- Database clustering (SQL Always On, MySQL HA)
- Failover scenarios where IP must remain constant

âš ï¸ **Not for web apps** â€” they usually require the LB to handle all responses.

---

## 4ï¸âƒ£ **HA Ports** (High Availability Ports) ğŸšª

### ğŸ“Œ What It Is

A **catch-all load balancing mode** â€” instead of defining individual LB rules for each port, you enable HA Ports so **all TCP/UDP ports** are load balanced.

---

### ğŸš§ The Problem Without HA Ports

A **normal Load Balancer rule** is locked to:

- **One frontend port** (e.g., 80)
- Mapped to **one backend port** (e.g., 80)

If you want to load balance **all TCP or UDP traffic** from a frontend IP (any port), youâ€™d need **one LB rule per port**.
Thatâ€™s fine for a website, but what if your VM needs to handle **thousands of ports**?

ğŸ’¡ Example:

- You have an **NVA (Network Virtual Appliance)** or a **firewall VM** that should inspect **all TCP traffic on all ports**.
- Creating 65,535 LB rules isâ€¦ insane.

---

### ğŸ’¡ The Solution: HA Ports

**HA Ports** = One LB rule that says:

> â€œSend **all traffic on all ports** from this frontend IP to the backend pool.â€

ğŸ“Œ **How it works:**

- No port filtering â€” it forwards **everything** (all TCP or all UDP ports).
- Used for **L3 scenarios** like NVAs, firewalls, or routing appliances.
- Works only with **Standard Load Balancer**.
- Backend VMs usually have **IP forwarding** enabled so they can route packets instead of terminating them.

---

### ğŸ¯ Key Difference from Floating IP

- **Floating IP**: Lets multiple VMs share **the same specific [IP+port]** without port translation (cluster failover scenario).
- **HA Ports**: Lets the LB forward **all ports** from a frontend IP to backend VMs (network appliance/routing scenario).

---

### ğŸ“ Real Example â€“ Firewall in Azure

Without HA Ports:

- Youâ€™d need separate LB rules for each port the firewall handles (HTTP = 80, HTTPS = 443, RDP = 3389, etc.).
- If tomorrow you need port 8443, you must add another rule.

With HA Ports:

- **One rule** â†’ forwards everything (0â€“65535 TCP) to firewall VM.
- Firewall VM decides what to allow/block.

---

### ğŸ–¼ Visual Flow

<div align="center">

```mermaid
flowchart TB
    Client["Any TCP/UDP port"] --> LB["Azure Standard LB\nFrontend IP: 20.1.1.1\nHA Ports Enabled"]
    LB --> FW1["Firewall VM1"]
    LB --> FW2["Firewall VM2"]

    style LB fill:#0b3150ff
    style FW1 fill:#643809ff
    style FW2 fill:#643809ff
```

</div>

---

### âœ… When to Use HA Ports

- NVAs, firewalls, routers in Azure
- Highly dynamic port requirements (no fixed list)
- Hybrid network appliances where you donâ€™t know in advance all the ports

---

### âŒ When NOT to Use HA Ports

- Simple web or API load balancing (use normal LB rules)
- When you want to NAT ports (HA Ports doesnâ€™t do port translation)

---

### ğŸ’¡ Use Case

- NVA (Network Virtual Appliances)
- Azure Firewall load balancing
- VPN gateways needing multi-port handling

---

## ğŸ **Summary**

| Feature         | Purpose                      | Where to Use               | Caution                 |
| --------------- | ---------------------------- | -------------------------- | ----------------------- |
| Sticky Sessions | Keep same client on same VM  | Local session state apps   | Uneven load possible    |
| Matching SKUs   | Ensure IP & LB compatibility | All deployments            | Mismatch = broken LB    |
| Floating IPs    | Direct Server Return for HA  | DB clusters, NLB migration | Not for normal web apps |
| HA Ports        | LB all ports/protocols       | NVAs, Azure Firewall       | Internal LB only        |

---

## ğŸ’¡ Quick Best Practices

- âœ… Use **Standard SKU** for production
- âœ… Enable **HA Ports** for appliances needing full port handling
- âœ… Avoid Sticky Sessions for stateless apps
- âœ… Document **SKU match** in infra diagrams to avoid config issues
