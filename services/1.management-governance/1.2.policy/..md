# üèõÔ∏è Azure Policy ‚Äî The Complete, No-Gaps Guide

Azure Policy is **Azure‚Äôs governance and compliance engine**. It evaluates resource configurations against your rules and **enforces** (or **audits**) them at scale across:  
**Management Groups ‚Üí Subscriptions ‚Üí Resource Groups ‚Üí Resources**.

---

## üß© Building Blocks (Who does what?)

- **Policy Definition** ‚Üí _The rule._ JSON logic (if/then) + parameters + effect.
- **Initiative (Policy Set)** ‚Üí _A bundle of rules._ Group multiple definitions to meet a standard (e.g., ISO/CIS).
- **Assignment** ‚Üí _Where the rule applies._ Binds a (parameterized) definition/initiative to a **scope** with optional **exclusions**.
- **Exemption** ‚Üí _Formal exception._ Temporarily or permanently excludes a resource/scope from a specific assignment (with category + reason).
- **Remediation Task** ‚Üí _Fix it!_ Brings **existing** non-compliant resources into compliance (often with **DeployIfNotExists** or **Modify**).

---

## üéõÔ∏è Scope, Inheritance & Exclusions

- Assign at any level: **MG / Subscription / RG / Resource**.
- **Inheritance**: children inherit assignments automatically.
- **Exclusions**: carve out specific RGs/resources from an assignment (great for pilots/edge cases).

---

## üß† Policy Rule Language (How rules think)

- **Structure**: `if` (conditions using **fields/aliases**) ‚Üí `then` (**effect**).
- **Aliases**: Canonical property paths for resource types (e.g., `Microsoft.Compute/virtualMachines/sku.name`, `location`, `tags['costCenter']`).
- **Operators**: `equals`, `in`, `notIn`, `like`, `contains`, `exists`, logical `allOf`/`anyOf`/`not`.
- **Parameters**: Make policies reusable (e.g., `allowedLocations`, `requiredTagName`).
- **Modes**:

  - **Indexed** ‚Üí Evaluates **ARM-indexed** resources (most common).
  - **All** ‚Üí Broader evaluation (used when you need non-indexed child properties).

> Tip: Use the **Alias browser** in the Portal (or `Get-AzPolicyAlias`) to find the exact property paths to target.

---

## üéØ Effects (What happens on (non)compliance?)

- **Deny** ‚ùå ‚Äî Blocks create/update.
- **Audit** üîç ‚Äî Doesn‚Äôt block; flags as non-compliant.
- **Append** ‚ûï ‚Äî Adds fields during request processing.
- **Modify** ‚úèÔ∏è ‚Äî Mutates the incoming request to comply (requires **assignment identity** + proper RBAC).
- **DeployIfNotExists (DINE)** üöÄ ‚Äî If a related resource/config is missing, deploy it (requires **assignment identity** + RBAC).
- **AuditIfNotExists** üëÄ ‚Äî Flags when related resource/config is missing.
- **Disabled** ‚è∏Ô∏è ‚Äî Allows quickly turning a rule off within an initiative.

> **Effect prerequisites**:
>
> - **Modify/DINE** need a **managed identity on the assignment** and **roleDefinitionIds** (permissions) so the policy engine can deploy/patch on your behalf.

---

## üß∑ Enforcement Mode (Block vs observe)

- **enforcementMode: Default** ‚Üí Effects behave normally (e.g., `deny` truly denies).
- **enforcementMode: DoNotEnforce** ‚Üí Policy still **evaluates** and logs compliance, but does **not block/modify**. Ideal for **‚Äúaudit-first‚Äù rollouts**.

---

## üßë‚Äç‚öñÔ∏è Exemptions (with categories)

Create **Exemptions** against an **assignment** (not the definition):

- **Waiver** ‚Üí Acknowledged exception; rule intentionally not applied.
- **Mitigated** ‚Üí Requirement satisfied by other controls (e.g., third-party tooling).
- **Time-bound** ‚Üí Add **expiry** and a **justification** for auditability.

Exempted resources show as **Exempt** and don‚Äôt count against compliance.

---

## üìä Compliance & States

The **Compliance dashboard** shows:

- **Compliant / NonCompliant / Exempt / NotStarted / Unknown**
- Per-policy, per-resource breakdown + drift trends
- Drill-downs to exact properties that failed

Evaluation occurs on **create/update** and in **periodic scans**.

---

## üß∞ Special Policy Domains

### 1) üê≥ Kubernetes (AKS) Policies

- Azure Policy + Gatekeeper (OPA) integrates with AKS to **admit/deny** manifests (e.g., forbid privileged pods).
- Use built-in **Kubernetes** category policies; enforce cluster hygiene **pre-admission**.

### 2) üßë‚Äçüíª Guest Configuration (inside VMs)

- Validate/ensure OS settings inside Windows/Linux VMs (e.g., password policy, BitLocker/DM-Crypt, services).
- Uses **DINE** to attach guest configuration agent/extensions, then **Audit/Modify**.

### 3) üîê Data-plane Limited Cases

- Azure Policy primarily governs the **control plane** (ARM).
- Certain providers (e.g., Key Vault data) have special modes/aliases; otherwise, use service-native controls for data-plane.

---

## üîÅ Remediation Deep-Dive

- **When**: After assigning a policy, existing resources might already be non-compliant.
- **How**: Create **Remediation Tasks** (Portal/CLI) to run `Modify` or `DINE` against the backlog.
- **Identity/RBAC**: The **assignment‚Äôs managed identity** must have the **exact roles** to patch or deploy the related resources.

---

## üß± Initiatives (Policy Sets)

- Group related policies (e.g., ‚ÄúProduction Baseline‚Äù, ‚ÄúCIS Foundations‚Äù).
- Parameterize once at the initiative level; propagate to members.
- Great for **landing zones** and **compliance standards** with 10s‚Äì100s of rules.

---

## üß® Common Pitfalls (and fixes)

- **Too-strict too soon** ‚Üí Start with **Audit** or **DoNotEnforce**, then flip to **Deny**.
- **Missing identity/RBAC** for Modify/DINE ‚Üí Add **system-assigned** identity on **assignment**, include proper **roleDefinitionIds**.
- **No tagging strategy** ‚Üí Define keys/allowed values first, then enforce.
- **Assigning many single policies** ‚Üí Use **Initiatives** for manageability and coherent reporting.
- **Forgetting exclusions** ‚Üí Exclude migration/edge RGs to prevent deployment blocks.

---

## üß™ Practical Examples

### A) **Require Tag** (deny if missing) ‚Äî JSON Definition

```json
{
  "properties": {
    "displayName": "Require tag on resources",
    "mode": "Indexed",
    "parameters": {
      "tagName": {
        "type": "String",
        "metadata": { "displayName": "Tag name" }
      }
    },
    "policyRule": {
      "if": {
        "field": "[concat('tags[', parameters('tagName'), ']')]",
        "exists": "false"
      },
      "then": { "effect": "deny" }
    }
  }
}
```

### B) **Auto-apply Diagnostic Settings** to Key Vaults ‚Äî DINE (snippet)

```json
"policyRule": {
  "if": {
    "field": "type",
    "equals": "Microsoft.KeyVault/vaults"
  },
  "then": {
    "effect": "DeployIfNotExists",
    "details": {
      "type": "Microsoft.Insights/diagnosticSettings",
      "existenceCondition": { "field": "Microsoft.Insights/diagnosticSettings/logs.enabled", "equals": "true" },
      "roleDefinitionIds": [
        "/providers/Microsoft.Authorization/roleDefinitions/abcd-...-monitor-contributor"
      ],
      "deployment": {
        "properties": {
          "mode": "incremental",
          "template": { /* ARM/Bicep template enabling diagnostics */ }
        }
      }
    }
  }
}
```

> Assign with a **managed identity**, grant it **Monitor Contributor** (or equivalent) on the targets.

### C) **Modify** example ‚Äî Append/normalize a tag

```json
"then": {
  "effect": "modify",
  "details": {
    "operations": [
      { "operation": "addOrReplace", "field": "tags.Environment", "value": "Prod" }
    ],
    "roleDefinitionIds": [
      "/providers/Microsoft.Authorization/roleDefinitions/b24988ac-6180-42a0-ab88-20f7382dd24c" /* Contributor */
    ]
  }
}
```

---

## üõ†Ô∏è Assignment & Remediation ‚Äî CLI & Bicep

### CLI (Az)

```bash
# Create definition
az policy definition create \
  --name require-tag \
  --display-name "Require Tag" \
  --rules ./require-tag.json \
  --mode Indexed \
  --params ./require-tag-params.json \
  --subscription <subId> \
  --category Tags

# Assign with identity + DoNotEnforce first
az policy assignment create \
  --name enforce-tag-rg \
  --policy require-tag \
  --scope /subscriptions/<subId>/resourceGroups/<rgName> \
  --params '{ "tagName": { "value": "costCenter" } }' \
  --enforcement-mode DoNotEnforce \
  --assign-identity

# Flip to enforce later
az policy assignment update --name enforce-tag-rg --enforcement-mode Default

# Start remediation for existing resources
az policy remediation create \
  --name fix-old-resources \
  --policy-assignment enforce-tag-rg \
  --scope /subscriptions/<subId>/resourceGroups/<rgName>
```

### Bicep ‚Äî Assignment with identity & exclusion

```bicep
param assignmentName string = 'enforce-tag-global'
param policyDefId string
param scope string
param tagName string = 'costCenter'
param excludedRgId string

resource assignment 'Microsoft.Authorization/policyAssignments@2022-06-01' = {
  name: assignmentName
  scope: resourceId('subscriptions', subscription().subscriptionId)
  properties: {
    displayName: 'Enforce Required Tag'
    policyDefinitionId: policyDefId
    enforcementMode: 'Default'
    parameters: {
      tagName: { value: tagName }
    }
    notScopes: [
      excludedRgId
    ]
  }
  identity: {
    type: 'SystemAssigned'
  }
  location: deployment().location // required when identity is used
}
```

---

## üîê RBAC & Identity for Remediation (must-know)

- **Assignment identity** must hold **exact roles** to patch/deploy.
- Add `roleDefinitionIds` inside **Modify/DINE** effects to declare which roles are needed.
- If remediation fails, check: **identity present? correct scope? correct roles?**

---

## üß≠ Governance at Scale

- **Initiatives** for standards (CIS/ISO/Prod Baseline).
- **Management Group hierarchy** to blast rules across tenants/subscriptions.
- **Exemptions** with justification and expiry for traceable exceptions.
- **Pipelines** (Bicep/ARM/Terraform) to manage definitions/assignments as **code**.

---

## ‚úÖ Best Practices Checklist

- Start with **Audit**/**DoNotEnforce**, then move to **Deny/Modify**.
- Put most rules into **Initiatives**; parameterize at the set level.
- Maintain a **tagging standard** and enforce it early.
- Always assign **managed identity** for **Modify/DINE** with the **right roles**.
- Use **exclusions** for migrations; create **time-bound exemptions** with **Waiver/Mitigated** categories.
- Monitor the **Compliance** blade; schedule periodic reviews.
- Include **AKS** and **Guest Configuration** policies for cluster & OS hygiene.
- Keep a **catalog** of your custom/built-in policies with versions and owners.

---

## üß™ Quick ‚ÄúTry It‚Äù Lab (Portal)

1. **Audit first**: Assign **‚ÄúAllowed locations‚Äù** with your region list, **DoNotEnforce**.
2. Create a resource in a blocked region ‚Üí see it **flagged** (not blocked).
3. Flip to **Default** enforcement ‚Üí try again ‚Üí now **Denied**.
4. Add an **Exemption** for one RG with **expiry** and **Waiver** reason.
5. Assign **DINE** ‚ÄúEnable diagnostic settings on Key Vault‚Äù with **identity** ‚Üí run **Remediation** ‚Üí watch existing vaults become compliant.

---

## üìù TL;DR

- **Policy Definition** (rules) ‚Üí **Initiative** (bundles) ‚Üí **Assignment** (where) ‚Üí **Exemption** (why not) ‚Üí **Remediation** (fix it).
- **Effects**: Deny, Audit, Append, Modify, DeployIfNotExists, AuditIfNotExists, Disabled.
- **Enforcement Mode**: **Default** vs **DoNotEnforce** (audit-only).
- **Identity & RBAC** are **mandatory** for **Modify/DINE** + remediation.
- **Compliance dashboard** gives states, drill-downs, and trends.
- Cover **AKS** (OPA Gatekeeper) and **Guest Configuration** for full-stack governance.

If you want, I can turn this into a **print-ready one-pager** or add a **Mermaid decision tree** that helps you pick the **right effect** (Audit vs Deny vs Modify vs DINE) for any scenario.
