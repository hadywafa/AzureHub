# 🔁 What happens on 1st sign-in vs next sign-in?

```mermaid
flowchart LR
  U[User on your Angular login page] --> P{Is this the user's first sign-in after cutover?}
  P -- Yes --> M[External ID policy calls your Migration API]
  M -->|Validate against your SQL Users table| DB["(On-prem SQL)"]
  DB -->|OK| E[Create user in Entra External ID + set password]
  E --> T["Issue tokens (ID/Access) to the app"]
  P -- No --> EE["External ID authenticates directly (no Migration API)"]
  EE --> T2["Issue tokens (ID/Access) to the app"]
```

- **First sign-in after cutover**:
  Entra External ID calls **your Migration API**, checks username/password against your SQL, **creates** the user in Entra, then returns tokens.

- **Second (and all future) sign-ins**:
  The user **authenticates directly in Entra External ID**.
  👉 **No call** to your Migration API anymore.
  (You can even delete/disable the migration step once most users have logged in once.)

- **SSO session**:
  If you enable it, subsequent apps can sign in **silently** using the same Entra session until it expires or the user signs out.

---

## 🧠 “Centralized identity” in Entra — what does that mean?

Think of Entra as the **single source of truth for authentication**:

- **One identity per user** across **all your apps**
- **One place** to enable MFA, Conditional Access, lock accounts, reset passwords
- **One set** of tokens/claims rules your apps consume

You still keep your **business logic** (registrations, event locks, entitlements) in **your own APIs + database**. Entra authenticates; **your systems authorize**.

---

## 🎛️ How can you customize it (without losing centralization)?

Here are the main “levers” you control:

### 1) 🔐 Sign-in/Sign-up Journey (the flow)

- **External ID “User flows” / “Custom policies”** let you shape **steps**: sign-in, sign-up, migration call, MFA, terms of use, profile edit, reset, etc.
- You decide **when** to call your Migration/Rules API (first login only, always, or never).

### 2) 🎨 UI & Branding (works with your Angular app)

- Keep your **Angular pages** as your main UI.
- Use External ID **custom page content** (or host your own pages) to ensure the identity screens **match your brand** (logo, CSS, language).
- You can tailor **per-journey** branding, so admin/consumer flows can look different.

### 3) 📇 User Profile Schema (attributes)

- Add **custom attributes** to the user profile (e.g., CustomerType, LegacyUserId).
- Map fields from your DB at first login, or enrich later via your APIs.
- Decide which attributes appear in **tokens** (as claims) vs only in your DB.

### 4) 🧾 Token Content (claims)

- Control **which claims** go into **ID/Access tokens** (e.g., LegacyUserId, tenant, entitlements snapshot).
- Keep tokens **minimal**; do **live checks** in your APIs for dynamic rules like “event locked”.

### 5) 🔐 Security Controls (central)

- Turn on **MFA**, **Conditional Access**, device/location policies, risk-based sign-in.
- These apply uniformly across all apps without per-app rewrites.

### 6) 👩‍💼 Admin & Governance

- Use the Entra **portal** for a centralized view of users, sign-ins, risk, lockouts.
- If you want a more tailored “admin console,” build a **lightweight admin UI** that talks to **Microsoft Graph** (list/search users, reset, disable, view attributes) — still centralized, but with **your** UX.

### 7) 🔗 App & API registrations

- Register **each API** (define **scopes** and **app roles**).
- Register **each client** (Angular, web, daemons) and assign the right permissions.
- Keeps permissions clean and auditable across your estate.

---

## 🛣️ Practical operating model (simple)

1. **Authenticate in Entra** (centralized, branded, MFA/CA).
2. **Get tokens** with a **few key claims** (e.g., `sub`/objectId, `LegacyUserId`).
3. **Authorize in your APIs** using your own DB (registrations, locks, quotas).
4. **Migrate passwords once** at first login; then **stop** calling your DB for auth.
5. Keep a **User ↔ Entra mapping** table so your FKs remain intact.

---

## 🧭 What happens to your “central view”?

- Entra becomes the **central view of identities and sign-ins** (who the user is, security settings, MFA, risk, last sign-in, lockouts).
- Your own admin/reporting continues to be the **central view of business state** (has the user registered, event lock, entitlements).
- If you need a **single pane**: build a small admin UI that **reads both** (Graph for Entra + your DB) and shows them together.

---

## 🏁 TL;DR

- **First login**: Entra External ID calls your Migration API → validates against your SQL → creates the user in Entra → issues tokens.
- **Next logins**: User authenticates **directly in Entra** (no migration call).
- **Centralization**: Auth is centralized in Entra; **you customize** journeys, UI, attributes, claims, and security policies.
- **Business rules** stay in your APIs/DB; use tokens + lookups to enforce them.
